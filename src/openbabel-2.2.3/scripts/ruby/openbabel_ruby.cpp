/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.39
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGRUBY


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif


/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.
  
  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/* 
   Flags/methods for returning states.
   
   The SWIG conversion methods, as ConvertPtr, return and integer 
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).
   
   Use the following macros/flags to set or process the returning
   states.
   
   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }
    
   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {         
        if (<obj is ok>) {			       
          if (<need new object>) {		       
            *ptr = <ptr to new allocated object>; 
            return SWIG_NEWOBJ;		       
          } else {				       
            *ptr = <ptr to old object>;	       
            return SWIG_OLDOBJ;		       
          } 				       
        } else {				       
          return SWIG_BADOBJ;		       
        }					       
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call
 
      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0) 
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)  

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) { 
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) { 
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0; 
}
#else /* no cast-rank mode */
#  define SWIG_AddCast
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/* 
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCompare(const char *nb, const char *tb) {
  int equiv = 0;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (!equiv && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = (SWIG_TypeNameComp(nb, ne, tb, te) == 0) ? 1 : 0;
    if (*ne) ++ne;
  }
  return equiv;
}


/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/* 
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/* 
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/* 
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;
  
  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }    
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}
  
/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start, 
                            swig_module_info *end, 
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      register size_t l = 0;
      register size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	register size_t i = (l + r) >> 1; 
	const char *iname = iter->types[i]->name;
	if (iname) {
	  register int compare = strcmp(name, iname);
	  if (compare == 0) {	    
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).
  
  We start searching at module start, and finish searching when start == end.  
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start, 
                     swig_module_info *end, 
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      register size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }
  
  /* neither found a match */
  return 0;
}

/* 
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  register const unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    register unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* 
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  register unsigned char *u = (unsigned char *) ptr;
  register const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    register char d = *(c++);
    register unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/* 
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



#include <ruby.h>

/* Remove global macros defined in Ruby's win32.h */
#ifdef write
# undef write
#endif
#ifdef read
# undef read
#endif
#ifdef bind
# undef bind
#endif


/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#ifdef HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/* RSTRING_LEN, etc are new in Ruby 1.9, but ->ptr and ->len no longer work */
/* Define these for older versions so we can just write code the new way */
#ifndef RSTRING_LEN
# define RSTRING_LEN(x) RSTRING(x)->len
#endif
#ifndef RSTRING_PTR
# define RSTRING_PTR(x) RSTRING(x)->ptr
#endif
#ifndef RSTRING_END
# define RSTRING_END(x) (RSTRING_PTR(x) + RSTRING_LEN(x))
#endif
#ifndef RARRAY_LEN
# define RARRAY_LEN(x) RARRAY(x)->len
#endif
#ifndef RARRAY_PTR
# define RARRAY_PTR(x) RARRAY(x)->ptr
#endif
#ifndef RFLOAT_VALUE
# define RFLOAT_VALUE(x) RFLOAT(x)->value
#endif
#ifndef DOUBLE2NUM
# define DOUBLE2NUM(x) rb_float_new(x)
#endif
#ifndef RHASH_TBL
# define RHASH_TBL(x) (RHASH(x)->tbl)
#endif
#ifndef RHASH_ITER_LEV
# define RHASH_ITER_LEV(x) (RHASH(x)->iter_lev)
#endif
#ifndef RHASH_IFNONE
# define RHASH_IFNONE(x) (RHASH(x)->ifnone)
#endif
#ifndef RHASH_SIZE
# define RHASH_SIZE(x) (RHASH(x)->tbl->num_entries)
#endif
#ifndef RHASH_EMPTY_P
# define RHASH_EMPTY_P(x) (RHASH_SIZE(x) == 0)
#endif
#ifndef RSTRUCT_LEN
# define RSTRUCT_LEN(x) RSTRUCT(x)->len
#endif
#ifndef RSTRUCT_PTR
# define RSTRUCT_PTR(x) RSTRUCT(x)->ptr
#endif



/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define PROTECTFUNC(f) ((VALUE (*)()) f)
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define PROTECTFUNC(f) ((VALUE (*)()) f)
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7+ */
#      define PROTECTFUNC(f) ((VALUE (*)(VALUE)) f)
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

/* Don't use for expressions have side effect */
#ifndef RB_STRING_VALUE
#define RB_STRING_VALUE(s) (TYPE(s) == T_STRING ? (s) : (*(volatile VALUE *)&(s) = rb_str_to_str(s)))
#endif
#ifndef StringValue
#define StringValue(s) RB_STRING_VALUE(s)
#endif
#ifndef StringValuePtr
#define StringValuePtr(s) RSTRING_PTR(RB_STRING_VALUE(s))
#endif
#ifndef StringValueLen
#define StringValueLen(s) RSTRING_LEN(RB_STRING_VALUE(s))
#endif
#ifndef SafeStringValue
#define SafeStringValue(v) do {\
    StringValue(v);\
    rb_check_safe_str(v);\
} while (0)
#endif

#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
#define rb_define_alloc_func(klass, func) rb_define_singleton_method((klass), "new", VALUEFUNC((func)), -1)
#define rb_undef_alloc_func(klass) rb_undef_method(CLASS_OF((klass)), "new")
#endif

static VALUE _mSWIG = Qnil;

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */


/* Define some additional error types */
#define SWIG_ObjectPreviouslyDeletedError  -100


/* Define custom exceptions for errors that do not map to existing Ruby
   exceptions.  Note this only works for C++ since a global cannot be
   initialized by a funtion in C.  For C, fallback to rb_eRuntimeError.*/

SWIGINTERN VALUE 
getNullReferenceError(void) {
  static int init = 0;
  static VALUE rb_eNullReferenceError ;
  if (!init) {
    init = 1;
    rb_eNullReferenceError = rb_define_class("NullReferenceError", rb_eRuntimeError);
  }
  return rb_eNullReferenceError;
} 

SWIGINTERN VALUE 
getObjectPreviouslyDeletedError(void) {
  static int init = 0;
  static VALUE rb_eObjectPreviouslyDeleted ;
  if (!init) {
    init = 1;
    rb_eObjectPreviouslyDeleted = rb_define_class("ObjectPreviouslyDeleted", rb_eRuntimeError);
  }
  return rb_eObjectPreviouslyDeleted;
} 


SWIGINTERN VALUE
SWIG_Ruby_ErrorType(int SWIG_code) {
  VALUE type;
  switch (SWIG_code) {
  case SWIG_MemoryError:
    type = rb_eNoMemError;
    break;
  case SWIG_IOError:
    type = rb_eIOError;
    break;
  case SWIG_RuntimeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_IndexError:
    type = rb_eIndexError;
    break;
  case SWIG_TypeError:
    type = rb_eTypeError;
    break;
  case SWIG_DivisionByZero:
    type = rb_eZeroDivError;
    break;
  case SWIG_OverflowError:
    type = rb_eRangeError;
    break;
  case SWIG_SyntaxError:
    type = rb_eSyntaxError;
    break;
  case SWIG_ValueError:
    type = rb_eArgError;
    break;
  case SWIG_SystemError:
    type = rb_eFatal;
    break;
  case SWIG_AttributeError:
    type = rb_eRuntimeError;
    break;
  case SWIG_NullReferenceError:
    type = getNullReferenceError();
    break;
  case SWIG_ObjectPreviouslyDeletedError:
    type = getObjectPreviouslyDeletedError();
    break;
  case SWIG_UnknownError:
    type = rb_eRuntimeError;
    break;
  default:
    type = rb_eRuntimeError;
  }
  return type;
}


/* This function is called when a user inputs a wrong argument to
   a method.
 */
SWIGINTERN 
const char* Ruby_Format_TypeError( const char* msg,
				   const char* type, 
				   const char* name, 
				   const int argn,
				   VALUE input )
{
  char buf[128];
  VALUE str;
  VALUE asStr;
  if ( msg && *msg )
    {
      str = rb_str_new2(msg);
    }
  else
    {
      str = rb_str_new(NULL, 0);
    }

  str = rb_str_cat2( str, "Expected argument " );
  sprintf( buf, "%d of type ", argn-1 );
  str = rb_str_cat2( str, buf );
  str = rb_str_cat2( str, type );
  str = rb_str_cat2( str, ", but got " );
  str = rb_str_cat2( str, rb_obj_classname(input) );
  str = rb_str_cat2( str, " " );
  asStr = rb_inspect(input);
  if ( RSTRING_LEN(asStr) > 30 )
    {
      str = rb_str_cat( str, StringValuePtr(asStr), 30 );
      str = rb_str_cat2( str, "..." );
    }
  else
    {
      str = rb_str_append( str, asStr );
    }

  if ( name )
    {
      str = rb_str_cat2( str, "\n\tin SWIG method '" );
      str = rb_str_cat2( str, name );
      str = rb_str_cat2( str, "'" );
    }

  return StringValuePtr( str );
}

/* This function is called when an overloaded method fails */
SWIGINTERN 
void Ruby_Format_OverloadedError(
				 const int argc,
				 const int maxargs,
				 const char* method, 
				 const char* prototypes 
				 )
{
  const char* msg = "Wrong # of arguments";
  if ( argc <= maxargs ) msg = "Wrong arguments";
  rb_raise(rb_eArgError,"%s for overloaded method '%s'.\n"  
	   "Possible C/C++ prototypes are:\n%s",
	   msg, method, prototypes);
}

/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubytracking.swg
 *
 * This file contains support for tracking mappings from 
 * Ruby objects to C++ objects.  This functionality is needed
 * to implement mark functions for Ruby's mark and sweep
 * garbage collector.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* Ruby 1.8 actually assumes the first case. */
#if SIZEOF_VOIDP == SIZEOF_LONG
#  define SWIG2NUM(v) LONG2NUM((unsigned long)v)
#  define NUM2SWIG(x) (unsigned long)NUM2LONG(x)
#elif SIZEOF_VOIDP == SIZEOF_LONG_LONG
#  define SWIG2NUM(v) LL2NUM((unsigned long long)v)
#  define NUM2SWIG(x) (unsigned long long)NUM2LL(x)
#else
#  error sizeof(void*) is not the same as long or long long
#endif


/* Global Ruby hash table to store Trackings from C/C++
   structs to Ruby Objects. 
*/
static VALUE swig_ruby_trackings = Qnil;

/* Global variable that stores a reference to the ruby
   hash table delete function. */
static ID swig_ruby_hash_delete;

/* Setup a Ruby hash table to store Trackings */
SWIGRUNTIME void SWIG_RubyInitializeTrackings(void) {
  /* Create a ruby hash table to store Trackings from C++ 
     objects to Ruby objects. */

  /* Try to see if some other .so has already created a 
     tracking hash table, which we keep hidden in an instance var
     in the SWIG module.
     This is done to allow multiple DSOs to share the same
     tracking table.
  */
  ID trackings_id = rb_intern( "@__trackings__" );
  VALUE verbose = rb_gv_get("VERBOSE");
  rb_gv_set("VERBOSE", Qfalse);
  swig_ruby_trackings = rb_ivar_get( _mSWIG, trackings_id );
  rb_gv_set("VERBOSE", verbose);

  /* No, it hasn't.  Create one ourselves */ 
  if ( swig_ruby_trackings == Qnil )
    {
      swig_ruby_trackings = rb_hash_new();
      rb_ivar_set( _mSWIG, trackings_id, swig_ruby_trackings );
    }

  /* Now store a reference to the hash table delete function
     so that we only have to look it up once.*/
  swig_ruby_hash_delete = rb_intern("delete");
}

/* Get a Ruby number to reference a pointer */
SWIGRUNTIME VALUE SWIG_RubyPtrToReference(void* ptr) {
  /* We cast the pointer to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the pointer to a Ruby number */
  return SWIG2NUM(ptr);
}

/* Get a Ruby number to reference an object */
SWIGRUNTIME VALUE SWIG_RubyObjectToReference(VALUE object) {
  /* We cast the object to an unsigned long
     and then store a reference to it using
     a Ruby number object. */

  /* Convert the Object to a Ruby number */
  return SWIG2NUM(object);
}

/* Get a Ruby object from a previously stored reference */
SWIGRUNTIME VALUE SWIG_RubyReferenceToObject(VALUE reference) {
  /* The provided Ruby number object is a reference
     to the Ruby object we want.*/

  /* Convert the Ruby number to a Ruby object */
  return NUM2SWIG(reference);
}

/* Add a Tracking from a C/C++ struct to a Ruby object */
SWIGRUNTIME void SWIG_RubyAddTracking(void* ptr, VALUE object) {
  /* In a Ruby hash table we store the pointer and
     the associated Ruby object.  The trick here is
     that we cannot store the Ruby object directly - if
     we do then it cannot be garbage collected.  So
     instead we typecast it as a unsigned long and
     convert it to a Ruby number object.*/

  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Get a reference to the Ruby object as a Ruby number */
  VALUE value = SWIG_RubyObjectToReference(object);

  /* Store the mapping to the global hash table. */
  rb_hash_aset(swig_ruby_trackings, key, value);
}

/* Get the Ruby object that owns the specified C/C++ struct */
SWIGRUNTIME VALUE SWIG_RubyInstanceFor(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Now lookup the value stored in the global hash table */
  VALUE value = rb_hash_aref(swig_ruby_trackings, key);
	
  if (value == Qnil) {
    /* No object exists - return nil. */
    return Qnil;
  }
  else {
    /* Convert this value to Ruby object */
    return SWIG_RubyReferenceToObject(value);
  }
}

/* Remove a Tracking from a C/C++ struct to a Ruby object.  It
   is very important to remove objects once they are destroyed
   since the same memory address may be reused later to create
   a new object. */
SWIGRUNTIME void SWIG_RubyRemoveTracking(void* ptr) {
  /* Get a reference to the pointer as a Ruby number */
  VALUE key = SWIG_RubyPtrToReference(ptr);

  /* Delete the object from the hash table by calling Ruby's
     do this we need to call the Hash.delete method.*/
  rb_funcall(swig_ruby_trackings, swig_ruby_hash_delete, 1, key);
}

/* This is a helper method that unlinks a Ruby object from its
   underlying C++ object.  This is needed if the lifetime of the
   Ruby object is longer than the C++ object */
SWIGRUNTIME void SWIG_RubyUnlinkObjects(void* ptr) {
  VALUE object = SWIG_RubyInstanceFor(ptr);

  if (object != Qnil) {
    DATA_PTR(object) = 0;
  }
}


#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------
 * Ruby API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN VALUE
SWIG_Ruby_AppendOutput(VALUE target, VALUE o) {
  if (NIL_P(target)) {
    target = o;
  } else {
    if (TYPE(target) != T_ARRAY) {
      VALUE o2 = target;
      target = rb_ary_new();
      rb_ary_push(target, o2);
    }
    rb_ary_push(target, o);
  }
  return target;
}

/* For ruby1.8.4 and earlier. */
#ifndef RUBY_INIT_STACK
   RUBY_EXTERN void Init_stack(VALUE* addr);
#  define RUBY_INIT_STACK \
   VALUE variable_in_this_stack_frame; \
   Init_stack(&variable_in_this_stack_frame);
#endif


#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * See the LICENSE file for information on copyright, usage and redistribution
 * of SWIG, and the README file for authors - http://www.swig.org/release.html.
 *
 * rubyrun.swg
 *
 * This file contains the runtime support for Ruby modules
 * and includes code for managing global variables and pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0

/* for raw pointers */
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Ruby_ConvertPtrAndOwn(obj, pptr, type, flags, own)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Ruby_NewPointerObj(ptr, type, flags)
#define SWIG_AcquirePtr(ptr, own)                       SWIG_Ruby_AcquirePtr(ptr, own)
#define swig_owntype                                    ruby_owntype

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty, flags)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_ConvertPtr(obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Ruby_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Ruby_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Ruby_GetModule()	
#define SWIG_SetModule(clientdata, pointer) 		SWIG_Ruby_SetModule(pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Ruby_ErrorType(code)               
#define SWIG_Error(code, msg)            		rb_raise(SWIG_Ruby_ErrorType(code), msg)
#define SWIG_fail                        		goto fail				 


/* Ruby-specific SWIG API */

#define SWIG_InitRuntime()                              SWIG_Ruby_InitRuntime()              
#define SWIG_define_class(ty)                        	SWIG_Ruby_define_class(ty)
#define SWIG_NewClassInstance(value, ty)             	SWIG_Ruby_NewClassInstance(value, ty)
#define SWIG_MangleStr(value)                        	SWIG_Ruby_MangleStr(value)		  
#define SWIG_CheckConvert(value, ty)                 	SWIG_Ruby_CheckConvert(value, ty)	  

#include "assert.h"

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
  VALUE klass;
  VALUE mImpl;
  void  (*mark)(void *);
  void  (*destroy)(void *);
  int trackObjects;
} swig_class;


/* Global pointer used to keep some internal SWIG stuff */
static VALUE _cSWIG_Pointer = Qnil;
static VALUE swig_runtime_data_type_pointer = Qnil;

/* Global IDs used to keep some internal SWIG stuff */
static ID swig_arity_id = 0;
static ID swig_call_id  = 0;

/*
  If your swig extension is to be run within an embedded ruby and has
  director callbacks, you should set -DRUBY_EMBEDDED during compilation.  
  This will reset ruby's stack frame on each entry point from the main 
  program the first time a virtual director function is invoked (in a 
  non-recursive way).
  If this is not done, you run the risk of Ruby trashing the stack.
*/

#ifdef RUBY_EMBEDDED

#  define SWIG_INIT_STACK                            \
      if ( !swig_virtual_calls ) { RUBY_INIT_STACK } \
      ++swig_virtual_calls;
#  define SWIG_RELEASE_STACK --swig_virtual_calls;
#  define Ruby_DirectorTypeMismatchException(x) \
          rb_raise( rb_eTypeError, x ); return c_result;

      static unsigned int swig_virtual_calls = 0;

#else  /* normal non-embedded extension */

#  define SWIG_INIT_STACK
#  define SWIG_RELEASE_STACK
#  define Ruby_DirectorTypeMismatchException(x) \
          throw Swig::DirectorTypeMismatchException( x );

#endif  /* RUBY_EMBEDDED */


SWIGRUNTIME VALUE 
getExceptionClass(void) {
  static int init = 0;
  static VALUE rubyExceptionClass ;
  if (!init) {
    init = 1;
    rubyExceptionClass = rb_const_get(_mSWIG, rb_intern("Exception"));
  }
  return rubyExceptionClass;
} 

/* This code checks to see if the Ruby object being raised as part
   of an exception inherits from the Ruby class Exception.  If so,
   the object is simply returned.  If not, then a new Ruby exception
   object is created and that will be returned to Ruby.*/
SWIGRUNTIME VALUE
SWIG_Ruby_ExceptionType(swig_type_info *desc, VALUE obj) {
  VALUE exceptionClass = getExceptionClass();
  if (rb_obj_is_kind_of(obj, exceptionClass)) {
    return obj;
  }  else {
    return rb_exc_new3(rb_eRuntimeError, rb_obj_as_string(obj));
  }
}

/* Initialize Ruby runtime support */
SWIGRUNTIME void
SWIG_Ruby_InitRuntime(void)
{
  if (_mSWIG == Qnil) {
    _mSWIG = rb_define_module("SWIG");
    swig_call_id  = rb_intern("call");
    swig_arity_id = rb_intern("arity");
  }
}

/* Define Ruby class for C type */
SWIGRUNTIME void
SWIG_Ruby_define_class(swig_type_info *type)
{
  VALUE klass;
  char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
  sprintf(klass_name, "TYPE%s", type->name);
  if (NIL_P(_cSWIG_Pointer)) {
    _cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
    rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
  }
  klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
  free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME VALUE
SWIG_Ruby_NewPointerObj(void *ptr, swig_type_info *type, int flags)
{
  int own =  flags & SWIG_POINTER_OWN; 
  int track;
  char *klass_name;
  swig_class *sklass;
  VALUE klass;
  VALUE obj;
  
  if (!ptr)
    return Qnil;
  
  if (type->clientdata) {
    sklass = (swig_class *) type->clientdata;
		
    /* Are we tracking this class and have we already returned this Ruby object? */
    track = sklass->trackObjects;
    if (track) {
      obj = SWIG_RubyInstanceFor(ptr);
      
      /* Check the object's type and make sure it has the correct type.
        It might not in cases where methods do things like 
        downcast methods. */
      if (obj != Qnil) {
        VALUE value = rb_iv_get(obj, "@__swigtype__");
        char* type_name = RSTRING_PTR(value);
				
        if (strcmp(type->name, type_name) == 0) {
          return obj;
        }
      }
    }

    /* Create a new Ruby object */
    obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), 
			   ( own ? VOIDFUNC(sklass->destroy) : 
			     (track ? VOIDFUNC(SWIG_RubyRemoveTracking) : 0 )
			     ), ptr);

    /* If tracking is on for this class then track this object. */
    if (track) {
      SWIG_RubyAddTracking(ptr, obj);
    }
  } else {
    klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    klass = rb_const_get(_mSWIG, rb_intern(klass_name));
    free((void *) klass_name);
    obj = Data_Wrap_Struct(klass, 0, 0, ptr);
  }
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  
  return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME VALUE
SWIG_Ruby_NewClassInstance(VALUE klass, swig_type_info *type)
{
  VALUE obj;
  swig_class *sklass = (swig_class *) type->clientdata;
  obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
  rb_iv_set(obj, "@__swigtype__", rb_str_new2(type->name));
  return obj;
}

/* Get type mangle from class name */
SWIGRUNTIMEINLINE char *
SWIG_Ruby_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "@__swigtype__");
  return StringValuePtr(stype);
}

/* Acquire a pointer value */
typedef void (*ruby_owntype)(void*);

SWIGRUNTIME ruby_owntype
SWIG_Ruby_AcquirePtr(VALUE obj, ruby_owntype own) {
  if (obj) {
    ruby_owntype oldown = RDATA(obj)->dfree;
    RDATA(obj)->dfree = own;
    return oldown;
  } else {
    return 0;
  }
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPtrAndOwn(VALUE obj, void **ptr, swig_type_info *ty, int flags, ruby_owntype *own)
{
  char *c;
  swig_cast_info *tc;
  void *vptr = 0;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return SWIG_OK;
  } else {
    if (TYPE(obj) != T_DATA) {
      return SWIG_ERROR;
    }
    Data_Get_Struct(obj, void, vptr);
  }
  
  if (own) *own = RDATA(obj)->dfree;
    
  /* Check to see if the input object is giving up ownership
     of the underlying C struct or C++ object.  If so then we
     need to reset the destructor since the Ruby object no 
     longer owns the underlying C++ object.*/ 
  if (flags & SWIG_POINTER_DISOWN) {
    /* Is tracking on for this class? */
    int track = 0;
    if (ty && ty->clientdata) {
      swig_class *sklass = (swig_class *) ty->clientdata;
      track = sklass->trackObjects;
    }
		
    if (track) {
      /* We are tracking objects for this class.  Thus we change the destructor
       * to SWIG_RubyRemoveTracking.  This allows us to
       * remove the mapping from the C++ to Ruby object
       * when the Ruby object is garbage collected.  If we don't
       * do this, then it is possible we will return a reference 
       * to a Ruby object that no longer exists thereby crashing Ruby. */
      RDATA(obj)->dfree = SWIG_RubyRemoveTracking;
    } else {    
      RDATA(obj)->dfree = 0;
    }
  }

  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
      if (rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
        if (vptr == 0) {
          /* The object has already been deleted */
          return SWIG_ObjectPreviouslyDeletedError;
        }
        *ptr = vptr;
        return SWIG_OK;
      }
    }
    if ((c = SWIG_MangleStr(obj)) == NULL) {
      return SWIG_ERROR;
    }
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) {
      return SWIG_ERROR;
    } else {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc, vptr, &newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  } else {
    *ptr = vptr;
  }
  
  return SWIG_OK;
}

/* Check convert */
SWIGRUNTIMEINLINE int
SWIG_Ruby_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c) return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

SWIGRUNTIME VALUE
SWIG_Ruby_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME int
SWIG_Ruby_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = StringValuePtr(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:
  return SWIG_ERROR;
}

SWIGRUNTIME swig_module_info *
SWIG_Ruby_GetModule(void)
{
  VALUE pointer;
  swig_module_info *ret = 0;
  VALUE verbose = rb_gv_get("VERBOSE");

 /* temporarily disable warnings, since the pointer check causes warnings with 'ruby -w' */
  rb_gv_set("VERBOSE", Qfalse);
  
  /* first check if pointer already created */
  pointer = rb_gv_get("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME);
  if (pointer != Qnil) {
    Data_Get_Struct(pointer, swig_module_info, ret);
  }

  /* reinstate warnings */
  rb_gv_set("VERBOSE", verbose);
  return ret;
}

SWIGRUNTIME void 
SWIG_Ruby_SetModule(swig_module_info *pointer)
{
  /* register a new class */
  VALUE cl = rb_define_class("swig_runtime_data", rb_cObject);
  /* create and store the structure pointer to a global variable */
  swig_runtime_data_type_pointer = Data_Wrap_Struct(cl, 0, 0, pointer);
  rb_define_readonly_variable("$swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, &swig_runtime_data_type_pointer);
}

/* This function can be used to check whether a proc or method or similarly
   callable function has been passed.  Usually used in a %typecheck, like:

   %typecheck(c_callback_t, precedence=SWIG_TYPECHECK_POINTER) {
        $result = SWIG_Ruby_isCallable( $input );
   }
 */
SWIGINTERN
int SWIG_Ruby_isCallable( VALUE proc )
{
  if ( rb_respond_to( proc, swig_call_id ) == Qtrue )
    return 1;
  return 0;
}

/* This function can be used to check the arity (number of arguments)
   a proc or method can take.  Usually used in a %typecheck.
   Valid arities will be that equal to minimal or those < 0
   which indicate a variable number of parameters at the end.
 */
SWIGINTERN
int SWIG_Ruby_arity( VALUE proc, int minimal )
{
  if ( rb_respond_to( proc, swig_arity_id ) == Qtrue )
    {
      VALUE num = rb_funcall( proc, swig_arity_id, 0 );
      int arity = NUM2INT(num);
      if ( arity < 0 && (arity+1) < -minimal ) return 1;
      if ( arity == minimal ) return 1;
      return 1;
    }
  return 0;
}


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg);; } while(0) 


/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_OpMap swig_types[0]
#define SWIGTYPE_p_OpenBabel__CharPtrLess swig_types[1]
#define SWIGTYPE_p_OpenBabel__DoubleType swig_types[2]
#define SWIGTYPE_p_OpenBabel__FastSearch swig_types[3]
#define SWIGTYPE_p_OpenBabel__FastSearchIndexer swig_types[4]
#define SWIGTYPE_p_OpenBabel__FptIndex swig_types[5]
#define SWIGTYPE_p_OpenBabel__FptIndexHeader swig_types[6]
#define SWIGTYPE_p_OpenBabel__LineSearchType swig_types[7]
#define SWIGTYPE_p_OpenBabel__OBAngle swig_types[8]
#define SWIGTYPE_p_OpenBabel__OBAngleData swig_types[9]
#define SWIGTYPE_p_OpenBabel__OBAromaticTyper swig_types[10]
#define SWIGTYPE_p_OpenBabel__OBAtom swig_types[11]
#define SWIGTYPE_p_OpenBabel__OBAtomAtomIter swig_types[12]
#define SWIGTYPE_p_OpenBabel__OBAtomBondIter swig_types[13]
#define SWIGTYPE_p_OpenBabel__OBAtomTyper swig_types[14]
#define SWIGTYPE_p_OpenBabel__OBBase swig_types[15]
#define SWIGTYPE_p_OpenBabel__OBBitVec swig_types[16]
#define SWIGTYPE_p_OpenBabel__OBBond swig_types[17]
#define SWIGTYPE_p_OpenBabel__OBChainsParser swig_types[18]
#define SWIGTYPE_p_OpenBabel__OBChiralData swig_types[19]
#define SWIGTYPE_p_OpenBabel__OBCommentData swig_types[20]
#define SWIGTYPE_p_OpenBabel__OBConformerData swig_types[21]
#define SWIGTYPE_p_OpenBabel__OBConversion swig_types[22]
#define SWIGTYPE_p_OpenBabel__OBDescriptor swig_types[23]
#define SWIGTYPE_p_OpenBabel__OBElement swig_types[24]
#define SWIGTYPE_p_OpenBabel__OBElementTable swig_types[25]
#define SWIGTYPE_p_OpenBabel__OBError swig_types[26]
#define SWIGTYPE_p_OpenBabel__OBExternalBond swig_types[27]
#define SWIGTYPE_p_OpenBabel__OBExternalBondData swig_types[28]
#define SWIGTYPE_p_OpenBabel__OBFFCalculation2 swig_types[29]
#define SWIGTYPE_p_OpenBabel__OBFFCalculation3 swig_types[30]
#define SWIGTYPE_p_OpenBabel__OBFFCalculation4 swig_types[31]
#define SWIGTYPE_p_OpenBabel__OBFFConstraint swig_types[32]
#define SWIGTYPE_p_OpenBabel__OBFFConstraints swig_types[33]
#define SWIGTYPE_p_OpenBabel__OBFFParameter swig_types[34]
#define SWIGTYPE_p_OpenBabel__OBFingerprint swig_types[35]
#define SWIGTYPE_p_OpenBabel__OBForceField swig_types[36]
#define SWIGTYPE_p_OpenBabel__OBFormat swig_types[37]
#define SWIGTYPE_p_OpenBabel__OBGenericData swig_types[38]
#define SWIGTYPE_p_OpenBabel__OBGlobalDataBase swig_types[39]
#define SWIGTYPE_p_OpenBabel__OBGridData swig_types[40]
#define SWIGTYPE_p_OpenBabel__OBInternalCoord swig_types[41]
#define SWIGTYPE_p_OpenBabel__OBIsotopeTable swig_types[42]
#define SWIGTYPE_p_OpenBabel__OBMatrixData swig_types[43]
#define SWIGTYPE_p_OpenBabel__OBMessageHandler swig_types[44]
#define SWIGTYPE_p_OpenBabel__OBMol swig_types[45]
#define SWIGTYPE_p_OpenBabel__OBMolAngleIter swig_types[46]
#define SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter swig_types[47]
#define SWIGTYPE_p_OpenBabel__OBMolAtomIter swig_types[48]
#define SWIGTYPE_p_OpenBabel__OBMolBondIter swig_types[49]
#define SWIGTYPE_p_OpenBabel__OBMolPairIter swig_types[50]
#define SWIGTYPE_p_OpenBabel__OBMolRingIter swig_types[51]
#define SWIGTYPE_p_OpenBabel__OBMolTorsionIter swig_types[52]
#define SWIGTYPE_p_OpenBabel__OBOp swig_types[53]
#define SWIGTYPE_p_OpenBabel__OBPairData swig_types[54]
#define SWIGTYPE_p_OpenBabel__OBPairTemplateT_double_t swig_types[55]
#define SWIGTYPE_p_OpenBabel__OBPairTemplateT_int_t swig_types[56]
#define SWIGTYPE_p_OpenBabel__OBPlugin swig_types[57]
#define SWIGTYPE_p_OpenBabel__OBPlugin__PluginMapType__const_iterator swig_types[58]
#define SWIGTYPE_p_OpenBabel__OBRTree swig_types[59]
#define SWIGTYPE_p_OpenBabel__OBRandom swig_types[60]
#define SWIGTYPE_p_OpenBabel__OBResidue swig_types[61]
#define SWIGTYPE_p_OpenBabel__OBResidueAtomIter swig_types[62]
#define SWIGTYPE_p_OpenBabel__OBResidueData swig_types[63]
#define SWIGTYPE_p_OpenBabel__OBResidueIter swig_types[64]
#define SWIGTYPE_p_OpenBabel__OBRing swig_types[65]
#define SWIGTYPE_p_OpenBabel__OBRingData swig_types[66]
#define SWIGTYPE_p_OpenBabel__OBRingSearch swig_types[67]
#define SWIGTYPE_p_OpenBabel__OBRingTyper swig_types[68]
#define SWIGTYPE_p_OpenBabel__OBRotationData swig_types[69]
#define SWIGTYPE_p_OpenBabel__OBSSMatch swig_types[70]
#define SWIGTYPE_p_OpenBabel__OBSerialNums swig_types[71]
#define SWIGTYPE_p_OpenBabel__OBSetData swig_types[72]
#define SWIGTYPE_p_OpenBabel__OBSmartsPattern swig_types[73]
#define SWIGTYPE_p_OpenBabel__OBSqrtTbl swig_types[74]
#define SWIGTYPE_p_OpenBabel__OBStopwatch swig_types[75]
#define SWIGTYPE_p_OpenBabel__OBSymmetryData swig_types[76]
#define SWIGTYPE_p_OpenBabel__OBTorsion swig_types[77]
#define SWIGTYPE_p_OpenBabel__OBTorsionData swig_types[78]
#define SWIGTYPE_p_OpenBabel__OBTypeTable swig_types[79]
#define SWIGTYPE_p_OpenBabel__OBUnitCell swig_types[80]
#define SWIGTYPE_p_OpenBabel__OBVectorData swig_types[81]
#define SWIGTYPE_p_OpenBabel__OBVibrationData swig_types[82]
#define SWIGTYPE_p_OpenBabel__OBVirtualBond swig_types[83]
#define SWIGTYPE_p_OpenBabel__Pattern swig_types[84]
#define SWIGTYPE_p_OpenBabel__SpaceGroup swig_types[85]
#define SWIGTYPE_p_OpenBabel__Template swig_types[86]
#define SWIGTYPE_p_OpenBabel__matrix3x3 swig_types[87]
#define SWIGTYPE_p_OpenBabel__obLogBuf swig_types[88]
#define SWIGTYPE_p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[89]
#define SWIGTYPE_p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[90]
#define SWIGTYPE_p_OpenBabel__vector3 swig_types[91]
#define SWIGTYPE_p_PluginIterator swig_types[92]
#define SWIGTYPE_p_PluginMapType swig_types[93]
#define SWIGTYPE_p_Unit swig_types[94]
#define SWIGTYPE_p_a_3__double swig_types[95]
#define SWIGTYPE_p_a_4__char swig_types[96]
#define SWIGTYPE_p_allocator_type swig_types[97]
#define SWIGTYPE_p_char swig_types[98]
#define SWIGTYPE_p_const_reference swig_types[99]
#define SWIGTYPE_p_difference_type swig_types[100]
#define SWIGTYPE_p_double swig_types[101]
#define SWIGTYPE_p_int swig_types[102]
#define SWIGTYPE_p_p_OpenBabel__OBAngleData swig_types[103]
#define SWIGTYPE_p_p_OpenBabel__OBChiralData swig_types[104]
#define SWIGTYPE_p_p_OpenBabel__OBCommentData swig_types[105]
#define SWIGTYPE_p_p_OpenBabel__OBConformerData swig_types[106]
#define SWIGTYPE_p_p_OpenBabel__OBDescriptor swig_types[107]
#define SWIGTYPE_p_p_OpenBabel__OBExternalBondData swig_types[108]
#define SWIGTYPE_p_p_OpenBabel__OBFingerprint swig_types[109]
#define SWIGTYPE_p_p_OpenBabel__OBForceField swig_types[110]
#define SWIGTYPE_p_p_OpenBabel__OBFormat swig_types[111]
#define SWIGTYPE_p_p_OpenBabel__OBGridData swig_types[112]
#define SWIGTYPE_p_p_OpenBabel__OBMatrixData swig_types[113]
#define SWIGTYPE_p_p_OpenBabel__OBOp swig_types[114]
#define SWIGTYPE_p_p_OpenBabel__OBPairData swig_types[115]
#define SWIGTYPE_p_p_OpenBabel__OBRingData swig_types[116]
#define SWIGTYPE_p_p_OpenBabel__OBRotationData swig_types[117]
#define SWIGTYPE_p_p_OpenBabel__OBSerialNums swig_types[118]
#define SWIGTYPE_p_p_OpenBabel__OBSetData swig_types[119]
#define SWIGTYPE_p_p_OpenBabel__OBSymmetryData swig_types[120]
#define SWIGTYPE_p_p_OpenBabel__OBTorsionData swig_types[121]
#define SWIGTYPE_p_p_OpenBabel__OBUnitCell swig_types[122]
#define SWIGTYPE_p_p_OpenBabel__OBVectorData swig_types[123]
#define SWIGTYPE_p_p_OpenBabel__OBVibrationData swig_types[124]
#define SWIGTYPE_p_p_OpenBabel__OBVirtualBond swig_types[125]
#define SWIGTYPE_p_p_double swig_types[126]
#define SWIGTYPE_p_p_int swig_types[127]
#define SWIGTYPE_p_p_void swig_types[128]
#define SWIGTYPE_p_reference swig_types[129]
#define SWIGTYPE_p_size_type swig_types[130]
#define SWIGTYPE_p_std__dequeT_int_t swig_types[131]
#define SWIGTYPE_p_std__istream swig_types[132]
#define SWIGTYPE_p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t swig_types[133]
#define SWIGTYPE_p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t swig_types[134]
#define SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t swig_types[135]
#define SWIGTYPE_p_std__multimapT_double_unsigned_int_t swig_types[136]
#define SWIGTYPE_p_std__ostream swig_types[137]
#define SWIGTYPE_p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t swig_types[138]
#define SWIGTYPE_p_std__streampos swig_types[139]
#define SWIGTYPE_p_std__string swig_types[140]
#define SWIGTYPE_p_std__type_info swig_types[141]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t swig_types[142]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator swig_types[143]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t swig_types[144]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator swig_types[145]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t swig_types[146]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type swig_types[147]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type swig_types[148]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t swig_types[149]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t swig_types[150]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type swig_types[151]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator swig_types[152]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type swig_types[153]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t swig_types[154]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator swig_types[155]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t swig_types[156]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type swig_types[157]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type swig_types[158]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator swig_types[159]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t swig_types[160]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type swig_types[161]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type swig_types[162]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t swig_types[163]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type swig_types[164]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator swig_types[165]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type swig_types[166]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t swig_types[167]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type swig_types[168]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type swig_types[169]
#define SWIGTYPE_p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t swig_types[170]
#define SWIGTYPE_p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t swig_types[171]
#define SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t swig_types[172]
#define SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type swig_types[173]
#define SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type swig_types[174]
#define SWIGTYPE_p_std__vectorT_double_p_std__allocatorT_double_p_t_t swig_types[175]
#define SWIGTYPE_p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator swig_types[176]
#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t swig_types[177]
#define SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type swig_types[178]
#define SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t swig_types[179]
#define SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type swig_types[180]
#define SWIGTYPE_p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t swig_types[181]
#define SWIGTYPE_p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t swig_types[182]
#define SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t swig_types[183]
#define SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type swig_types[184]
#define SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t swig_types[185]
#define SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t swig_types[186]
#define SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type swig_types[187]
#define SWIGTYPE_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t swig_types[188]
#define SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t swig_types[189]
#define SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type swig_types[190]
#define SWIGTYPE_p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t swig_types[191]
#define SWIGTYPE_p_swig__ConstIterator swig_types[192]
#define SWIGTYPE_p_swig__GC_VALUE swig_types[193]
#define SWIGTYPE_p_swig__Iterator swig_types[194]
#define SWIGTYPE_p_unsigned_int swig_types[195]
#define SWIGTYPE_p_value_type swig_types[196]
#define SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type swig_types[197]
#define SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type swig_types[198]
static swig_type_info *swig_types[200];
static swig_module_info swig_module = {swig_types, 199, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_OpenBabel
#define SWIG_name    "OpenBabel"

static VALUE mOpenBabel;

#define SWIG_RUBY_THREAD_BEGIN_BLOCK
#define SWIG_RUBY_THREAD_END_BLOCK


#define SWIGVERSION 0x010339 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


// used to set import/export for Cygwin DLLs
#ifdef WIN32
#define USING_OBDLL
#endif


#include <openbabel/obutil.h>
#include <openbabel/rand.h>
#include <openbabel/math/vector3.h>
#include <openbabel/math/matrix3x3.h>
#include <openbabel/griddata.h>
#include <openbabel/generic.h>

#include <openbabel/base.h>
#include <openbabel/mol.h>
#include <openbabel/atom.h>
#include <openbabel/bond.h>
#include <openbabel/residue.h>
#include <openbabel/internalcoord.h>

#include <openbabel/ring.h>
#include <openbabel/obconversion.h>
#include <openbabel/oberror.h>
#include <openbabel/plugin.h>
#include <openbabel/fingerprint.h>
#include <openbabel/descriptor.h>
#include <openbabel/format.h>

#include <openbabel/forcefield.h>
#include <openbabel/op.h>

#include <openbabel/data.h>
#include <openbabel/parsmart.h>


namespace swig {
  class GC_VALUE {
  protected:
    // Hash of all GC_VALUE's currently in use
    static VALUE _hash;

    VALUE  _obj;

    static ID hash_id;
    static ID   lt_id;
    static ID   gt_id;
    static ID   eq_id;
    static ID   le_id;
    static ID   ge_id;

    static ID  pos_id;
    static ID  neg_id;
    static ID  inv_id;

    static ID  add_id;
    static ID  sub_id;
    static ID  mul_id;
    static ID  div_id;
    static ID  mod_id;

    static ID  and_id;
    static ID   or_id;
    static ID  xor_id;

    static ID  lshift_id;
    static ID  rshift_id;

    struct OpArgs
    {
      VALUE src;
      ID    id;
      int   nargs;
      VALUE target;
    };


  public:
    static void initialize()
    {
      if ( _hash == Qnil ) 
	{ 
	  _hash = rb_hash_new();
	  rb_gc_register_address( &_hash );
	}
    }

    // this function is never called.  Provided for symmetry only.
    static void cleanup()
    {
      rb_gc_unregister_address( &_hash );
    }

    GC_VALUE() : _obj( Qnil )
    {
    }

    GC_VALUE(const GC_VALUE& item) : _obj(item._obj)
    {
      GC_register();
    }
    
    GC_VALUE(VALUE obj) :_obj(obj)
    {
      GC_register();
    }
    
    ~GC_VALUE() 
    {
      GC_unregister();
    }
    
    GC_VALUE & operator=(const GC_VALUE& item) 
    {
      GC_unregister();
      _obj = item._obj;
      GC_register();
      return *this;
    }

    void GC_register()
    {
      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
	return;
      VALUE val = rb_hash_aref( _hash, _obj );
      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 0;
      ++n;
      rb_hash_aset( _hash, _obj, INT2NUM(n) );
    }

    void GC_unregister()
    {
      if ( FIXNUM_P(_obj) || SPECIAL_CONST_P(_obj) || SYMBOL_P(_obj) ) 
	return;
      // this test should not be needed but I've noticed some very erratic
      // behavior of none being unregistered in some very rare situations.
      if ( BUILTIN_TYPE(_obj) == T_NONE ) return;

      VALUE val = rb_hash_aref( _hash, _obj );
      unsigned n = FIXNUM_P(val) ? NUM2UINT(val) : 1;
      --n;
      if ( n )
	rb_hash_aset( _hash, _obj, INT2NUM(n) );
      else
	rb_hash_delete( _hash, _obj );
    }
    
    operator VALUE() const
    {
      return _obj;
    }

    VALUE inspect() const
    {
      return rb_inspect(_obj);
    }

    VALUE to_s() const
    {
      return rb_inspect(_obj);
    }

    static VALUE swig_protect_funcall( VALUE p )
    {
      OpArgs* args = (OpArgs*) p;
      return rb_funcall( args->src, args->id, args->nargs, args->target );
    }


#define GC_VALUE_CMP( op_id, op, cmp, cmpval ) \
    bool op( const GC_VALUE& other ) const \
    { \
      if ( FIXNUM_P(_obj) && FIXNUM_P(other._obj) ) \
      { \
	return _obj cmp other._obj; \
      } \
      bool  res = false; \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      if ( rb_respond_to( _obj, op_id ) == Qtrue ) \
	{ \
	  int status; \
	  OpArgs  args; \
          args.src    = _obj; \
	  args.id     = op_id; \
	  args.nargs  = 1; \
	  args.target = VALUE(other); \
	  ret = rb_protect( PROTECTFUNC(swig_protect_funcall), \
                            VALUE(&args), &status ); \
	} \
      if ( ret == Qnil ) { \
	VALUE a = rb_funcall(         _obj, hash_id, 0 ); \
	VALUE b = rb_funcall( VALUE(other), hash_id, 0 ); \
	res = a cmp b; \
      } \
      else \
	{ \
	  res = RTEST( ret ); \
	} \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return res; \
    }


    GC_VALUE_CMP( eq_id, operator==, ==, == 0 )
    GC_VALUE_CMP( lt_id, operator<,  < , <  0 )
    GC_VALUE_CMP( le_id, operator<=, <=, <= 0 )
    GC_VALUE_CMP( gt_id, operator>,  > , >  0 )
    GC_VALUE_CMP( ge_id, operator>=, >=, >= 0 )
#undef GC_VALUE_CMP

    bool operator!=( const GC_VALUE& other )
    {
      return !(this->operator==(other));
    }

#define GC_VALUE_UNARY( proc_id, op ) \
    GC_VALUE op() const \
    { \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      int status; \
      OpArgs  args; \
      args.src    = _obj; \
      args.id     = proc_id; \
      args.nargs  = 0; \
      args.target = Qnil; \
      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
			&status ); \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return ret; \
    }

    GC_VALUE_UNARY( pos_id, operator+ )
    GC_VALUE_UNARY( neg_id, operator- )
    GC_VALUE_UNARY( inv_id, operator~ )
#undef GC_VALUE_BINARY

#define GC_VALUE_BINARY( proc_id, op ) \
    GC_VALUE op( const GC_VALUE& other ) const \
    { \
      VALUE ret = Qnil; \
      SWIG_RUBY_THREAD_BEGIN_BLOCK; \
      int status; \
      OpArgs  args; \
      args.src    = _obj; \
      args.id     = proc_id; \
      args.nargs  = 1; \
      args.target = VALUE(other); \
      ret = rb_protect( PROTECTFUNC(swig_protect_funcall), VALUE(&args), \
			&status ); \
      SWIG_RUBY_THREAD_END_BLOCK; \
      return GC_VALUE(ret); \
    }

    GC_VALUE_BINARY( add_id, operator+ );
    GC_VALUE_BINARY( sub_id, operator- );
    GC_VALUE_BINARY( mul_id, operator* );
    GC_VALUE_BINARY( div_id, operator/ );
    GC_VALUE_BINARY( mod_id, operator% );
    
    GC_VALUE_BINARY( and_id, operator& );
    GC_VALUE_BINARY( xor_id, operator^ );
    GC_VALUE_BINARY(  or_id, operator| );

    GC_VALUE_BINARY( lshift_id, operator<< );
    GC_VALUE_BINARY( rshift_id, operator>> );
#undef GC_VALUE_BINARY

  };

  ID  GC_VALUE::hash_id = rb_intern("hash");
  ID  GC_VALUE::lt_id = rb_intern("<");
  ID  GC_VALUE::gt_id = rb_intern(">");
  ID  GC_VALUE::eq_id = rb_intern("==");
  ID  GC_VALUE::le_id = rb_intern("<=");
  ID  GC_VALUE::ge_id = rb_intern(">=");

  ID  GC_VALUE::pos_id = rb_intern("+@");
  ID  GC_VALUE::neg_id = rb_intern("-@");
  ID  GC_VALUE::inv_id = rb_intern("~");

  ID  GC_VALUE::add_id = rb_intern("+");
  ID  GC_VALUE::sub_id = rb_intern("-");
  ID  GC_VALUE::mul_id = rb_intern("*");
  ID  GC_VALUE::div_id = rb_intern("/");
  ID  GC_VALUE::mod_id = rb_intern("%");

  ID  GC_VALUE::and_id = rb_intern("&");
  ID  GC_VALUE::or_id  = rb_intern("|");
  ID  GC_VALUE::xor_id = rb_intern("^");

  ID  GC_VALUE::lshift_id = rb_intern("<<");
  ID  GC_VALUE::rshift_id = rb_intern(">>");

  VALUE GC_VALUE::_hash = Qnil;

  typedef GC_VALUE LANGUAGE_OBJ;

} // namespace swig



#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>
#include <stdexcept>


#include <utility>


#include <iostream>

  
namespace swig {
  struct stop_iteration {
  };

  /** 
   * Abstract base class used to represent all iterators of STL containers.
   */
  struct ConstIterator {
  public:
    typedef ConstIterator self_type;

  protected:
    GC_VALUE _seq;

  protected:
    ConstIterator(VALUE seq) : _seq(seq)
    {
    }

    // Random access iterator methods, but not required in Ruby
    virtual ptrdiff_t distance(const ConstIterator &x) const
    {
      throw std::invalid_argument("distance not supported");
    }

    virtual bool equal (const ConstIterator &x) const
    {
      throw std::invalid_argument("equal not supported");
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("advance not supported");
    }
      
  public:
    virtual ~ConstIterator() {}

    // Access iterator method, required by Ruby
    virtual VALUE value() const {
      throw std::invalid_argument("value not supported");
      return Qnil;
    };

    virtual VALUE setValue( const VALUE& v ) {
      throw std::invalid_argument("value= not supported");
      return Qnil;
    }

    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    virtual VALUE to_s() const {
      throw std::invalid_argument("to_s not supported");
      return Qnil;
    }

    virtual VALUE inspect() const {
      throw std::invalid_argument("inspect not supported");
      return Qnil;
    }
    
    virtual ConstIterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }

    //
    // C++ common/needed methods.  We emulate a bidirectional
    // operator, to be compatible with all the STL.
    // The iterator traits will then tell the STL what type of
    // iterator we really are.
    //
    ConstIterator() : _seq( Qnil )
    {
    }

    ConstIterator( const self_type& b ) : _seq( b._seq )
    {
    }

    self_type& operator=( const self_type& b )
    {
      _seq = b._seq;
      return *this;
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const ConstIterator& x) const
    {
      return ! operator==(x);
    }
      
    // Pre-decrement operator
    self_type& operator--()
    {
      return *previous();
    }

    // Pre-increment operator
    self_type& operator++()
    {
      return *next();
    }

    // Post-decrement operator
    self_type operator--(int)
    {
      self_type r = *this;
      previous();
      return r;
    }

    // Post-increment operator
    self_type operator++(int)
    {
      self_type r = *this;
      next();
      return r;
    }

    ConstIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    ConstIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }

    ConstIterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    ConstIterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const ConstIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::ConstIterator *");
	init = 1;
      }	
      return desc;
    }
  };


  /**
   * Abstract base class used to represent all non-const iterators of STL containers.
   * 
   */
  struct Iterator : public ConstIterator {
  public:
    typedef Iterator self_type;

  protected:
    Iterator(VALUE seq) : ConstIterator(seq)
    {
    }

    virtual self_type* advance(ptrdiff_t n)
    {
      throw std::invalid_argument("operation not supported");
    }

  public:
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::Iterator *");
	init = 1;
      }	
      return desc;
    }
    
    virtual Iterator *dup() const
    {
      throw std::invalid_argument("dup not supported");
      return NULL;
    }
      
    virtual self_type* next( size_t n = 1 )
    {
      return this->advance( n );
    }

    virtual self_type* previous( size_t n = 1 )
    {
      ptrdiff_t nn = n;
      return this->advance( -nn );
    }

    bool operator == (const ConstIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const Iterator& x) const
    {
      return ! operator==(x);
    }
      
    Iterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    Iterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    Iterator* operator + (ptrdiff_t n) const
    {
      return dup()->advance(n);
    }

    Iterator* operator - (ptrdiff_t n) const
    {
      return dup()->advance(-n);
    }
      
    ptrdiff_t operator - (const Iterator& x) const
    {
      return x.distance(*this);
    }
  };

}


SWIGINTERN VALUE
SWIG_ruby_failed(void)
{
  return Qnil;
} 


/*@SWIG:/usr/local/share/swig/1.3.39/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2ULONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  unsigned long *res = (unsigned long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2ULONG(obj) : rb_big2ulong(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (VALUE obj, unsigned long *val) 
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    unsigned long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2ULONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (VALUE obj, size_t *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_bool  (bool value)
{
  return value ? Qtrue : Qfalse;
}


/*@SWIG:/usr/local/share/swig/1.3.39/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2LONG(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  long *res = (long *)(args[1]);
  *res = type == T_FIXNUM ? NUM2LONG(obj) : rb_big2long(obj);
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_long (VALUE obj, long* val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FIXNUM) || (type == T_BIGNUM)) {
    long v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2LONG), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (VALUE obj, ptrdiff_t *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, val ? &v : 0);
  if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  return res;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


  #define SWIG_From_long   LONG2NUM 


SWIGINTERNINLINE VALUE
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
  return SWIG_From_long  (static_cast< long >(value));
}


#include <stdexcept>


#include <algorithm>


#include <map>
#include <algorithm>
#include <stdexcept>


#include <vector>


#include <string>


SWIGINTERN int
SWIG_AsVal_int (VALUE obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}


namespace swig {  
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };  
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> 
  struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }    
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }    
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category> 
  struct traits_as { };
 
  template <class Type, class Category> 
  struct traits_check { };

}



namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static VALUE from(Type *val, int owner = 0) {
      return SWIG_NewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static VALUE from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static VALUE from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static VALUE from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline VALUE from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline VALUE from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(VALUE obj, Type **val) {
      Type *p;
      int res = SWIG_ConvertPtr(obj, (void**)&p, type_info<Type>(), 0);
      if (SWIG_IsOK(res)) {
	if (val) *val = p;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(VALUE obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(VALUE obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(VALUE obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(VALUE obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(VALUE obj, bool throw_error) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(VALUE obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	// Uninitialized return value, no Type() constructor required.
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	static Type *v_def = (Type*) malloc(sizeof(Type));
	memset(v_def,0,sizeof(Type));
	return *v_def;
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(VALUE obj, bool throw_error) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (throw_error) throw std::invalid_argument("bad type");
	VALUE lastErr = rb_gv_get("$!");
	if (lastErr == Qnil) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	return 0;
      }
    }
  };

  template <class Type>
  inline Type as(VALUE obj, bool te = false) {
    return traits_as< Type, typename traits< Type >::category >::as(obj, te);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(VALUE obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(VALUE obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(VALUE obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


namespace swig {
  template <> struct traits<int > {
    typedef value_category category;
    static const char* type_name() { return"int"; }
  };  
  template <>  struct traits_asval<int > {   
    typedef int value_type;
    static int asval(VALUE obj, value_type *val) { 
      return SWIG_AsVal_int (obj, val);
    }
  };
  template <>  struct traits_from<int > {
    typedef int value_type;
    static VALUE from(const value_type& val) {
      return SWIG_From_int  (val);
    }
  };
}


#include <functional>


namespace swig {
  template < class T >
  struct yield : public std::unary_function< T, bool >
  {
    bool
    operator()( const T& v ) const
    { 
      return RTEST( rb_yield( swig::from< T >(v) ) );
    }
  };


  inline size_t
  check_index(ptrdiff_t i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    
    throw std::out_of_range("index out of range");
  }

  inline size_t
  slice_index(ptrdiff_t i, size_t size) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size) {
	return (size_t) (i + size);
      } else {
	throw std::out_of_range("index out of range");
      }
    } else {
      return ( (size_t) i < size ) ? ((size_t) i) : size;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size);
    typename Sequence::size_type jj = swig::slice_index(j, size);

    if (jj > ii) {
      typename Sequence::const_iterator vb = self->begin();
      typename Sequence::const_iterator ve = self->begin();
      std::advance(vb,ii);
      std::advance(ve,jj);
      return new Sequence(vb, ve);
    } else {
      return new Sequence();
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, const InputSeq& v) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj < ii) jj = ii;
    size_t ssize = jj - ii;
    if (ssize <= v.size()) {
      typename Sequence::iterator sb = self->begin();
      typename InputSeq::const_iterator vmid = v.begin();
      std::advance(sb,ii);
      std::advance(vmid, jj - ii);
      self->insert(std::copy(v.begin(), vmid, sb), vmid, v.end());
    } else {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
      self->insert(sb, v.begin(), v.end());
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j) {
    typename Sequence::size_type size = self->size();
    typename Sequence::size_type ii = swig::check_index(i, size, true);
    typename Sequence::size_type jj = swig::slice_index(j, size);
    if (jj > ii) {
      typename Sequence::iterator sb = self->begin();
      typename Sequence::iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      self->erase(sb,se);
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {

  /** 
   * Templated base classes for all custom const_iterators.
   *
   */
  template<typename OutConstIterator>
  class ConstIterator_T :  public ConstIterator
  {
  public:
    typedef OutConstIterator const_iter;
    typedef typename std::iterator_traits<const_iter>::value_type value_type;    
    typedef ConstIterator_T<const_iter> self_type;

  protected:

    
    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:
    ConstIterator_T() : ConstIterator(Qnil)
    {
    }

    ConstIterator_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator(seq), current(curr)
    {
    }

    const const_iter& get_current() const
    {
      return current;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::const_iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    const_iter current;
  };


  /** 
   * Templated base classes for all custom non-const iterators.
   *
   */
  template<typename InOutIterator>
  class Iterator_T :  public Iterator
  {
  public:
    typedef InOutIterator nonconst_iter;

    // Make this class iterator STL compatible, by using iterator_traits
    typedef typename std::iterator_traits<nonconst_iter >::iterator_category iterator_category;
    typedef typename std::iterator_traits<nonconst_iter >::value_type        value_type;
    typedef typename std::iterator_traits<nonconst_iter >::difference_type   difference_type;
    typedef typename std::iterator_traits<nonconst_iter >::pointer           pointer;
    typedef typename std::iterator_traits<nonconst_iter >::reference         reference;

    typedef Iterator                         base;
    typedef Iterator_T< nonconst_iter > self_type;

  protected:

    virtual bool equal (const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    virtual ptrdiff_t distance(const ConstIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }

    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( current, n );
      return this;
    }

  public:

    Iterator_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator(seq), current(curr)
    {
    }

    const nonconst_iter& get_current() const
    {
      return current;
    }

    self_type& operator=( const self_type& b )
    {
      base::operator=( b );
      return *this;
    }
    
    self_type& operator=( const value_type& b )
    {
      *current = b;
      return *this;
    }

    const value_type& operator*() const
    {
      return *current;
    }

    value_type& operator*()
    {
      return *current;
    }
    
    virtual VALUE inspect() const
    {
      VALUE ret = rb_str_new2("#<");
      ret = rb_str_cat2( ret, rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_inspect(cur) );
      ret = rb_str_cat2( ret, ">" );
      return ret;
    }

    virtual VALUE to_s()    const
    {
      VALUE ret = rb_str_new2( rb_obj_classname(_seq) );
      ret = rb_str_cat2( ret, "::iterator " );
      VALUE cur = value();
      ret = rb_str_concat( ret, rb_obj_as_string(cur) );
      return ret;
    }

  protected:
    nonconst_iter current;
  };


  /**
   * Auxiliary functor to store the value of a ruby object inside
   * a reference of a compatible C++ type.  ie: Ruby -> C++
   * 
   */
  template <class ValueType>
  struct asval_oper 
  {
    typedef ValueType    value_type;
    typedef bool        result_type;
    bool operator()(VALUE obj, value_type& v) const
    {
      return ( swig::asval< value_type >(obj, &v) == SWIG_OK );
    }
  };

  /**
   * Auxiliary functor to return a ruby object from a C++ type. 
   * ie: C++ -> Ruby
   * 
   */
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef VALUE result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };


  /** 
   * ConstIterator class for a const_iterator with no end() boundaries.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorOpen_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;
    typedef ConstIteratorOpen_T<OutConstIterator, ValueType, FromOper> self_type;
    
    ConstIteratorOpen_T(const_iter curr, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * Iterator class for an iterator with no end() boundaries.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorOpen_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper  from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;

  public:
    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }
    
    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }

    virtual VALUE setValue( const VALUE& v )
    {
      value_type& dst = *base::current;
      if ( asval(v, dst) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
  };

  /** 
   * ConstIterator class for a const_iterator where begin() and end() boundaries are known.
   *
   */
  template<typename OutConstIterator, 
	   typename ValueType = typename std::iterator_traits<OutConstIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class ConstIteratorClosed_T :  public ConstIterator_T<OutConstIterator>
  {
  public:
    FromOper from;
    typedef OutConstIterator const_iter;
    typedef ValueType value_type;
    typedef ConstIterator_T<const_iter>  base;    
    typedef ConstIteratorClosed_T<OutConstIterator, ValueType, FromOper> self_type;
    
  protected:
    virtual ConstIterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    ConstIteratorClosed_T(const_iter curr, const_iter first, 
			  const_iter last, VALUE seq = Qnil)
      : ConstIterator_T<OutConstIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    ConstIterator *dup() const
    {
      return new self_type(*this);
    }


  private:
    const_iter begin;
    const_iter end;
  };

  /** 
   * Iterator class for a iterator where begin() and end() boundaries are known.
   *
   */
  template<typename InOutIterator, 
	   typename ValueType = typename std::iterator_traits<InOutIterator>::value_type,
	   typename FromOper = from_oper<ValueType>,
	   typename AsvalOper = asval_oper<ValueType> >
  class IteratorClosed_T :  public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef ValueType value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, ValueType, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    // Iterator setter method, required by Ruby
    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      value_type& dst = *base::current;
      if ( asval( v, dst ) ) return v;
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorOpen_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorOpen_T<InOutIterator, bool, FromOper, AsvalOper> self_type;

    IteratorOpen_T(nonconst_iter curr, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq)
    {
    }

    virtual VALUE value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    virtual VALUE setValue( const VALUE& v )
    {
      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }    
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }
    
  };

  /* Partial specialization for bools which don't allow de-referencing */
  template< typename InOutIterator, typename FromOper, typename AsvalOper >
  class IteratorClosed_T< InOutIterator, bool, FromOper, AsvalOper > : 
    public Iterator_T<InOutIterator>
  {
  public:
    FromOper   from;
    AsvalOper asval;
    typedef InOutIterator nonconst_iter;
    typedef bool value_type;
    typedef Iterator_T<nonconst_iter>  base;
    typedef IteratorClosed_T<InOutIterator, bool, FromOper, AsvalOper> self_type;
    
  protected:
    virtual Iterator* advance(ptrdiff_t n)
    {
      std::advance( base::current, n );
      if ( base::current == end )
	throw stop_iteration();
      return this;
    }

  public:
    IteratorClosed_T(nonconst_iter curr, nonconst_iter first, 
		     nonconst_iter last, VALUE seq = Qnil)
      : Iterator_T<InOutIterator>(curr, seq), begin(first), end(last)
    {
    }

    virtual VALUE value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }

    virtual VALUE setValue( const VALUE& v )
    {
      if (base::current == end)
	throw stop_iteration();

      bool tmp = *base::current;
      if ( asval( v, tmp ) )
	{
	  *base::current = tmp;
	  return v;
	}
      return Qnil;
    }
    
    Iterator *dup() const
    {
      return new self_type(*this);
    }

  private:
    nonconst_iter begin;
    nonconst_iter end;
  };


  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, const InOutIter& begin,
			 const InOutIter& end, VALUE seq = Qnil)
  {
    return new IteratorClosed_T<InOutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename InOutIter>
  inline Iterator*
  make_nonconst_iterator(const InOutIter& current, VALUE seq = Qnil)
  {
    return new IteratorOpen_T<InOutIter>(current, seq);
  }

  /** 
   * Helper function used to wrap a bounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, const OutIter& begin,
                       const OutIter& end, VALUE seq = Qnil)
  {
    return new ConstIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  /** 
   * Helper function used to wrap an unbounded const_iterator.  This is to be used in
   * a %typemap(out), for example.
   *
   */
  template<typename OutIter>
  inline ConstIterator*
  make_const_iterator(const OutIter& current, VALUE seq = Qnil)
  {
    return new ConstIteratorOpen_T<OutIter>(current, seq);
  }
}


namespace swig
{

  /**
   * This class is a proxy class for references, used to return and set values
   * of an element of a Ruby Array of stuff.
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   * 
   */
  template <class T>
  struct RubySequence_Ref
  {
    RubySequence_Ref(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      VALUE item = rb_ary_entry(_seq, _index );
      try {
	return swig::as<T>(item, true);
      } catch (std::exception& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", _index);
	VALUE lastErr = rb_gv_get("$!");
	if ( lastErr == Qnil ) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	VALUE str = rb_str_new2(msg);
	str = rb_str_cat2( str, e.what() );
	SWIG_Ruby_ExceptionType( NULL, str );
	throw;
      }
    }

    RubySequence_Ref& operator=(const T& v)
    {
      rb_ary_set(_seq, _index, swig::from< T >(v));
      return *this;
    }

  private:
    VALUE  _seq;
    int _index;
  };


  /**
   * This class is a proxy to return a pointer to a class, usually
   * RubySequence_Ref. 
   * It can be used by RubySequence_InputIterator to make it work with STL
   * algorithms.
   * 
   */
  template <class T>
  struct RubySequence_ArrowProxy
  {
    RubySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };


  /**
   * Input Iterator.  This adapator class is a random access iterator that 
   * allows you to use STL algorithms with a Ruby class (a Ruby Array by default).
   * 
   */
  template <class T, class Reference = RubySequence_Ref< T > >
  struct RubySequence_InputIterator
  {
    typedef RubySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef ptrdiff_t difference_type;

    RubySequence_InputIterator()
    {
    }

    RubySequence_InputIterator(VALUE  seq, int index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    RubySequence_ArrowProxy<T>
    operator->() const {
      return RubySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    VALUE  _seq;
    difference_type _index;
  };


  /**
   * This adaptor class allows you to use a Ruby Array as if it was an STL
   * container, giving it begin(), end(), and iterators.
   * 
   */
  template <class T>
  struct RubySequence_Cont
  {
    typedef RubySequence_Ref<T> reference;
    typedef const RubySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef int difference_type;
    typedef int size_type;
    typedef const pointer const_pointer;
    typedef RubySequence_InputIterator<T, reference> iterator;
    typedef RubySequence_InputIterator<T, const_reference> const_iterator;

    RubySequence_Cont(VALUE  seq) : _seq(0)
    {
      if (!rb_obj_is_kind_of(seq, rb_cArray)) {
	throw std::invalid_argument("an Array is expected");
      }
      _seq = seq;
    }

    ~RubySequence_Cont()
    {
    }

    size_type size() const
    {
      return RARRAY_LEN(_seq);
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check(bool set_err = false) const
    {
      int s = (int) size();
      for (int i = 0; i < s; ++i) {
	VALUE item = rb_ary_entry(_seq, i );
	if (!swig::check<value_type>(item)) {
	  if (set_err) {
	    char msg[1024];
	    sprintf(msg, "in sequence element %d", i);
	    SWIG_Error(SWIG_RuntimeError, msg);
	  }
	  return false;
	}
      }
      return true;
    }

  private:
    VALUE  _seq;
  };

}


namespace swig {
  template <class RubySeq, class Seq>
  inline void
  assign(const RubySeq& rubyseq, Seq* seq) {
    // seq->assign(rubyseq.begin(), rubyseq.end()); // not used as not always implemented
    typedef typename RubySeq::value_type value_type;
    typename RubySeq::const_iterator it = rubyseq.begin();
    for (;it != rubyseq.end(); ++it) {
      seq->insert(seq->end(),(value_type)(*it));
    }
  }

  template <class Seq, class T = typename Seq::value_type >
  struct traits_asptr_stdseq {
    typedef Seq sequence;
    typedef T value_type;

    static int asptr(VALUE obj, sequence **seq) {
      if (rb_obj_is_kind_of(obj, rb_cArray) == Qtrue) {
	try {
	  RubySequence_Cont<value_type> rubyseq(obj);
	  if (seq) {
	    sequence *pseq = new sequence();
	    assign(rubyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return rubyseq.check() ? SWIG_OK : SWIG_ERROR;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    VALUE lastErr = rb_gv_get("$!");
	    if (lastErr == Qnil) {
	      rb_raise(rb_eTypeError, e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      } else {
	sequence *p;
	if (SWIG_ConvertPtr(obj,(void**)&p,
			    swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      }
      return SWIG_ERROR;
    }
  };

  // Partial specialization for GC_VALUE's.  No need to typecheck each
  // element.
  template< class Seq >
  struct traits_asptr_stdseq< Seq, swig::GC_VALUE > {
    typedef Seq sequence;
    typedef swig::GC_VALUE value_type;

    static int asptr(VALUE obj, sequence **seq) {
      if (rb_obj_is_kind_of(obj, rb_cArray) == Qtrue) {
	try {
	  if (seq) {
	    RubySequence_Cont<value_type> rubyseq(obj);
	    sequence *pseq = new sequence();
	    assign(rubyseq, pseq);
	    *seq = pseq;
	    return SWIG_NEWOBJ;
	  } else {
	    return true;
	  }
	} catch (std::exception& e) {
	  if (seq) {
	    VALUE lastErr = rb_gv_get("$!");
	    if (lastErr == Qnil) {
	      rb_raise(rb_eTypeError, e.what());
	    }
	  }
	  return SWIG_ERROR;
	}
      } else {
	sequence *p;
	if (SWIG_ConvertPtr(obj,(void**)&p,
			    swig::type_info<sequence>(),0) == SWIG_OK) {
	  if (seq) *seq = p;
	  return SWIG_OLDOBJ;
	}
      }
      return SWIG_ERROR;
    }
  };

  template <class Seq, class T = typename Seq::value_type >
  struct traits_from_stdseq {
    typedef Seq sequence;
    typedef T value_type;
    typedef typename Seq::size_type size_type;
    typedef typename sequence::const_iterator const_iterator;

    static VALUE from(const sequence& seq) {






      size_type size = seq.size();
      if (size <= (size_type)INT_MAX) {
	VALUE obj = rb_ary_new2((int)size);
	int i = 0;
	for (const_iterator it = seq.begin();
	     it != seq.end(); ++it, ++i) {
	  RARRAY_PTR(obj)[i] = swig::from< value_type >(*it);
	}
	RARRAY_LEN(obj) = size;
	rb_obj_freeze(obj);  // treat as immutable result
	return obj;
      } else {
	rb_raise(rb_eRangeError,"sequence size not valid in ruby");
	return Qnil;
      }
    }
  };
}


  namespace swig {
    template <class T>
    struct traits_asptr<std::vector<T> >  {
      static int asptr(VALUE obj, std::vector<T> **vec) {
	return traits_asptr_stdseq<std::vector<T> >::asptr(obj, vec);
      }
    };
    
    template <class T>
    struct traits_from<std::vector<T> > {
      static VALUE from(const std::vector<T>& vec) {
	return traits_from_stdseq<std::vector<T> >::from(vec);
      }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<int, std::allocator< int > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "int" "," "std::allocator< int >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__dup(std::vector< int > *self){
      return new std::vector<int,std::allocator< int > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__inspect(std::vector< int > *self){
      std::vector<int,std::allocator< int > >::const_iterator i = self->begin();
      std::vector<int,std::allocator< int > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<int,std::allocator< int > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<int,std::allocator< int > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__to_a(std::vector< int > *self){
      std::vector<int,std::allocator< int > >::const_iterator i = self->begin();
      std::vector<int,std::allocator< int > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<int,std::allocator< int > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__to_s(std::vector< int > *self){
      std::vector<int,std::allocator< int > >::iterator i = self->begin();
      std::vector<int,std::allocator< int > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<int,std::allocator< int > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__slice(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<int,std::allocator< int > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__each(std::vector< int > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<int,std::allocator< int > >::const_iterator i = self->begin();
	std::vector<int,std::allocator< int > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<int,std::allocator< int > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__select(std::vector< int > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<int,std::allocator< int > >* r = new std::vector<int,std::allocator< int > >;
      std::vector<int,std::allocator< int > >::const_iterator i = self->begin();
      std::vector<int,std::allocator< int > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<int,std::allocator< int > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__reject_bang(std::vector< int > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<int,std::allocator< int > >::iterator i = self->begin();
      std::vector<int,std::allocator< int > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<int,std::allocator< int > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__delete_at(std::vector< int > *self,std::vector< int >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<int,std::allocator< int > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<int,std::allocator< int > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg____delete2__(std::vector< int > *self,std::vector< int >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__pop(std::vector< int > *self){
      if (self->empty()) return Qnil;
      std::vector<int,std::allocator< int > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<int,std::allocator< int > >::value_type >( x );
    }
SWIGINTERN std::vector< int >::value_type const std_vector_Sl_int_Sg__push(std::vector< int > *self,std::vector< int >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__reject(std::vector< int > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<int,std::allocator< int > >* r = new std::vector<int,std::allocator< int > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<int,std::allocator< int > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__at(std::vector< int > const *self,std::vector< int >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<int,std::allocator< int > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg____getitem____SWIG_0(std::vector< int > const *self,std::vector< int >::difference_type i,std::vector< int >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<int,std::allocator< int > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg____getitem____SWIG_1(std::vector< int > const *self,std::vector< int >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<int,std::allocator< int > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg____getitem____SWIG_2(std::vector< int > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<int,std::allocator< int > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg____setitem____SWIG_0(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<int,std::allocator< int > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_int_Sg____setitem____SWIG_1(std::vector< int > *self,std::vector< int >::difference_type i,std::vector< int >::difference_type j,std::vector< int,std::allocator< int > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<int,std::allocator< int > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_int_Sg__shift(std::vector< int > *self){
      if (self->empty()) return Qnil;
      std::vector<int,std::allocator< int > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<int,std::allocator< int > >::value_type >( x );
    }
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__insert__SWIG_0(std::vector< int > *self,std::vector< int >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<int,std::allocator< int > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<int,std::allocator< int > >::value_type val = swig::as<std::vector<int,std::allocator< int > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<int,std::allocator< int > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<int,std::allocator< int > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__unshift(std::vector< int > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<int,std::allocator< int > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<int,std::allocator< int > >::value_type val = swig::as<std::vector<int,std::allocator< int > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<int,std::allocator< int > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return ULONG2NUM(value); 
}


SWIGINTERNINLINE VALUE
SWIG_From_size_t  (size_t value)
{    
  return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
}

SWIGINTERN std::vector< int,std::allocator< int > > *std_vector_Sl_int_Sg__map_bang(std::vector< int > *self){

    if ( !rb_block_given_p() )
      rb_raise( rb_eArgError, "No block given" );

    VALUE r = Qnil;
    std::vector< int >::iterator i = self->begin();
    std::vector< int >::iterator e = self->end();

    try {
      for ( ; i != e; ++i )
	{
	  r = swig::from< int >( *i );
	  r = rb_yield( r );
	  *i = swig::as< int >( r );
	}
    }
    catch ( const std::invalid_argument& )
      {
	rb_raise(rb_eTypeError,
		 "Yield block did not return a valid element for ""%arg(std::vector)");
      }
    
    return self;
  }
SWIGINTERN VALUE std_vector_Sl_int_Sg____delete__(std::vector< int > *self,int const &val){
    VALUE r = Qnil;
    std::vector<int >::iterator e = self->end();
    std::vector<int >::iterator i = std::remove( self->begin(), e, val );
    // remove dangling elements now
    self->erase( i, e );
    
    if ( i != e )
      r = swig::from< int >( val );
    else if ( rb_block_given_p() )
      r = rb_yield(Qnil);
    return r;
  }

SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (VALUE obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


namespace swig {
  template <> struct traits<unsigned int > {
    typedef value_category category;
    static const char* type_name() { return"unsigned int"; }
  };  
  template <>  struct traits_asval<unsigned int > {   
    typedef unsigned int value_type;
    static int asval(VALUE obj, value_type *val) { 
      return SWIG_AsVal_unsigned_SS_int (obj, val);
    }
  };
  template <>  struct traits_from<unsigned int > {
    typedef unsigned int value_type;
    static VALUE from(const value_type& val) {
      return SWIG_From_unsigned_SS_int  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::vector<unsigned int, std::allocator< unsigned int > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "unsigned int" "," "std::allocator< unsigned int >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__dup(std::vector< unsigned int > *self){
      return new std::vector<unsigned int,std::allocator< unsigned int > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__inspect(std::vector< unsigned int > *self){
      std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator i = self->begin();
      std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<unsigned int,std::allocator< unsigned int > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__to_a(std::vector< unsigned int > *self){
      std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator i = self->begin();
      std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__to_s(std::vector< unsigned int > *self){
      std::vector<unsigned int,std::allocator< unsigned int > >::iterator i = self->begin();
      std::vector<unsigned int,std::allocator< unsigned int > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__slice(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<unsigned int,std::allocator< unsigned int > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__each(std::vector< unsigned int > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator i = self->begin();
	std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__select(std::vector< unsigned int > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<unsigned int,std::allocator< unsigned int > >* r = new std::vector<unsigned int,std::allocator< unsigned int > >;
      std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator i = self->begin();
      std::vector<unsigned int,std::allocator< unsigned int > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__reject_bang(std::vector< unsigned int > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<unsigned int,std::allocator< unsigned int > >::iterator i = self->begin();
      std::vector<unsigned int,std::allocator< unsigned int > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__delete_at(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<unsigned int,std::allocator< unsigned int > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____delete2__(std::vector< unsigned int > *self,std::vector< unsigned int >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__pop(std::vector< unsigned int > *self){
      if (self->empty()) return Qnil;
      std::vector<unsigned int,std::allocator< unsigned int > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( x );
    }
SWIGINTERN std::vector< unsigned int >::value_type const std_vector_Sl_unsigned_SS_int_Sg__push(std::vector< unsigned int > *self,std::vector< unsigned int >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__reject(std::vector< unsigned int > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<unsigned int,std::allocator< unsigned int > >* r = new std::vector<unsigned int,std::allocator< unsigned int > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__at(std::vector< unsigned int > const *self,std::vector< unsigned int >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____getitem____SWIG_0(std::vector< unsigned int > const *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<unsigned int,std::allocator< unsigned int > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____getitem____SWIG_1(std::vector< unsigned int > const *self,std::vector< unsigned int >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____getitem____SWIG_2(std::vector< unsigned int > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<unsigned int,std::allocator< unsigned int > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____setitem____SWIG_0(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____setitem____SWIG_1(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type i,std::vector< unsigned int >::difference_type j,std::vector< unsigned int,std::allocator< unsigned int > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<unsigned int,std::allocator< unsigned int > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg__shift(std::vector< unsigned int > *self){
      if (self->empty()) return Qnil;
      std::vector<unsigned int,std::allocator< unsigned int > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<unsigned int,std::allocator< unsigned int > >::value_type >( x );
    }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__insert__SWIG_0(std::vector< unsigned int > *self,std::vector< unsigned int >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<unsigned int,std::allocator< unsigned int > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<unsigned int,std::allocator< unsigned int > >::value_type val = swig::as<std::vector<unsigned int,std::allocator< unsigned int > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<unsigned int,std::allocator< unsigned int > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<unsigned int,std::allocator< unsigned int > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__unshift(std::vector< unsigned int > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<unsigned int,std::allocator< unsigned int > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<unsigned int,std::allocator< unsigned int > >::value_type val = swig::as<std::vector<unsigned int,std::allocator< unsigned int > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<unsigned int,std::allocator< unsigned int > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }
SWIGINTERN std::vector< unsigned int,std::allocator< unsigned int > > *std_vector_Sl_unsigned_SS_int_Sg__map_bang(std::vector< unsigned int > *self){

    if ( !rb_block_given_p() )
      rb_raise( rb_eArgError, "No block given" );

    VALUE r = Qnil;
    std::vector< unsigned int >::iterator i = self->begin();
    std::vector< unsigned int >::iterator e = self->end();

    try {
      for ( ; i != e; ++i )
	{
	  r = swig::from< unsigned int >( *i );
	  r = rb_yield( r );
	  *i = swig::as< unsigned int >( r );
	}
    }
    catch ( const std::invalid_argument& )
      {
	rb_raise(rb_eTypeError,
		 "Yield block did not return a valid element for ""%arg(std::vector)");
      }
    
    return self;
  }
SWIGINTERN VALUE std_vector_Sl_unsigned_SS_int_Sg____delete__(std::vector< unsigned int > *self,unsigned int const &val){
    VALUE r = Qnil;
    std::vector<unsigned int >::iterator e = self->end();
    std::vector<unsigned int >::iterator i = std::remove( self->begin(), e, val );
    // remove dangling elements now
    self->erase( i, e );
    
    if ( i != e )
      r = swig::from< unsigned int >( val );
    else if ( rb_block_given_p() )
      r = rb_yield(Qnil);
    return r;
  }

      namespace swig {
	template <>  struct traits<std::vector<std::vector< int,std::allocator< int > >, std::allocator< std::vector< int,std::allocator< int > > > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "std::vector< int,std::allocator< int > >" "," "std::allocator< std::vector< int,std::allocator< int > > >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__dup(std::vector< std::vector< int > > *self){
      return new std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__inspect(std::vector< std::vector< int > > *self){
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator i = self->begin();
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__to_a(std::vector< std::vector< int > > *self){
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator i = self->begin();
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__to_s(std::vector< std::vector< int > > *self){
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator i = self->begin();
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__slice(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::difference_type i,std::vector< std::vector< int > >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__each(std::vector< std::vector< int > > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator i = self->begin();
	std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__select(std::vector< std::vector< int > > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >* r = new std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >;
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator i = self->begin();
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__reject_bang(std::vector< std::vector< int > > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator i = self->begin();
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__delete_at(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg____delete2__(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__pop(std::vector< std::vector< int > > *self){
      if (self->empty()) return Qnil;
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( x );
    }
SWIGINTERN std::vector< std::vector< int > >::value_type const std_vector_Sl_std_vector_Sl_int_Sg__Sg__push(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__reject(std::vector< std::vector< int > > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >* r = new std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__at(std::vector< std::vector< int > > const *self,std::vector< std::vector< int > >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem____SWIG_0(std::vector< std::vector< int > > const *self,std::vector< std::vector< int > >::difference_type i,std::vector< std::vector< int > >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem____SWIG_1(std::vector< std::vector< int > > const *self,std::vector< std::vector< int > >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem____SWIG_2(std::vector< std::vector< int > > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem____SWIG_0(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::difference_type i,std::vector< std::vector< int > >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem____SWIG_1(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::difference_type i,std::vector< std::vector< int > >::difference_type j,std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_vector_Sl_int_Sg__Sg__shift(std::vector< std::vector< int > > *self){
      if (self->empty()) return Qnil;
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type >( x );
    }
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__insert__SWIG_0(std::vector< std::vector< int > > *self,std::vector< std::vector< int > >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type val = swig::as<std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *std_vector_Sl_std_vector_Sl_int_Sg__Sg__unshift(std::vector< std::vector< int > > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type val = swig::as<std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

/*@SWIG:/usr/local/share/swig/1.3.39/ruby/rubyprimtypes.swg,23,%ruby_aux_method@*/
SWIGINTERN VALUE SWIG_AUX_NUM2DBL(VALUE *args)
{
  VALUE obj = args[0];
  VALUE type = TYPE(obj);
  double *res = (double *)(args[1]);
  *res = (type == T_FLOAT ? NUM2DBL(obj) : (type == T_FIXNUM ? (double) FIX2INT(obj) : rb_big2dbl(obj)));
  return obj;
}
/*@SWIG@*/

SWIGINTERN int
SWIG_AsVal_double (VALUE obj, double *val)
{
  VALUE type = TYPE(obj);
  if ((type == T_FLOAT) || (type == T_FIXNUM) || (type == T_BIGNUM)) {
    double v;
    VALUE a[2];
    a[0] = obj;
    a[1] = (VALUE)(&v);
    if (rb_rescue(RUBY_METHOD_FUNC(SWIG_AUX_NUM2DBL), (VALUE)a, RUBY_METHOD_FUNC(SWIG_ruby_failed), 0) != Qnil) {
      if (val) *val = v;
      return SWIG_OK;
    }
  }
  return SWIG_TypeError;
}


  #define SWIG_From_double   rb_float_new 


namespace swig {
  template <> struct traits<double > {
    typedef value_category category;
    static const char* type_name() { return"double"; }
  };  
  template <>  struct traits_asval<double > {   
    typedef double value_type;
    static int asval(VALUE obj, value_type *val) { 
      return SWIG_AsVal_double (obj, val);
    }
  };
  template <>  struct traits_from<double > {
    typedef double value_type;
    static VALUE from(const value_type& val) {
      return SWIG_From_double  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::vector<double, std::allocator< double > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "double" "," "std::allocator< double >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__dup(std::vector< double > *self){
      return new std::vector<double,std::allocator< double > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__inspect(std::vector< double > *self){
      std::vector<double,std::allocator< double > >::const_iterator i = self->begin();
      std::vector<double,std::allocator< double > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<double,std::allocator< double > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<double,std::allocator< double > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__to_a(std::vector< double > *self){
      std::vector<double,std::allocator< double > >::const_iterator i = self->begin();
      std::vector<double,std::allocator< double > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<double,std::allocator< double > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__to_s(std::vector< double > *self){
      std::vector<double,std::allocator< double > >::iterator i = self->begin();
      std::vector<double,std::allocator< double > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<double,std::allocator< double > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__slice(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<double,std::allocator< double > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__each(std::vector< double > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<double,std::allocator< double > >::const_iterator i = self->begin();
	std::vector<double,std::allocator< double > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<double,std::allocator< double > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__select(std::vector< double > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<double,std::allocator< double > >* r = new std::vector<double,std::allocator< double > >;
      std::vector<double,std::allocator< double > >::const_iterator i = self->begin();
      std::vector<double,std::allocator< double > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<double,std::allocator< double > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__reject_bang(std::vector< double > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<double,std::allocator< double > >::iterator i = self->begin();
      std::vector<double,std::allocator< double > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<double,std::allocator< double > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__delete_at(std::vector< double > *self,std::vector< double >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<double,std::allocator< double > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<double,std::allocator< double > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg____delete2__(std::vector< double > *self,std::vector< double >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__pop(std::vector< double > *self){
      if (self->empty()) return Qnil;
      std::vector<double,std::allocator< double > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<double,std::allocator< double > >::value_type >( x );
    }
SWIGINTERN std::vector< double >::value_type const std_vector_Sl_double_Sg__push(std::vector< double > *self,std::vector< double >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__reject(std::vector< double > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<double,std::allocator< double > >* r = new std::vector<double,std::allocator< double > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<double,std::allocator< double > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__at(std::vector< double > const *self,std::vector< double >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<double,std::allocator< double > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg____getitem____SWIG_0(std::vector< double > const *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<double,std::allocator< double > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg____getitem____SWIG_1(std::vector< double > const *self,std::vector< double >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<double,std::allocator< double > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg____getitem____SWIG_2(std::vector< double > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<double,std::allocator< double > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg____setitem____SWIG_0(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<double,std::allocator< double > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_double_Sg____setitem____SWIG_1(std::vector< double > *self,std::vector< double >::difference_type i,std::vector< double >::difference_type j,std::vector< double,std::allocator< double > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<double,std::allocator< double > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_double_Sg__shift(std::vector< double > *self){
      if (self->empty()) return Qnil;
      std::vector<double,std::allocator< double > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<double,std::allocator< double > >::value_type >( x );
    }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__insert__SWIG_0(std::vector< double > *self,std::vector< double >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<double,std::allocator< double > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<double,std::allocator< double > >::value_type val = swig::as<std::vector<double,std::allocator< double > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<double,std::allocator< double > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<double,std::allocator< double > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__unshift(std::vector< double > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<double,std::allocator< double > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<double,std::allocator< double > >::value_type val = swig::as<std::vector<double,std::allocator< double > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<double,std::allocator< double > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }
SWIGINTERN std::vector< double,std::allocator< double > > *std_vector_Sl_double_Sg__map_bang(std::vector< double > *self){

    if ( !rb_block_given_p() )
      rb_raise( rb_eArgError, "No block given" );

    VALUE r = Qnil;
    std::vector< double >::iterator i = self->begin();
    std::vector< double >::iterator e = self->end();

    try {
      for ( ; i != e; ++i )
	{
	  r = swig::from< double >( *i );
	  r = rb_yield( r );
	  *i = swig::as< double >( r );
	}
    }
    catch ( const std::invalid_argument& )
      {
	rb_raise(rb_eTypeError,
		 "Yield block did not return a valid element for ""%arg(std::vector)");
      }
    
    return self;
  }
SWIGINTERN VALUE std_vector_Sl_double_Sg____delete__(std::vector< double > *self,double const &val){
    VALUE r = Qnil;
    std::vector<double >::iterator e = self->end();
    std::vector<double >::iterator i = std::remove( self->begin(), e, val );
    // remove dangling elements now
    self->erase( i, e );
    
    if ( i != e )
      r = swig::from< double >( val );
    else if ( rb_block_given_p() )
      r = rb_yield(Qnil);
    return r;
  }

SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(VALUE obj, char** cptr, size_t* psize, int *alloc)
{
  if (TYPE(obj) == T_STRING) {
    #if defined(StringValuePtr)
    char *cstr = StringValuePtr(obj); 
    #else
    char *cstr = STR2CSTR(obj);
    #endif
    size_t size = RSTRING_LEN(obj) + 1;
    if (cptr)  {
      if (alloc) {
	if (*alloc == SWIG_NEWOBJ) {
	  *cptr = reinterpret_cast< char* >(memcpy((new char[size]), cstr, sizeof(char)*(size)));
	} else {
	  *cptr = cstr;
	  *alloc = SWIG_OLDOBJ;
	}
      }
    }
    if (psize) *psize = size;
    return SWIG_OK;
  } else {
    swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
    if (pchar_descriptor) {
      void* vptr = 0;
      if (SWIG_ConvertPtr(obj, &vptr, pchar_descriptor, 0) == SWIG_OK) {
	if (cptr) *cptr = (char *)vptr;
	if (psize) *psize = vptr ? (strlen((char*)vptr) + 1) : 0;
	if (alloc) *alloc = SWIG_OLDOBJ;
	return SWIG_OK;
      }
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsPtr_std_string (VALUE obj, std::string **val) 
{
  char* buf = 0 ; size_t size = 0; int alloc = SWIG_OLDOBJ;
  if (SWIG_IsOK((SWIG_AsCharPtrAndSize(obj, &buf, &size, &alloc)))) {
    if (buf) {
      if (val) *val = new std::string(buf, size - 1);
      if (alloc == SWIG_NEWOBJ) delete[] buf;
      return SWIG_NEWOBJ;
    } else {
      if (val) *val = 0;
      return SWIG_OLDOBJ;
    }
  } else {
    static int init = 0;
    static swig_type_info* descriptor = 0;
    if (!init) {
      descriptor = SWIG_TypeQuery("std::string" " *");
      init = 1;
    }
    if (descriptor) {
      std::string *vptr;
      int res = SWIG_ConvertPtr(obj, (void**)&vptr, descriptor, 0);
      if (SWIG_IsOK(res) && val) *val = vptr;
      return res;
    }
  }
  return SWIG_ERROR;
}


SWIGINTERN int
SWIG_AsVal_std_string (VALUE obj, std::string *val)
{
  std::string* v = (std::string *) 0;
  int res = SWIG_AsPtr_std_string (obj, &v);
  if (!SWIG_IsOK(res)) return res;
  if (v) {
    if (val) *val = *v;
    if (SWIG_IsNewObj(res)) {
      delete v;
      res = SWIG_DelNewMask(res);
    }
    return res;
  }
  return SWIG_ERROR;
}


SWIGINTERNINLINE VALUE 
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > LONG_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_NewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : Qnil;
    } else {
      return rb_str_new(carray, static_cast< long >(size));
    }
  } else {
    return Qnil;
  }
}


SWIGINTERNINLINE VALUE
SWIG_From_std_string  (const std::string& s)
{
  if (s.size()) {
    return SWIG_FromCharPtrAndSize(s.data(), s.size());
  } else {
    return SWIG_FromCharPtrAndSize(s.c_str(), 0);
  }
}


namespace swig {
  template <> struct traits<std::string > {
    typedef value_category category;
    static const char* type_name() { return"std::string"; }
  };  
  template <>  struct traits_asval<std::string > {   
    typedef std::string value_type;
    static int asval(VALUE obj, value_type *val) { 
      return SWIG_AsVal_std_string (obj, val);
    }
  };
  template <>  struct traits_from<std::string > {
    typedef std::string value_type;
    static VALUE from(const value_type& val) {
      return SWIG_From_std_string  (val);
    }
  };
}


      namespace swig {
	template <>  struct traits<std::vector<std::string, std::allocator< std::string > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "std::string" "," "std::allocator< std::string >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__dup(std::vector< std::string > *self){
      return new std::vector<std::string,std::allocator< std::string > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__inspect(std::vector< std::string > *self){
      std::vector<std::string,std::allocator< std::string > >::const_iterator i = self->begin();
      std::vector<std::string,std::allocator< std::string > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<std::string,std::allocator< std::string > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__to_a(std::vector< std::string > *self){
      std::vector<std::string,std::allocator< std::string > >::const_iterator i = self->begin();
      std::vector<std::string,std::allocator< std::string > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__to_s(std::vector< std::string > *self){
      std::vector<std::string,std::allocator< std::string > >::iterator i = self->begin();
      std::vector<std::string,std::allocator< std::string > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__slice(std::vector< std::string > *self,std::vector< std::string >::difference_type i,std::vector< std::string >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<std::string,std::allocator< std::string > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__each(std::vector< std::string > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<std::string,std::allocator< std::string > >::const_iterator i = self->begin();
	std::vector<std::string,std::allocator< std::string > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__select(std::vector< std::string > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<std::string,std::allocator< std::string > >* r = new std::vector<std::string,std::allocator< std::string > >;
      std::vector<std::string,std::allocator< std::string > >::const_iterator i = self->begin();
      std::vector<std::string,std::allocator< std::string > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__reject_bang(std::vector< std::string > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<std::string,std::allocator< std::string > >::iterator i = self->begin();
      std::vector<std::string,std::allocator< std::string > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__delete_at(std::vector< std::string > *self,std::vector< std::string >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<std::string,std::allocator< std::string > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____delete2__(std::vector< std::string > *self,std::vector< std::string >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__pop(std::vector< std::string > *self){
      if (self->empty()) return Qnil;
      std::vector<std::string,std::allocator< std::string > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( x );
    }
SWIGINTERN std::vector< std::string >::value_type const std_vector_Sl_std_string_Sg__push(std::vector< std::string > *self,std::vector< std::string >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__reject(std::vector< std::string > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<std::string,std::allocator< std::string > >* r = new std::vector<std::string,std::allocator< std::string > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<std::string,std::allocator< std::string > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__at(std::vector< std::string > const *self,std::vector< std::string >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____getitem____SWIG_0(std::vector< std::string > const *self,std::vector< std::string >::difference_type i,std::vector< std::string >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<std::string,std::allocator< std::string > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____getitem____SWIG_1(std::vector< std::string > const *self,std::vector< std::string >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____getitem____SWIG_2(std::vector< std::string > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<std::string,std::allocator< std::string > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____setitem____SWIG_0(std::vector< std::string > *self,std::vector< std::string >::difference_type i,std::vector< std::string >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____setitem____SWIG_1(std::vector< std::string > *self,std::vector< std::string >::difference_type i,std::vector< std::string >::difference_type j,std::vector< std::string,std::allocator< std::string > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<std::string,std::allocator< std::string > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg__shift(std::vector< std::string > *self){
      if (self->empty()) return Qnil;
      std::vector<std::string,std::allocator< std::string > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<std::string,std::allocator< std::string > >::value_type >( x );
    }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__insert__SWIG_0(std::vector< std::string > *self,std::vector< std::string >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<std::string,std::allocator< std::string > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<std::string,std::allocator< std::string > >::value_type val = swig::as<std::vector<std::string,std::allocator< std::string > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<std::string,std::allocator< std::string > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<std::string,std::allocator< std::string > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__unshift(std::vector< std::string > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<std::string,std::allocator< std::string > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<std::string,std::allocator< std::string > >::value_type val = swig::as<std::vector<std::string,std::allocator< std::string > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<std::string,std::allocator< std::string > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }
SWIGINTERN std::vector< std::string,std::allocator< std::string > > *std_vector_Sl_std_string_Sg__map_bang(std::vector< std::string > *self){

    if ( !rb_block_given_p() )
      rb_raise( rb_eArgError, "No block given" );

    VALUE r = Qnil;
    std::vector< std::string >::iterator i = self->begin();
    std::vector< std::string >::iterator e = self->end();

    try {
      for ( ; i != e; ++i )
	{
	  r = swig::from< std::string >( *i );
	  r = rb_yield( r );
	  *i = swig::as< std::string >( r );
	}
    }
    catch ( const std::invalid_argument& )
      {
	rb_raise(rb_eTypeError,
		 "Yield block did not return a valid element for ""%arg(std::vector)");
      }
    
    return self;
  }
SWIGINTERN VALUE std_vector_Sl_std_string_Sg____delete__(std::vector< std::string > *self,std::string const &val){
    VALUE r = Qnil;
    std::vector<std::string >::iterator e = self->end();
    std::vector<std::string >::iterator i = std::remove( self->begin(), e, val );
    // remove dangling elements now
    self->erase( i, e );
    
    if ( i != e )
      r = swig::from< std::string >( val );
    else if ( rb_block_given_p() )
      r = rb_yield(Qnil);
    return r;
  }

  namespace swig {
    template <>  struct traits<OpenBabel::vector3 > {
      typedef pointer_category category;
      static const char* type_name() { return"OpenBabel::vector3"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::vector3, std::allocator< OpenBabel::vector3 > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::vector3" "," "std::allocator< OpenBabel::vector3 >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__dup(std::vector< OpenBabel::vector3 > *self){
      return new std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__inspect(std::vector< OpenBabel::vector3 > *self){
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator i = self->begin();
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__to_a(std::vector< OpenBabel::vector3 > *self){
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator i = self->begin();
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__to_s(std::vector< OpenBabel::vector3 > *self){
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator i = self->begin();
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__slice(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::difference_type i,std::vector< OpenBabel::vector3 >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__each(std::vector< OpenBabel::vector3 > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator i = self->begin();
	std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__select(std::vector< OpenBabel::vector3 > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >* r = new std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >;
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator i = self->begin();
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__reject_bang(std::vector< OpenBabel::vector3 > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator i = self->begin();
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__delete_at(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg____delete2__(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__pop(std::vector< OpenBabel::vector3 > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::vector3 >::value_type const std_vector_Sl_OpenBabel_vector3_Sg__push(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__reject(std::vector< OpenBabel::vector3 > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >* r = new std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__at(std::vector< OpenBabel::vector3 > const *self,std::vector< OpenBabel::vector3 >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg____getitem____SWIG_0(std::vector< OpenBabel::vector3 > const *self,std::vector< OpenBabel::vector3 >::difference_type i,std::vector< OpenBabel::vector3 >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg____getitem____SWIG_1(std::vector< OpenBabel::vector3 > const *self,std::vector< OpenBabel::vector3 >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg____getitem____SWIG_2(std::vector< OpenBabel::vector3 > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg____setitem____SWIG_0(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::difference_type i,std::vector< OpenBabel::vector3 >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg____setitem____SWIG_1(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::difference_type i,std::vector< OpenBabel::vector3 >::difference_type j,std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_vector3_Sg__shift(std::vector< OpenBabel::vector3 > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__insert__SWIG_0(std::vector< OpenBabel::vector3 > *self,std::vector< OpenBabel::vector3 >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type val = swig::as<std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *std_vector_Sl_OpenBabel_vector3_Sg__unshift(std::vector< OpenBabel::vector3 > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type val = swig::as<std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

  namespace swig {
    template <>  struct traits<OpenBabel::OBMol > {
      typedef pointer_category category;
      static const char* type_name() { return"OpenBabel::OBMol"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::OBMol, std::allocator< OpenBabel::OBMol > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::OBMol" "," "std::allocator< OpenBabel::OBMol >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__dup(std::vector< OpenBabel::OBMol > *self){
      return new std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__inspect(std::vector< OpenBabel::OBMol > *self){
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__to_a(std::vector< OpenBabel::OBMol > *self){
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__to_s(std::vector< OpenBabel::OBMol > *self){
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator i = self->begin();
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__slice(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::difference_type i,std::vector< OpenBabel::OBMol >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__each(std::vector< OpenBabel::OBMol > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator i = self->begin();
	std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__select(std::vector< OpenBabel::OBMol > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >* r = new std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >;
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__reject_bang(std::vector< OpenBabel::OBMol > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator i = self->begin();
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__delete_at(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg____delete2__(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__pop(std::vector< OpenBabel::OBMol > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBMol >::value_type const std_vector_Sl_OpenBabel_OBMol_Sg__push(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__reject(std::vector< OpenBabel::OBMol > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >* r = new std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__at(std::vector< OpenBabel::OBMol > const *self,std::vector< OpenBabel::OBMol >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg____getitem____SWIG_0(std::vector< OpenBabel::OBMol > const *self,std::vector< OpenBabel::OBMol >::difference_type i,std::vector< OpenBabel::OBMol >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg____getitem____SWIG_1(std::vector< OpenBabel::OBMol > const *self,std::vector< OpenBabel::OBMol >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg____getitem____SWIG_2(std::vector< OpenBabel::OBMol > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg____setitem____SWIG_0(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::difference_type i,std::vector< OpenBabel::OBMol >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg____setitem____SWIG_1(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::difference_type i,std::vector< OpenBabel::OBMol >::difference_type j,std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBMol_Sg__shift(std::vector< OpenBabel::OBMol > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__insert__SWIG_0(std::vector< OpenBabel::OBMol > *self,std::vector< OpenBabel::OBMol >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type val = swig::as<std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *std_vector_Sl_OpenBabel_OBMol_Sg__unshift(std::vector< OpenBabel::OBMol > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type val = swig::as<std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

  namespace swig {
    template <>  struct traits<OpenBabel::OBBond > {
      typedef pointer_category category;
      static const char* type_name() { return"OpenBabel::OBBond"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::OBBond, std::allocator< OpenBabel::OBBond > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::OBBond" "," "std::allocator< OpenBabel::OBBond >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__dup(std::vector< OpenBabel::OBBond > *self){
      return new std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__inspect(std::vector< OpenBabel::OBBond > *self){
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__to_a(std::vector< OpenBabel::OBBond > *self){
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__to_s(std::vector< OpenBabel::OBBond > *self){
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator i = self->begin();
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__slice(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::difference_type i,std::vector< OpenBabel::OBBond >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__each(std::vector< OpenBabel::OBBond > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator i = self->begin();
	std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__select(std::vector< OpenBabel::OBBond > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >* r = new std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >;
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__reject_bang(std::vector< OpenBabel::OBBond > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator i = self->begin();
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__delete_at(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg____delete2__(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__pop(std::vector< OpenBabel::OBBond > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBBond >::value_type const std_vector_Sl_OpenBabel_OBBond_Sg__push(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__reject(std::vector< OpenBabel::OBBond > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >* r = new std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__at(std::vector< OpenBabel::OBBond > const *self,std::vector< OpenBabel::OBBond >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg____getitem____SWIG_0(std::vector< OpenBabel::OBBond > const *self,std::vector< OpenBabel::OBBond >::difference_type i,std::vector< OpenBabel::OBBond >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg____getitem____SWIG_1(std::vector< OpenBabel::OBBond > const *self,std::vector< OpenBabel::OBBond >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg____getitem____SWIG_2(std::vector< OpenBabel::OBBond > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg____setitem____SWIG_0(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::difference_type i,std::vector< OpenBabel::OBBond >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg____setitem____SWIG_1(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::difference_type i,std::vector< OpenBabel::OBBond >::difference_type j,std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBBond_Sg__shift(std::vector< OpenBabel::OBBond > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__insert__SWIG_0(std::vector< OpenBabel::OBBond > *self,std::vector< OpenBabel::OBBond >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type val = swig::as<std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *std_vector_Sl_OpenBabel_OBBond_Sg__unshift(std::vector< OpenBabel::OBBond > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type val = swig::as<std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

  namespace swig {
    template <>  struct traits<OpenBabel::OBResidue > {
      typedef pointer_category category;
      static const char* type_name() { return"OpenBabel::OBResidue"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::OBResidue, std::allocator< OpenBabel::OBResidue > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::OBResidue" "," "std::allocator< OpenBabel::OBResidue >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__dup(std::vector< OpenBabel::OBResidue > *self){
      return new std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__inspect(std::vector< OpenBabel::OBResidue > *self){
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__to_a(std::vector< OpenBabel::OBResidue > *self){
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__to_s(std::vector< OpenBabel::OBResidue > *self){
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator i = self->begin();
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__slice(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::difference_type i,std::vector< OpenBabel::OBResidue >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__each(std::vector< OpenBabel::OBResidue > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator i = self->begin();
	std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__select(std::vector< OpenBabel::OBResidue > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >* r = new std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >;
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__reject_bang(std::vector< OpenBabel::OBResidue > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator i = self->begin();
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__delete_at(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg____delete2__(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__pop(std::vector< OpenBabel::OBResidue > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBResidue >::value_type const std_vector_Sl_OpenBabel_OBResidue_Sg__push(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__reject(std::vector< OpenBabel::OBResidue > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >* r = new std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__at(std::vector< OpenBabel::OBResidue > const *self,std::vector< OpenBabel::OBResidue >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg____getitem____SWIG_0(std::vector< OpenBabel::OBResidue > const *self,std::vector< OpenBabel::OBResidue >::difference_type i,std::vector< OpenBabel::OBResidue >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg____getitem____SWIG_1(std::vector< OpenBabel::OBResidue > const *self,std::vector< OpenBabel::OBResidue >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg____getitem____SWIG_2(std::vector< OpenBabel::OBResidue > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg____setitem____SWIG_0(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::difference_type i,std::vector< OpenBabel::OBResidue >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg____setitem____SWIG_1(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::difference_type i,std::vector< OpenBabel::OBResidue >::difference_type j,std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBResidue_Sg__shift(std::vector< OpenBabel::OBResidue > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__insert__SWIG_0(std::vector< OpenBabel::OBResidue > *self,std::vector< OpenBabel::OBResidue >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type val = swig::as<std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *std_vector_Sl_OpenBabel_OBResidue_Sg__unshift(std::vector< OpenBabel::OBResidue > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type val = swig::as<std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

  namespace swig {
    template <>  struct traits<OpenBabel::OBRing > {
      typedef pointer_category category;
      static const char* type_name() { return"OpenBabel::OBRing"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::OBRing, std::allocator< OpenBabel::OBRing > > > {
	  typedef pointer_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::OBRing" "," "std::allocator< OpenBabel::OBRing >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__dup(std::vector< OpenBabel::OBRing > *self){
      return new std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__inspect(std::vector< OpenBabel::OBRing > *self){
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__to_a(std::vector< OpenBabel::OBRing > *self){
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__to_s(std::vector< OpenBabel::OBRing > *self){
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator i = self->begin();
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__slice(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::difference_type i,std::vector< OpenBabel::OBRing >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__each(std::vector< OpenBabel::OBRing > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator i = self->begin();
	std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__select(std::vector< OpenBabel::OBRing > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >* r = new std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >;
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__reject_bang(std::vector< OpenBabel::OBRing > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator i = self->begin();
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__delete_at(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg____delete2__(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__pop(std::vector< OpenBabel::OBRing > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type x = self->back();
      self->pop_back();
      return swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBRing >::value_type const std_vector_Sl_OpenBabel_OBRing_Sg__push(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::value_type const &e){
      self->push_back( e );
      return e;
    }
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__reject(std::vector< OpenBabel::OBRing > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >* r = new std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >;
      std::remove_copy_if( self->begin(), self->end(),              
			   std::back_inserter(*r),
			   swig::yield< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >() );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__at(std::vector< OpenBabel::OBRing > const *self,std::vector< OpenBabel::OBRing >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg____getitem____SWIG_0(std::vector< OpenBabel::OBRing > const *self,std::vector< OpenBabel::OBRing >::difference_type i,std::vector< OpenBabel::OBRing >::difference_type j){
      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; if ( static_cast<std::size_t>(j) >= len ) j = len-1;

      VALUE r = Qnil;
      try {
	r = swig::from< const std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >* >( swig::getslice(self, i, j) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg____getitem____SWIG_1(std::vector< OpenBabel::OBRing > const *self,std::vector< OpenBabel::OBRing >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg____getitem____SWIG_2(std::vector< OpenBabel::OBRing > const *self,VALUE i){
      if ( rb_obj_is_kind_of( i, rb_cRange ) == Qfalse )
	{
	  rb_raise( rb_eTypeError, "not a valid index or range" );
	}

      VALUE r = Qnil;
      static ID id_end   = rb_intern("end");
      static ID id_start = rb_intern("begin");
      static ID id_noend = rb_intern("exclude_end?");

      VALUE start = rb_funcall( i, id_start, 0 );
      VALUE end   = rb_funcall( i, id_end, 0 );
      bool  noend = ( rb_funcall( i, id_noend, 0 ) == Qtrue );

      int len = self->size();

      int s = NUM2INT( start );
      if ( s < 0 ) s = len + s;
      else if ( s >= len ) return Qnil;

      int e = NUM2INT( end );
      if ( e < 0 ) e = len + e;

      if ( e < s ) return Qnil; //std::swap( s, e );

      if ( noend ) e -= 1;
      if ( e >= len ) e = len - 1;

      return swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >* >( swig::getslice(self, s, e+1) );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg____setitem____SWIG_0(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::difference_type i,std::vector< OpenBabel::OBRing >::value_type const &x){
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	else if ( static_cast<std::size_t>(i) >= len )
	  self->resize( i+1, x );
	else
	  *(swig::getpos(self,i)) = x;

	return swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( x );
      }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg____setitem____SWIG_1(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::difference_type i,std::vector< OpenBabel::OBRing >::difference_type j,std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > const &v){

      if ( j <= 0 ) return Qnil;
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      j += i; 
      if ( static_cast<std::size_t>(j) >= len ) {
	self->resize( j+1, *(v.begin()) );
	j = len-1;
      }

      VALUE r = Qnil;
      swig::setslice(self, i, j, v);
      r = swig::from< const std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >* >( &v );
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sg__shift(std::vector< OpenBabel::OBRing > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__insert__SWIG_0(std::vector< OpenBabel::OBRing > *self,std::vector< OpenBabel::OBRing >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type val = swig::as<std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *std_vector_Sl_OpenBabel_OBRing_Sg__unshift(std::vector< OpenBabel::OBRing > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type val = swig::as<std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::OBRing*, std::allocator< OpenBabel::OBRing * > > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::OBRing" " *," "std::allocator< OpenBabel::OBRing * >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *std_vector_Sl_OpenBabel_OBRing_Sm__Sg__dup(std::vector< OpenBabel::OBRing * > *self){
      return new std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg__inspect(std::vector< OpenBabel::OBRing * > *self){
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg__to_a(std::vector< OpenBabel::OBRing * > *self){
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg__to_s(std::vector< OpenBabel::OBRing * > *self){
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator i = self->begin();
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg__slice(std::vector< OpenBabel::OBRing * > *self,std::vector< OpenBabel::OBRing * >::difference_type i,std::vector< OpenBabel::OBRing * >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *std_vector_Sl_OpenBabel_OBRing_Sm__Sg__each(std::vector< OpenBabel::OBRing * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator i = self->begin();
	std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *std_vector_Sl_OpenBabel_OBRing_Sm__Sg__select(std::vector< OpenBabel::OBRing * > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >* r = new std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >;
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *std_vector_Sl_OpenBabel_OBRing_Sm__Sg__reject_bang(std::vector< OpenBabel::OBRing * > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator i = self->begin();
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg__delete_at(std::vector< OpenBabel::OBRing * > *self,std::vector< OpenBabel::OBRing * >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg____delete2__(std::vector< OpenBabel::OBRing * > *self,std::vector< OpenBabel::OBRing * >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg____getitem__(std::vector< OpenBabel::OBRing * > *self,std::vector< OpenBabel::OBRing * >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg____setitem__(std::vector< OpenBabel::OBRing * > *self,std::vector< OpenBabel::OBRing * >::difference_type i,std::vector< OpenBabel::OBRing * >::value_type x){
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      else if ( static_cast<std::size_t>(i) >= len )
	self->resize( i+1, x );
      else *(swig::getpos(self,i)) = x;
      return swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( x );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBRing_Sm__Sg__shift(std::vector< OpenBabel::OBRing * > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *std_vector_Sl_OpenBabel_OBRing_Sm__Sg__insert__SWIG_0(std::vector< OpenBabel::OBRing * > *self,std::vector< OpenBabel::OBRing * >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type val = swig::as<std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *std_vector_Sl_OpenBabel_OBRing_Sm__Sg__unshift(std::vector< OpenBabel::OBRing * > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type val = swig::as<std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

  namespace swig {
    template <>  struct traits<OpenBabel::OBGenericData > {
      typedef pointer_category category;
      static const char* type_name() { return"OpenBabel::OBGenericData"; }
    };
  }


      namespace swig {
	template <>  struct traits<std::vector<OpenBabel::OBGenericData*, std::allocator< OpenBabel::OBGenericData * > > > {
	  typedef value_category category;
	  static const char* type_name() {
	    return "std::vector<" "OpenBabel::OBGenericData" " *," "std::allocator< OpenBabel::OBGenericData * >" " >";
	  }
	};
      }
    
SWIGINTERN std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__dup(std::vector< OpenBabel::OBGenericData * > *self){
      return new std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >(*self);
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__inspect(std::vector< OpenBabel::OBGenericData * > *self){
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator e = self->end();
      VALUE str = rb_str_new2( swig::type_name< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >() );
      str = rb_str_cat2( str, " [" );
      bool comma = false;
      VALUE tmp;
      for ( ; i != e; ++i, comma = true )
	{
	  if (comma) str = rb_str_cat2( str, "," );
	  tmp = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( *i );
	  tmp = rb_inspect( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      str = rb_str_cat2( str, "]" );
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__to_a(std::vector< OpenBabel::OBGenericData * > *self){
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator e = self->end();
      VALUE ary = rb_ary_new2( std::distance( i, e ) );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( *i );
	  rb_ary_push( ary, tmp );
	}
      return ary;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__to_s(std::vector< OpenBabel::OBGenericData * > *self){
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator i = self->begin();
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator e = self->end();
      VALUE str = rb_str_new2( "" );
      VALUE tmp;
      for ( ; i != e; ++i )
	{
	  tmp = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( *i );
	  tmp = rb_obj_as_string( tmp );
	  str = rb_str_buf_append( str, tmp );
	}
      return str;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__slice(std::vector< OpenBabel::OBGenericData * > *self,std::vector< OpenBabel::OBGenericData * >::difference_type i,std::vector< OpenBabel::OBGenericData * >::difference_type j){
	if ( j <= 0 ) return Qnil;
	std::size_t len = self->size();
	if ( i < 0 ) i = len - i;
	j += i;
	if ( static_cast<std::size_t>(j) >= len ) j = len-1;

	VALUE r = Qnil;
	try {
	  r = swig::from< const std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >* >( swig::getslice(self, i, j) );
	}
	catch( std::out_of_range )
	  {
	  }
	return r;
      }
SWIGINTERN std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__each(std::vector< OpenBabel::OBGenericData * > *self){
	if ( !rb_block_given_p() )
	  rb_raise( rb_eArgError, "no block given");

	VALUE r;
	std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator i = self->begin();
	std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator e = self->end();
	for ( ; i != e; ++i )
	  {
	    r = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >(*i);
	    rb_yield(r);
	  }
	
	return self;
      }
SWIGINTERN std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__select(std::vector< OpenBabel::OBGenericData * > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >* r = new std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >;
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator i = self->begin();
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::const_iterator e = self->end();
      for ( ; i != e; ++i )
	{
	  VALUE v = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >(*i);
	  if ( RTEST( rb_yield(v) ) )
	    self->insert( r->end(), *i);
	}
	
      return r;
    }
SWIGINTERN std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__reject_bang(std::vector< OpenBabel::OBGenericData * > *self){
      if ( !rb_block_given_p() )
	rb_raise( rb_eArgError, "no block given" );

      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator i = self->begin();
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator e = self->end();
      for ( ; i != e; )
	{
	  VALUE r = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >(*i);
	  if ( RTEST( rb_yield(r) ) ) {
	    self->erase(i++);
            e = self->end();
	  } else {
	    ++i;
          }
	}
	
      return self;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__delete_at(std::vector< OpenBabel::OBGenericData * > *self,std::vector< OpenBabel::OBGenericData * >::difference_type i){
      VALUE r = Qnil;
      try {
	std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator at = swig::getpos(self, i);
	r = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( *(at) );
	self->erase(at); 
      }
      catch (std::out_of_range)
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____delete2__(std::vector< OpenBabel::OBGenericData * > *self,std::vector< OpenBabel::OBGenericData * >::value_type const &i){
      VALUE r = Qnil;
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____getitem__(std::vector< OpenBabel::OBGenericData * > *self,std::vector< OpenBabel::OBGenericData * >::difference_type i){
      VALUE r = Qnil;
      try {
	r = swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( *(swig::cgetpos(self, i)) );
      }
      catch( std::out_of_range )
	{
	}
      return r;
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____setitem__(std::vector< OpenBabel::OBGenericData * > *self,std::vector< OpenBabel::OBGenericData * >::difference_type i,std::vector< OpenBabel::OBGenericData * >::value_type x){
      std::size_t len = self->size();
      if ( i < 0 ) i = len - i;
      else if ( static_cast<std::size_t>(i) >= len )
	self->resize( i+1, x );
      else *(swig::getpos(self,i)) = x;
      return swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( x );
    }
SWIGINTERN VALUE std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__shift(std::vector< OpenBabel::OBGenericData * > *self){
      if (self->empty()) return Qnil;
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type x = self->front();
      self->erase( self->begin() );
      return swig::from< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type >( x );
    }
SWIGINTERN std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__insert__SWIG_0(std::vector< OpenBabel::OBGenericData * > *self,std::vector< OpenBabel::OBGenericData * >::difference_type pos,int argc,VALUE *argv,...){
      std::size_t len = self->size();
      std::size_t   i = swig::check_index( pos, len, true );
      std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator start;

      VALUE elem = argv[0];
      int idx = 0;
      try {
	std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type val = swig::as<std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type>( elem, true );
	if ( i >= len ) {
	  self->resize(i-1, val);
	  return self;
	}
	start = self->begin();
	std::advance( start, i );
	self->insert( start++, val );

	for ( ++idx; idx < argc; ++idx )
	  {
	    elem = argv[idx];
	    val = swig::as<std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type>( elem );
	    self->insert( start++, val );
	  }

      } 
      catch( std::invalid_argument )
	{
	  rb_raise( rb_eArgError,
		    Ruby_Format_TypeError( "", 
					   swig::type_name<std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type>(),
					   __FUNCTION__, idx+2, elem ));
	}


      return self;
    }
SWIGINTERN std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__unshift(std::vector< OpenBabel::OBGenericData * > *self,int argc,VALUE *argv,...){
      for ( int idx = argc-1; idx >= 0; --idx )
	{
	  std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::iterator start = self->begin();
	  VALUE elem = argv[idx];
	  try {
	    std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type val = swig::as<std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type>( elem, true );
	    self->insert( start, val );
	  }
	  catch( std::invalid_argument )
	    {
	      rb_raise( rb_eArgError,
			Ruby_Format_TypeError( "", 
					       swig::type_name<std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > >::value_type>(),
					       __FUNCTION__, idx+2, elem ));
	    }
	}

      return self;
    }

OpenBabel::OBPairData *toPairData(OpenBabel::OBGenericData *data) {
	return (OpenBabel::OBPairData *) data;
}

OpenBabel::OBUnitCell *toUnitCell(OpenBabel::OBGenericData *data) {
	return (OpenBabel::OBUnitCell *) data;
}





SWIGINTERNINLINE VALUE 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERN int
SWIG_AsVal_bool (VALUE obj, bool *val)
{
  if (obj == Qtrue) {
    if (val) *val = true;
    return SWIG_OK;
  } else if (obj == Qfalse) {
    if (val) *val = false;
    return SWIG_OK;
  } else {
    int res = 0;
    if (SWIG_AsVal_int (obj, &res) == SWIG_OK) {    
      if (val) *val = res ? true : false;
      return SWIG_OK;
    }
  }  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsCharArray(VALUE obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    if ((csize == size + 1) && cptr && !(cptr[csize-1])) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char (VALUE obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long (obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}


SWIGINTERN int
SWIG_AsVal_short (VALUE obj, short *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < SHRT_MIN || v > SHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< short >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE VALUE
SWIG_From_unsigned_SS_short  (unsigned short value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_short (VALUE obj, unsigned short *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > USHRT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned short >(v);
    }
  }  
  return res;
}

swig_class SwigClassGCVALUE;


/*
  Document-method: OpenBabel::GCVALUE.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_GCVALUE_inspect(int argc, VALUE *argv, VALUE self) { swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::GC_VALUE const *","inspect", 1, self ));  } 
  arg1 = reinterpret_cast< swig::GC_VALUE * >(argp1); result = (VALUE)((swig::GC_VALUE const *)arg1)->inspect();
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::GCVALUE.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_GCVALUE_to_s(int argc, VALUE *argv, VALUE self) { swig::GC_VALUE *arg1 = (swig::GC_VALUE *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__GC_VALUE, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::GC_VALUE const *","to_s", 1, self ));  } 
  arg1 = reinterpret_cast< swig::GC_VALUE * >(argp1); result = (VALUE)((swig::GC_VALUE const *)arg1)->to_s(); vresult = result;
  return vresult; fail: return Qnil; }
swig_class SwigClassConstIterator;

SWIGINTERN void
free_swig_ConstIterator(swig::ConstIterator *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_ConstIterator_value(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","value", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); try { result = (VALUE)((swig::ConstIterator const *)arg1)->value();} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  }  vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::ConstIterator.dup

  call-seq:
    dup -> ConstIterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_ConstIterator_dup(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","dup", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->dup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 ); return vresult;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::ConstIterator.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_ConstIterator_inspect(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","inspect", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); result = (VALUE)((swig::ConstIterator const *)arg1)->inspect();
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::ConstIterator.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_ConstIterator_to_s(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","to_s", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); result = (VALUE)((swig::ConstIterator const *)arg1)->to_s();
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; size_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ;
  int ecode2 = 0 ; swig::ConstIterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] )); }  
  arg2 = static_cast< size_t >(val2); result = (swig::ConstIterator *)(arg1)->next(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","next", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); try { result = (swig::ConstIterator *)(arg1)->next();} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator_next(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_ConstIterator_next__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_ConstIterator_next__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.next",  "    swig::ConstIterator * ConstIterator.next(size_t n)\n"
  "    swig::ConstIterator * ConstIterator.next()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; size_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ;
  int ecode2 = 0 ; swig::ConstIterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] )); }  
  arg2 = static_cast< size_t >(val2); result = (swig::ConstIterator *)(arg1)->previous(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::ConstIterator *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator *","previous", 1, self ));  } 
  arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); try { result = (swig::ConstIterator *)(arg1)->previous();} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator_previous(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_ConstIterator_previous__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_ConstIterator_previous__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "ConstIterator.previous", 
  "    swig::ConstIterator * ConstIterator.previous(size_t n)\n" "    swig::ConstIterator * ConstIterator.previous()\n");
  return Qnil; }

/*
  Document-method: OpenBabel::ConstIterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE _wrap_ConstIterator___eq__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; swig::ConstIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator ==", 1, self ));  }
   arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator ==", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator ==", 2, argv[0])); }
   arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  result = (bool)((swig::ConstIterator const *)arg1)->operator ==((swig::ConstIterator const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::ConstIterator.+

  call-seq:
    +(n) -> ConstIterator

Add operator.
*/
SWIGINTERN VALUE _wrap_ConstIterator___add__(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; ptrdiff_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ;
  int ecode2 = 0 ; swig::ConstIterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator +", 1, self ));  }
   arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] )); }  
  arg2 = static_cast< ptrdiff_t >(val2); try {
    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator +(arg2);}  catch(swig::stop_iteration &_e) { {
      (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 ); return vresult;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::ConstIterator.-

  call-seq:
    -(n) -> ConstIterator
    -(x) -> ptrdiff_t

Substraction operator.
*/
SWIGINTERN VALUE _wrap_ConstIterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; ptrdiff_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ;
  int ecode2 = 0 ; swig::ConstIterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self ));  }
   arg1 = reinterpret_cast< swig::ConstIterator * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] )); }  
  arg2 = static_cast< ptrdiff_t >(val2); try {
    result = (swig::ConstIterator *)((swig::ConstIterator const *)arg1)->operator -(arg2);}  catch(swig::stop_iteration &_e) { {
      (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__ConstIterator, SWIG_POINTER_OWN |  0 ); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::ConstIterator *arg1 = (swig::ConstIterator *) 0 ; swig::ConstIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; ptrdiff_t result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__ConstIterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::ConstIterator const *","operator -", 1, self ));  }
   arg1 = reinterpret_cast< swig::ConstIterator * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__ConstIterator,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::ConstIterator const &","operator -", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::ConstIterator const &","operator -", 2, argv[0])); }
   arg2 = reinterpret_cast< swig::ConstIterator * >(argp2);
  result = ((swig::ConstIterator const *)arg1)->operator -((swig::ConstIterator const &)*arg2);
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ConstIterator___sub__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__ConstIterator, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_ConstIterator___sub____SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_ConstIterator___sub____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "__sub__.new",  "    __sub__.new(ptrdiff_t n)\n"
  "    __sub__.new(swig::ConstIterator const &x)\n"); return Qnil; }
swig_class SwigClassIterator;

SWIGINTERN VALUE _wrap_Iterator_valuee___(int argc, VALUE *argv, VALUE self) { swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  VALUE *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE temp2 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","setValue", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); temp2 = static_cast< VALUE >(argv[0]); arg2 = &temp2;
  result = (VALUE)(arg1)->setValue((VALUE const &)*arg2); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::Iterator.dup

  call-seq:
    dup -> Iterator

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_Iterator_dup(int argc, VALUE *argv, VALUE self) { swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","dup", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); result = (swig::Iterator *)((swig::Iterator const *)arg1)->dup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 ); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator_next__SWIG_0(int argc, VALUE *argv, VALUE self) { swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  size_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; swig::Iterator *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","next", 2, argv[0] )); }  
  arg2 = static_cast< size_t >(val2); result = (swig::Iterator *)(arg1)->next(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator_next__SWIG_1(int argc, VALUE *argv, VALUE self) { swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","next", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); try { result = (swig::Iterator *)(arg1)->next();} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator_next(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_Iterator_next__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_Iterator_next__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "Iterator.next", 
  "    swig::Iterator * Iterator.next(size_t n)\n" "    swig::Iterator * Iterator.next()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_Iterator_previous__SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ; size_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  swig::Iterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "size_t","previous", 2, argv[0] )); }  
  arg2 = static_cast< size_t >(val2); result = (swig::Iterator *)(arg1)->previous(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator_previous__SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator *","previous", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); try { result = (swig::Iterator *)(arg1)->previous();} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator_previous(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_Iterator_previous__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_Iterator_previous__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "Iterator.previous",  "    swig::Iterator * Iterator.previous(size_t n)\n"
  "    swig::Iterator * Iterator.previous()\n"); return Qnil; }

/*
  Document-method: OpenBabel::Iterator.==

  call-seq:
    ==(x) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE _wrap_Iterator___eq__(int argc, VALUE *argv, VALUE self) { swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  swig::Iterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator ==", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator ==", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator ==", 2, argv[0])); }
   arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  result = (bool)((swig::Iterator const *)arg1)->operator ==((swig::Iterator const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::Iterator.+

  call-seq:
    +(n) -> Iterator

Add operator.
*/
SWIGINTERN VALUE _wrap_Iterator___add__(int argc, VALUE *argv, VALUE self) { swig::Iterator *arg1 = (swig::Iterator *) 0 ;
  ptrdiff_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; swig::Iterator *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator +", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator +", 2, argv[0] )); }  
  arg2 = static_cast< ptrdiff_t >(val2); try { result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator +(arg2);} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 ); return vresult;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::Iterator.-

  call-seq:
    -(n) -> Iterator
    -(x) -> ptrdiff_t

Substraction operator.
*/
SWIGINTERN VALUE _wrap_Iterator___sub____SWIG_0(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ; ptrdiff_t arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ;
  int ecode2 = 0 ; swig::Iterator *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "ptrdiff_t","operator -", 2, argv[0] )); }  
  arg2 = static_cast< ptrdiff_t >(val2); try { result = (swig::Iterator *)((swig::Iterator const *)arg1)->operator -(arg2);} 
  catch(swig::stop_iteration &_e) { { (void)_e; SWIG_Ruby_ExceptionType(NULL, Qnil); SWIG_fail; }  } 
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__Iterator, SWIG_POINTER_OWN |  0 ); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator___sub____SWIG_1(int argc, VALUE *argv, VALUE self) {
  swig::Iterator *arg1 = (swig::Iterator *) 0 ; swig::Iterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ;
  int res2 = 0 ; ptrdiff_t result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_swig__Iterator, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "swig::Iterator const *","operator -", 1, self ));  } 
  arg1 = reinterpret_cast< swig::Iterator * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_swig__Iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "swig::Iterator const &","operator -", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "swig::Iterator const &","operator -", 2, argv[0])); }
   arg2 = reinterpret_cast< swig::Iterator * >(argp2);
  result = ((swig::Iterator const *)arg1)->operator -((swig::Iterator const &)*arg2);
  vresult = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Iterator___sub__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_swig__Iterator, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_Iterator___sub____SWIG_1(nargs, args, self);}  check_1:
  if (argc == 2) { return _wrap_Iterator___sub____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "__sub__.new",  "    __sub__.new(ptrdiff_t n)\n"
  "    __sub__.new(swig::Iterator const &x)\n"); return Qnil; }
SWIGINTERN void
free_swig_Iterator(swig::Iterator *arg1) {
    delete arg1;
}

swig_class SwigClassVectorInt;


/*
  Document-method: OpenBabel::VectorInt.dup

  call-seq:
    dup -> VectorInt

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorInt_dup(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","dup", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorInt_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","inspect", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = (VALUE)std_vector_Sl_int_Sg__inspect(arg1); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.to_a

  call-seq:
    to_a -> VALUE

Convert VectorInt to an Array.
*/
SWIGINTERN VALUE _wrap_VectorInt_to_a(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","to_a", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = (VALUE)std_vector_Sl_int_Sg__to_a(arg1); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorInt_to_s(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","to_s", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = (VALUE)std_vector_Sl_int_Sg__to_s(arg1); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ;
  std::vector< int >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ;
  int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","slice", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< int >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_int_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.each

  call-seq:
    each -> VectorInt

Iterate thru each element in the VectorInt.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorInt_each(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","each", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.select

  call-seq:
    select -> VectorInt

Iterate thru each element in the VectorInt and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorInt_select(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","select", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.reject_bang

  call-seq:
    reject_bang -> VectorInt

Iterate thru each element in the VectorInt and reject those that fail a condition.  A block must be provided.  VectorInt is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorInt_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","reject_bang", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorInt_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","delete_at", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2); result = (VALUE)std_vector_Sl_int_Sg__delete_at(arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::value_type *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< int >::value_type temp2 ; int val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","__delete2__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::value_type","__delete2__", 2, argv[0] )); }
    temp2 = static_cast< std::vector< int >::value_type >(val2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_int_Sg____delete2__(arg1,(int const &)*arg2); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_pop(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","pop", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = (VALUE)std_vector_Sl_int_Sg__pop(arg1); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_push(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; std::vector< int >::value_type temp2 ; int val2 ;
  int ecode2 = 0 ; std::vector< int >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","push", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::value_type","push", 2, argv[0] )); }
    temp2 = static_cast< std::vector< int >::value_type >(val2); arg2 = &temp2;
  result = (std::vector< int >::value_type)std_vector_Sl_int_Sg__push(arg1,(int const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.reject

  call-seq:
    reject -> VectorInt

Iterate thru each element in the VectorInt and reject those that fail a condition returning a new VectorInt.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorInt_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","reject", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorInt_at(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","at", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_int_Sg__at((std::vector< int > const *)arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorInt___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ;
  std::vector< int >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ;
  int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< int >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_int_Sg____getitem____SWIG_0((std::vector< int > const *)arg1,arg2,arg3); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_int_Sg____getitem____SWIG_1((std::vector< int > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< int > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_int_Sg____getitem____SWIG_2((std::vector< int > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorInt___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorInt___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorInt___getitem____SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< int >::difference_type i, std::vector< int >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< int >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n"); return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorInt___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ;
  std::vector< int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< int >::value_type temp3 ; int val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","__setitem__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::value_type","__setitem__", 3, argv[1] )); }
    temp3 = static_cast< std::vector< int >::value_type >(val3); arg3 = &temp3;
  result = (VALUE)std_vector_Sl_int_Sg____setitem____SWIG_0(arg1,arg2,(int const &)*arg3); vresult = result; return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ;
  std::vector< int >::difference_type arg3 ; std::vector< int,std::allocator< int > > *arg4 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","__setitem__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< int >::difference_type >(val3); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_int_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< int,std::allocator< int > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorInt___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorInt___setitem____SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< int >::difference_type i, std::vector< int >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< int >::difference_type i, std::vector< int >::difference_type j, std::vector< int,std::allocator< int > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","shift", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = (VALUE)std_vector_Sl_int_Sg__shift(arg1); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.insert

  call-seq:
    insert(pos, argc, ?) -> VectorInt
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::difference_type arg2 ; int arg3 ;
  VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.unshift

  call-seq:
    unshift(argc, ?) -> VectorInt

Add one or more elements at the beginning of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ; void *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","unshift", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorInt__SWIG_0(int argc, VALUE *argv, VALUE self) { std::vector< int > *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< int > *)new std::vector< int >(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorInt__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< int > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const &","std::vector<(int)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int > const &","std::vector<(int)>", 1, argv[0])); }
     arg1 = ptr; }  result = (std::vector< int > *)new std::vector< int >((std::vector< int > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.empty

  call-seq:
    empty -> bool

Check if the VectorInt is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorInt_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","empty", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = (bool)((std::vector< int > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.size

  call-seq:
    size -> size_type

Size or Length of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_size(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","size", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.clear

  call-seq:
    clear

Clear VectorInt contents.
*/
SWIGINTERN VALUE _wrap_VectorInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","clear", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_swap(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  std::vector< int > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","swap", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< int > &","swap", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< int > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< int > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< int >::allocator_type(static_cast< const std::vector< int >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","begin", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< int >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_end(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int >::const_iterator result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","end", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< int >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","rbegin", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< int >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_rend(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int >::const_reverse_iterator result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","rend", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< int >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorInt__SWIG_2(int argc, VALUE *argv, VALUE self) { std::vector< int >::size_type arg1 ;
  size_t val1 ; int ecode1 = 0 ; std::vector< int > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< int >::size_type","std::vector<(int)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< int >::size_type >(val1); result = (std::vector< int > *)new std::vector< int >(arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","resize", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  swig::Iterator *iter2 = 0 ; int res2 ; std::vector< int >::iterator result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< int >::iterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::iterator arg2 ; std::vector< int >::iterator arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< int >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< int >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< int >::iterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VectorInt_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorInt_erase__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VectorInt.erase", 
  "    std::vector< int >::iterator VectorInt.erase(std::vector< int >::iterator pos)\n"
  "    std::vector< int >::iterator VectorInt.erase(std::vector< int >::iterator first, std::vector< int >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorInt_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorInt__SWIG_3(int argc, VALUE *argv, VALUE self) { std::vector< int >::size_type arg1 ;
  std::vector< int >::value_type *arg2 = 0 ; size_t val1 ; int ecode1 = 0 ; std::vector< int >::value_type temp2 ; int val2 ;
  int ecode2 = 0 ; std::vector< int > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< int >::size_type","std::vector<(int)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< int >::size_type >(val1); ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::value_type","std::vector<(int)>", 2, argv[1] )); }
    temp2 = static_cast< std::vector< int >::value_type >(val2); arg2 = &temp2;
  result = (std::vector< int > *)new std::vector< int >(arg1,(std::vector< int >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorInt(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorInt__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorInt__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorInt__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorInt__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorInt.new", 
  "    VectorInt.new()\n" "    VectorInt.new(std::vector< int > const &)\n"
  "    VectorInt.new(std::vector< int >::size_type size)\n"
  "    VectorInt.new(std::vector< int >::size_type size, std::vector< int >::value_type const &value)\n"); return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.front

  call-seq:
    front -> value_type

Return the first element in VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_front(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","front", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int >::value_type *) &((std::vector< int > const *)arg1)->front();
  vresult = SWIG_From_int(static_cast< int >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.back

  call-seq:
    back -> value_type

Return the last element in VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_back(int argc, VALUE *argv, VALUE self) { std::vector< int > *arg1 = (std::vector< int > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int >::value_type *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","back", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int >::value_type *) &((std::vector< int > const *)arg1)->back();
  vresult = SWIG_From_int(static_cast< int >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.assign

  call-seq:
    assign(n, x)

Assign a new VectorInt or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorInt_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::size_type arg2 ;
  std::vector< int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  std::vector< int >::value_type temp3 ; int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","assign", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::size_type >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::value_type","assign", 3, argv[1] )); }
    temp3 = static_cast< std::vector< int >::value_type >(val3); arg3 = &temp3;
  (arg1)->assign(arg2,(std::vector< int >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::size_type arg2 ;
  std::vector< int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  std::vector< int >::value_type temp3 ; int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","resize", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::size_type >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::value_type","resize", 3, argv[1] )); }
    temp3 = static_cast< std::vector< int >::value_type >(val3); arg3 = &temp3;
  (arg1)->resize(arg2,(std::vector< int >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VectorInt_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorInt_resize__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VectorInt.resize", 
  "    void VectorInt.resize(std::vector< int >::size_type new_size)\n"
  "    void VectorInt.resize(std::vector< int >::size_type new_size, std::vector< int >::value_type const &x)\n"); return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.insert

  call-seq:
    insert(pos, argc, ?) -> VectorInt
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::iterator arg2 ;
  std::vector< int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< int >::value_type temp3 ; int val3 ; int ecode3 = 0 ; std::vector< int >::iterator result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::value_type","insert", 3, argv[1] )); }
    temp3 = static_cast< std::vector< int >::value_type >(val3); arg3 = &temp3;
  result = (arg1)->insert(arg2,(std::vector< int >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< int >::iterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::iterator arg2 ; std::vector< int >::size_type arg3 ;
  std::vector< int >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  size_t val3 ; int ecode3 = 0 ; std::vector< int >::value_type temp4 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< int >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< int >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< int >::size_type >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::vector< int >::value_type","insert", 4, argv[2] )); }
    temp4 = static_cast< std::vector< int >::value_type >(val4); arg4 = &temp4;
  (arg1)->insert(arg2,arg3,(std::vector< int >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< int >::iterator > *>(iter) != 0));} 
    if (!_v) goto check_1; return _wrap_VectorInt_insert__SWIG_1(nargs, args, self);}  check_1: if (argc >= 3) {
    return _wrap_VectorInt_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorInt_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< int >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< int >::iterator pos, std::vector< int >::value_type const &x)\n"
  "    void insert(std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorInt for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorInt_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; std::vector< int >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","reserve", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< int >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< int >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorInt.
*/
SWIGINTERN VALUE _wrap_VectorInt_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::vector< int >::size_type result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > const *","capacity", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); result = ((std::vector< int > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorInt_map_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","map_bang", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1);
  result = (std::vector< int,std::allocator< int > > *)std_vector_Sl_int_Sg__map_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorInt.__delete__

  call-seq:
    __delete__(val) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE _wrap_VectorInt___delete__(int argc, VALUE *argv, VALUE self) {
  std::vector< int > *arg1 = (std::vector< int > *) 0 ; int *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; int temp2 ; int val2 ;
  int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int > *","__delete__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< int > * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","__delete__", 2, argv[0] )); }  
  temp2 = static_cast< int >(val2); arg2 = &temp2; result = (VALUE)std_vector_Sl_int_Sg____delete__(arg1,(int const &)*arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_int_Sg_(std::vector< int > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorUnsignedInt;


/*
  Document-method: OpenBabel::VectorUnsignedInt.dup

  call-seq:
    dup -> VectorUnsignedInt

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","dup", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.to_a

  call-seq:
    to_a -> VALUE

Convert VectorUnsignedInt to an Array.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","to_a", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__to_a(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","to_s", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__to_s(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","slice", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< unsigned int >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.each

  call-seq:
    each -> VectorUnsignedInt

Iterate thru each element in the VectorUnsignedInt.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","each", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.select

  call-seq:
    select -> VectorUnsignedInt

Iterate thru each element in the VectorUnsignedInt and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_select(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.reject_bang

  call-seq:
    reject_bang -> VectorUnsignedInt

Iterate thru each element in the VectorUnsignedInt and reject those that fail a condition.  A block must be provided.  VectorUnsignedInt is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::value_type *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< unsigned int >::value_type temp2 ; unsigned int val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","__delete2__", 2, argv[0] )); }
    temp2 = static_cast< std::vector< unsigned int >::value_type >(val2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____delete2__(arg1,(unsigned int const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","pop", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__pop(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::value_type *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< unsigned int >::value_type temp2 ; unsigned int val2 ; int ecode2 = 0 ;
  std::vector< unsigned int >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","push", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","push", 2, argv[0] )); }
    temp2 = static_cast< std::vector< unsigned int >::value_type >(val2); arg2 = &temp2;
  result = (std::vector< unsigned int >::value_type)std_vector_Sl_unsigned_SS_int_Sg__push(arg1,(unsigned int const &)*arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.reject

  call-seq:
    reject -> VectorUnsignedInt

Iterate thru each element in the VectorUnsignedInt and reject those that fail a condition returning a new VectorUnsignedInt.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_at(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__at((std::vector< unsigned int > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< unsigned int >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____getitem____SWIG_0((std::vector< unsigned int > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____getitem____SWIG_1((std::vector< unsigned int > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____getitem____SWIG_2((std::vector< unsigned int > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorUnsignedInt___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorUnsignedInt___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorUnsignedInt___getitem____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< unsigned int >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n"); return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< unsigned int >::value_type temp3 ; unsigned int val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","__setitem__", 3, argv[1] )); }
    temp3 = static_cast< std::vector< unsigned int >::value_type >(val3); arg3 = &temp3;
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____setitem____SWIG_0(arg1,arg2,(unsigned int const &)*arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  std::vector< unsigned int >::difference_type arg3 ; std::vector< unsigned int,std::allocator< unsigned int > > *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< unsigned int >::difference_type >(val3); {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< unsigned int,std::allocator< unsigned int > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorUnsignedInt___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorUnsignedInt___setitem____SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< unsigned int >::difference_type i, std::vector< unsigned int >::difference_type j, std::vector< unsigned int,std::allocator< unsigned int > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","shift", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.insert

  call-seq:
    insert(pos, argc, ?) -> VectorUnsignedInt
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::difference_type arg2 ;
  int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.unshift

  call-seq:
    unshift(argc, ?) -> VectorUnsignedInt

Add one or more elements at the beginning of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ;
  VALUE vresult = Qnil; if (argc < 1) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorUnsignedInt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< unsigned int > *)new std::vector< unsigned int >(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorUnsignedInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = 0 ; int res1 = SWIG_OLDOBJ ; std::vector< unsigned int > *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const &","std::vector<(unsigned int)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int > const &","std::vector<(unsigned int)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< unsigned int > *)new std::vector< unsigned int >((std::vector< unsigned int > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.empty

  call-seq:
    empty -> bool

Check if the VectorUnsignedInt is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (bool)((std::vector< unsigned int > const *)arg1)->empty(); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.size

  call-seq:
    size -> size_type

Size or Length of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_size(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = ((std::vector< unsigned int > const *)arg1)->size(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.clear

  call-seq:
    clear

Clear VectorUnsignedInt contents.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","clear", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","swap", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< unsigned int > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< unsigned int > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = ((std::vector< unsigned int > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< unsigned int >::allocator_type(static_cast< const std::vector< unsigned int >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = ((std::vector< unsigned int > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< unsigned int >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_end(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); result = ((std::vector< unsigned int > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< unsigned int >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = ((std::vector< unsigned int > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< unsigned int >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = ((std::vector< unsigned int > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< unsigned int >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorUnsignedInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ; std::vector< unsigned int > *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","std::vector<(unsigned int)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< unsigned int >::size_type >(val1);
  result = (std::vector< unsigned int > *)new std::vector< unsigned int >(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::size_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::iterator arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; std::vector< unsigned int >::iterator result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< unsigned int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< unsigned int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< unsigned int >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::iterator arg2 ;
  std::vector< unsigned int >::iterator arg3 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  swig::Iterator *iter3 = 0 ; int res3 ; std::vector< unsigned int >::iterator result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< unsigned int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< unsigned int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< unsigned int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< unsigned int >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< unsigned int >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorUnsignedInt_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorUnsignedInt_erase__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorUnsignedInt.erase", 
  "    std::vector< unsigned int >::iterator VectorUnsignedInt.erase(std::vector< unsigned int >::iterator pos)\n"
  "    std::vector< unsigned int >::iterator VectorUnsignedInt.erase(std::vector< unsigned int >::iterator first, std::vector< unsigned int >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorUnsignedInt_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorUnsignedInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorUnsignedInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int >::size_type arg1 ; std::vector< unsigned int >::value_type *arg2 = 0 ; size_t val1 ;
  int ecode1 = 0 ; std::vector< unsigned int >::value_type temp2 ; unsigned int val2 ; int ecode2 = 0 ;
  std::vector< unsigned int > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","std::vector<(unsigned int)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< unsigned int >::size_type >(val1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","std::vector<(unsigned int)>", 2, argv[1] )); }
    temp2 = static_cast< std::vector< unsigned int >::value_type >(val2); arg2 = &temp2;
  result = (std::vector< unsigned int > *)new std::vector< unsigned int >(arg1,(std::vector< unsigned int >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorUnsignedInt(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs; if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorUnsignedInt__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorUnsignedInt__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorUnsignedInt__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorUnsignedInt__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "VectorUnsignedInt.new",  "    VectorUnsignedInt.new()\n"
  "    VectorUnsignedInt.new(std::vector< unsigned int > const &)\n"
  "    VectorUnsignedInt.new(std::vector< unsigned int >::size_type size)\n"
  "    VectorUnsignedInt.new(std::vector< unsigned int >::size_type size, std::vector< unsigned int >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.front

  call-seq:
    front -> value_type

Return the first element in VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_front(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int >::value_type *) &((std::vector< unsigned int > const *)arg1)->front();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.back

  call-seq:
    back -> value_type

Return the last element in VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_back(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int >::value_type *) &((std::vector< unsigned int > const *)arg1)->back();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.assign

  call-seq:
    assign(n, x)

Assign a new VectorUnsignedInt or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::size_type arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  std::vector< unsigned int >::value_type temp3 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::size_type >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","assign", 3, argv[1] )); }
    temp3 = static_cast< std::vector< unsigned int >::value_type >(val3); arg3 = &temp3;
  (arg1)->assign(arg2,(std::vector< unsigned int >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::size_type arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  std::vector< unsigned int >::value_type temp3 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::size_type >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","resize", 3, argv[1] )); }
    temp3 = static_cast< std::vector< unsigned int >::value_type >(val3); arg3 = &temp3;
  (arg1)->resize(arg2,(std::vector< unsigned int >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorUnsignedInt_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorUnsignedInt_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorUnsignedInt.resize", 
  "    void VectorUnsignedInt.resize(std::vector< unsigned int >::size_type new_size)\n"
  "    void VectorUnsignedInt.resize(std::vector< unsigned int >::size_type new_size, std::vector< unsigned int >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.insert

  call-seq:
    insert(pos, argc, ?) -> VectorUnsignedInt
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::iterator arg2 ;
  std::vector< unsigned int >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< unsigned int >::value_type temp3 ; unsigned int val3 ; int ecode3 = 0 ;
  std::vector< unsigned int >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< unsigned int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< unsigned int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","insert", 3, argv[1] )); }
    temp3 = static_cast< std::vector< unsigned int >::value_type >(val3); arg3 = &temp3;
  result = (arg1)->insert(arg2,(std::vector< unsigned int >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< unsigned int >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::iterator arg2 ;
  std::vector< unsigned int >::size_type arg3 ; std::vector< unsigned int >::value_type *arg4 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; size_t val3 ; int ecode3 = 0 ;
  std::vector< unsigned int >::value_type temp4 ; unsigned int val4 ; int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< unsigned int >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< unsigned int >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< unsigned int >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< unsigned int >::size_type >(val3); ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::vector< unsigned int >::value_type","insert", 4, argv[2] )); }
    temp4 = static_cast< std::vector< unsigned int >::value_type >(val4); arg4 = &temp4;
  (arg1)->insert(arg2,arg3,(std::vector< unsigned int >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< unsigned int >::iterator > *>(iter) != 0));} 
    if (!_v) goto check_1; { { int res = SWIG_AsVal_unsigned_SS_int(argv[2], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorUnsignedInt_insert__SWIG_1(nargs, args, self);}  check_1: if (argc >= 3) {
    return _wrap_VectorUnsignedInt_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorUnsignedInt_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< unsigned int >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::value_type const &x)\n"
  "    void insert(std::vector< unsigned int >::iterator pos, std::vector< unsigned int >::size_type n, std::vector< unsigned int >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorUnsignedInt for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; std::vector< unsigned int >::size_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< unsigned int >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< unsigned int >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorUnsignedInt.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = ((std::vector< unsigned int > const *)arg1)->capacity(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorUnsignedInt_map_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","map_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *)std_vector_Sl_unsigned_SS_int_Sg__map_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorUnsignedInt.__delete__

  call-seq:
    __delete__(val) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE _wrap_VectorUnsignedInt___delete__(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int > *arg1 = (std::vector< unsigned int > *) 0 ; unsigned int *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; unsigned int temp2 ; unsigned int val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int > *","__delete__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< unsigned int > * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","__delete__", 2, argv[0] )); }  
  temp2 = static_cast< unsigned int >(val2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_unsigned_SS_int_Sg____delete__(arg1,(unsigned int const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_unsigned_SS_int_Sg_(std::vector< unsigned int > *arg1) {
    delete arg1;
}

swig_class SwigClassVVInt;


/*
  Document-method: OpenBabel::VVInt.dup

  call-seq:
    dup -> VVInt

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VVInt_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VVInt_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.to_a

  call-seq:
    to_a -> VALUE

Convert VVInt to an Array.
*/
SWIGINTERN VALUE _wrap_VVInt_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VVInt_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; std::vector< std::vector< int > >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::vector< int > >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.each

  call-seq:
    each -> VVInt

Iterate thru each element in the VVInt.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VVInt_each(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.select

  call-seq:
    select -> VVInt

Iterate thru each element in the VVInt and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VVInt_select(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.reject_bang

  call-seq:
    reject_bang -> VVInt

Iterate thru each element in the VVInt and reject those that fail a condition.  A block must be provided.  VVInt is modified in place.
*/
SWIGINTERN VALUE _wrap_VVInt_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VVInt_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VVInt___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","__delete2__", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","__delete2__", 2, argv[0])); }
     arg2 = ptr; } 
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg____delete2__(arg1,(std::vector< int,std::allocator< int > > const &)*arg2);
  vresult = result; if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","pop", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__pop(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_push(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ;
  std::vector< std::vector< int > >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","push", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","push", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","push", 2, argv[0])); }
     arg2 = ptr; } 
  result = std_vector_Sl_std_vector_Sl_int_Sg__Sg__push(arg1,(std::vector< int,std::allocator< int > > const &)*arg2);
  vresult = swig::from(static_cast< std::vector<int,std::allocator< int > > >(result)); if (SWIG_IsNewObj(res2)) delete arg2;
  return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }

/*
  Document-method: OpenBabel::VVInt.reject

  call-seq:
    reject -> VVInt

Iterate thru each element in the VVInt and reject those that fail a condition returning a new VVInt.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VVInt_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VVInt_at(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__at((std::vector< std::vector< int > > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VVInt___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; std::vector< std::vector< int > >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::vector< int > >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem____SWIG_0((std::vector< std::vector< int > > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem____SWIG_1((std::vector< std::vector< int > > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg____getitem____SWIG_2((std::vector< std::vector< int > > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VVInt___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VVInt___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VVInt___getitem____SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< std::vector< int > >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VVInt___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; std::vector< std::vector< int > >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; int res3 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res3 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","__setitem__", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","__setitem__", 3, argv[1])); }
     arg3 = ptr; } 
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem____SWIG_0(arg1,arg2,(std::vector< int,std::allocator< int > > const &)*arg3);
  vresult = result; if (SWIG_IsNewObj(res3)) delete arg3; return vresult; fail: if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil; }
SWIGINTERN VALUE _wrap_VVInt___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; std::vector< std::vector< int > >::difference_type arg3 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::vector< int > >::difference_type >(val3); {
    std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *ptr = (std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VVInt___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VVInt___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VVInt___setitem____SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< std::vector< int > >::difference_type i, std::vector< std::vector< int > >::difference_type j, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (VALUE)std_vector_Sl_std_vector_Sl_int_Sg__Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.insert

  call-seq:
    insert(pos, argc, ?) -> VVInt
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if (argc < 2) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.unshift

  call-seq:
    unshift(argc, ?) -> VVInt

Add one or more elements at the beginning of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if (argc < 1) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)std_vector_Sl_std_vector_Sl_int_Sg__Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVInt__SWIG_0(int argc, VALUE *argv, VALUE self) { std::vector< std::vector< int > > *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< std::vector< int > > *)new std::vector< std::vector< int > >(); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVInt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int,std::allocator< int > > > *arg1 = 0 ; int res1 = SWIG_OLDOBJ ;
  std::vector< std::vector< int > > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *ptr = (std::vector<std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int,std::allocator< int > > > const &","std::vector<(std::vector<(int)>)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int,std::allocator< int > > > const &","std::vector<(std::vector<(int)>)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< std::vector< int > > *)new std::vector< std::vector< int > >((std::vector< std::vector< int,std::allocator< int > > > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.empty

  call-seq:
    empty -> bool

Check if the VVInt is empty or not.
*/
SWIGINTERN VALUE _wrap_VVInt_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (bool)((std::vector< std::vector< int > > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.size

  call-seq:
    size -> size_type

Size or Length of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_size(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->size(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.clear

  call-seq:
    clear

Clear VVInt contents.
*/
SWIGINTERN VALUE _wrap_VVInt_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int,std::allocator< int > > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int,std::allocator< int > > > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int,std::allocator< int > > > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< std::vector< int,std::allocator< int > > > * >(argp2); (arg1)->swap(*arg2);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::vector< int,std::allocator< int > > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< std::vector< int > >::allocator_type(static_cast< const std::vector< std::vector< int > >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::vector< int > >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_end(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::vector< int > >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::vector< int > >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::vector< int > >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVInt__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< std::vector< int > > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","std::vector<(std::vector<(int)>)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< std::vector< int > >::size_type >(val1);
  result = (std::vector< std::vector< int > > *)new std::vector< std::vector< int > >(arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< std::vector< int > >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::vector< int > >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::vector< int > >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::vector< int > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::iterator arg2 ; std::vector< std::vector< int > >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< std::vector< int > >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::vector< int > >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::vector< int > >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< std::vector< int > >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::vector< int > >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::vector< int > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VVInt_erase__SWIG_0(nargs, args, self);}  if (argc == 3) { return _wrap_VVInt_erase__SWIG_1(nargs, args, self);}
   fail: Ruby_Format_OverloadedError( argc, 4, "VVInt.erase", 
  "    std::vector< std::vector< int > >::iterator VVInt.erase(std::vector< std::vector< int > >::iterator pos)\n"
  "    std::vector< std::vector< int > >::iterator VVInt.erase(std::vector< std::vector< int > >::iterator first, std::vector< std::vector< int > >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VVInt_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VVInt_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VVInt__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > >::size_type arg1 ; std::vector< std::vector< int > >::value_type *arg2 = 0 ; size_t val1 ;
  int ecode1 = 0 ; int res2 = SWIG_OLDOBJ ; std::vector< std::vector< int > > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","std::vector<(std::vector<(int)>)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< std::vector< int > >::size_type >(val1); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res2 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","std::vector<(std::vector<(int)>)>", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","std::vector<(std::vector<(int)>)>", 2, argv[1])); }
     arg2 = ptr; } 
  result = (std::vector< std::vector< int > > *)new std::vector< std::vector< int > >(arg1,(std::vector< std::vector< int > >::value_type const &)*arg2);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res2)) delete arg2; return self; fail: if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil; }
SWIGINTERN VALUE _wrap_new_VVInt(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VVInt__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VVInt__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VVInt__SWIG_1(nargs, args, self);}  if (argc == 2) { return _wrap_new_VVInt__SWIG_3(nargs, args, self);} 
  fail: Ruby_Format_OverloadedError( argc, 2, "VVInt.new",  "    VVInt.new()\n"
  "    VVInt.new(std::vector< std::vector< int,std::allocator< int > > > const &)\n"
  "    VVInt.new(std::vector< std::vector< int > >::size_type size)\n"
  "    VVInt.new(std::vector< std::vector< int > >::size_type size, std::vector< std::vector< int > >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.front

  call-seq:
    front -> value_type

Return the first element in VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_front(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int > >::value_type *) &((std::vector< std::vector< int > > const *)arg1)->front();
  vresult = swig::from(static_cast< std::vector<int,std::allocator< int > > >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.back

  call-seq:
    back -> value_type

Return the last element in VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_back(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = (std::vector< std::vector< int > >::value_type *) &((std::vector< std::vector< int > > const *)arg1)->back();
  vresult = swig::from(static_cast< std::vector<int,std::allocator< int > > >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVInt.assign

  call-seq:
    assign(n, x)

Assign a new VVInt or portion of it.
*/
SWIGINTERN VALUE _wrap_VVInt_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type arg2 ; std::vector< std::vector< int > >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; int res3 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::size_type >(val2); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res3 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","assign", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","assign", 3, argv[1])); }
     arg3 = ptr; }  (arg1)->assign(arg2,(std::vector< std::vector< int > >::value_type const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail: if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }

/*
  Document-method: OpenBabel::VVInt.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type arg2 ; std::vector< std::vector< int > >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; int res3 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::size_type >(val2); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res3 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","resize", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","resize", 3, argv[1])); }
     arg3 = ptr; }  (arg1)->resize(arg2,(std::vector< std::vector< int > >::value_type const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail: if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VVInt_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VVInt_resize__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VVInt.resize", 
  "    void VVInt.resize(std::vector< std::vector< int > >::size_type new_size)\n"
  "    void VVInt.resize(std::vector< std::vector< int > >::size_type new_size, std::vector< std::vector< int > >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.insert

  call-seq:
    insert(pos, argc, ?) -> VVInt
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::iterator arg2 ; std::vector< std::vector< int > >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; int res3 = SWIG_OLDOBJ ;
  std::vector< std::vector< int > >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::vector< int > >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::vector< int > >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","insert", 2, argv[0] )); }
     }  { std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res3 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","insert", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","insert", 3, argv[1])); }
     arg3 = ptr; }  result = (arg1)->insert(arg2,(std::vector< std::vector< int > >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::vector< int > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); if (SWIG_IsNewObj(res3)) delete arg3; return vresult; fail:
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::iterator arg2 ; std::vector< std::vector< int > >::size_type arg3 ;
  std::vector< std::vector< int > >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; size_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::vector< int > >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::vector< int > >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::vector< int > >::size_type >(val3); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::value_type const &","insert", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int > >::value_type const &","insert", 4, argv[2])); }
     arg4 = ptr; }  (arg1)->insert(arg2,arg3,(std::vector< std::vector< int > >::value_type const &)*arg4);
  if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VVInt_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< std::vector< int > >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { int res = swig::asptr(argv[2], (std::vector<int,std::allocator< int > >**)(0));
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VVInt_insert__SWIG_1(nargs, args, self);}  check_1:
  if (argc >= 3) { return _wrap_VVInt_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VVInt_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< std::vector< int > >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< std::vector< int > >::iterator pos, std::vector< std::vector< int > >::value_type const &x)\n"
  "    void insert(std::vector< std::vector< int > >::iterator pos, std::vector< std::vector< int > >::size_type n, std::vector< std::vector< int > >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.reserve

  call-seq:
    reserve(n)

Reserve memory in the VVInt for a number of elements.
*/
SWIGINTERN VALUE _wrap_VVInt_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ;
  std::vector< std::vector< int > >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::vector< int > >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::vector< int > >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VVInt.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VVInt.
*/
SWIGINTERN VALUE _wrap_VVInt_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< std::vector< int > > *arg1 = (std::vector< std::vector< int > > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int > >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::vector< int > > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::vector< int > > * >(argp1);
  result = ((std::vector< std::vector< int > > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_std_vector_Sl_int_Sg__Sg_(std::vector< std::vector< int > > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorDouble;


/*
  Document-method: OpenBabel::VectorDouble.dup

  call-seq:
    dup -> VectorDouble

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorDouble_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","dup", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorDouble_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","inspect", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = (VALUE)std_vector_Sl_double_Sg__inspect(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.to_a

  call-seq:
    to_a -> VALUE

Convert VectorDouble to an Array.
*/
SWIGINTERN VALUE _wrap_VectorDouble_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","to_a", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = (VALUE)std_vector_Sl_double_Sg__to_a(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorDouble_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","to_s", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = (VALUE)std_vector_Sl_double_Sg__to_s(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ;
  std::vector< double >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","slice", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< double >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_double_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.each

  call-seq:
    each -> VectorDouble

Iterate thru each element in the VectorDouble.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorDouble_each(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","each", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.select

  call-seq:
    select -> VectorDouble

Iterate thru each element in the VectorDouble and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorDouble_select(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","select", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.reject_bang

  call-seq:
    reject_bang -> VectorDouble

Iterate thru each element in the VectorDouble and reject those that fail a condition.  A block must be provided.  VectorDouble is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorDouble_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","reject_bang", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorDouble_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","delete_at", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_double_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::value_type *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< double >::value_type temp2 ; double val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","__delete2__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::value_type","__delete2__", 2, argv[0] )); }
    temp2 = static_cast< std::vector< double >::value_type >(val2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_double_Sg____delete2__(arg1,(double const &)*arg2); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","pop", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = (VALUE)std_vector_Sl_double_Sg__pop(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_push(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::value_type *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< double >::value_type temp2 ; double val2 ; int ecode2 = 0 ;
  std::vector< double >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","push", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::value_type","push", 2, argv[0] )); }
    temp2 = static_cast< std::vector< double >::value_type >(val2); arg2 = &temp2;
  result = (std::vector< double >::value_type)std_vector_Sl_double_Sg__push(arg1,(double const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.reject

  call-seq:
    reject -> VectorDouble

Iterate thru each element in the VectorDouble and reject those that fail a condition returning a new VectorDouble.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorDouble_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","reject", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorDouble_at(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","at", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_double_Sg__at((std::vector< double > const *)arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorDouble___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ;
  std::vector< double >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< double >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_double_Sg____getitem____SWIG_0((std::vector< double > const *)arg1,arg2,arg3); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_double_Sg____getitem____SWIG_1((std::vector< double > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< double > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_double_Sg____getitem____SWIG_2((std::vector< double > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorDouble___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorDouble___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorDouble___getitem____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< double >::difference_type i, std::vector< double >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< double >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n"); return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorDouble___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ;
  std::vector< double >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< double >::value_type temp3 ; double val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","__setitem__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::value_type","__setitem__", 3, argv[1] )); }
    temp3 = static_cast< std::vector< double >::value_type >(val3); arg3 = &temp3;
  result = (VALUE)std_vector_Sl_double_Sg____setitem____SWIG_0(arg1,arg2,(double const &)*arg3); vresult = result;
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ;
  std::vector< double >::difference_type arg3 ; std::vector< double,std::allocator< double > > *arg4 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","__setitem__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< double >::difference_type >(val3); {
    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double,std::allocator< double > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_double_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< double,std::allocator< double > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorDouble___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorDouble___setitem____SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< double >::difference_type i, std::vector< double >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< double >::difference_type i, std::vector< double >::difference_type j, std::vector< double,std::allocator< double > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","shift", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = (VALUE)std_vector_Sl_double_Sg__shift(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.insert

  call-seq:
    insert(pos, argc, ?) -> VectorDouble
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::difference_type arg2 ; int arg3 ;
  VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.unshift

  call-seq:
    unshift(argc, ?) -> VectorDouble

Add one or more elements at the beginning of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ; void *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil;
  if (argc < 1) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","unshift", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorDouble__SWIG_0(int argc, VALUE *argv, VALUE self) { std::vector< double > *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< double > *)new std::vector< double >(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorDouble__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< double > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< double > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const &","std::vector<(double)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double > const &","std::vector<(double)>", 1, argv[0])); }
     arg1 = ptr; }  result = (std::vector< double > *)new std::vector< double >((std::vector< double > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.empty

  call-seq:
    empty -> bool

Check if the VectorDouble is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorDouble_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","empty", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = (bool)((std::vector< double > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.size

  call-seq:
    size -> size_type

Size or Length of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_size(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","size", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.clear

  call-seq:
    clear

Clear VectorDouble contents.
*/
SWIGINTERN VALUE _wrap_VectorDouble_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","clear", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","swap", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double > &","swap", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< double > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< double >::allocator_type(static_cast< const std::vector< double >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","begin", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< double >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_end(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","end", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< double >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< double >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","rend", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< double >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorDouble__SWIG_2(int argc, VALUE *argv, VALUE self) { std::vector< double >::size_type arg1 ;
  size_t val1 ; int ecode1 = 0 ; std::vector< double > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< double >::size_type","std::vector<(double)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< double >::size_type >(val1);
  result = (std::vector< double > *)new std::vector< double >(arg1); DATA_PTR(self) = result; return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::size_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","resize", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::iterator arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; std::vector< double >::iterator result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< double >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< double >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::iterator arg2 ;
  std::vector< double >::iterator arg3 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  swig::Iterator *iter3 = 0 ; int res3 ; std::vector< double >::iterator result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< double >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< double >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< double >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorDouble_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorDouble_erase__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorDouble.erase", 
  "    std::vector< double >::iterator VectorDouble.erase(std::vector< double >::iterator pos)\n"
  "    std::vector< double >::iterator VectorDouble.erase(std::vector< double >::iterator first, std::vector< double >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorDouble_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorDouble_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorDouble__SWIG_3(int argc, VALUE *argv, VALUE self) { std::vector< double >::size_type arg1 ;
  std::vector< double >::value_type *arg2 = 0 ; size_t val1 ; int ecode1 = 0 ; std::vector< double >::value_type temp2 ;
  double val2 ; int ecode2 = 0 ; std::vector< double > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< double >::size_type","std::vector<(double)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< double >::size_type >(val1); ecode2 = SWIG_AsVal_double(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::value_type","std::vector<(double)>", 2, argv[1] )); }
    temp2 = static_cast< std::vector< double >::value_type >(val2); arg2 = &temp2;
  result = (std::vector< double > *)new std::vector< double >(arg1,(std::vector< double >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorDouble(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorDouble__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorDouble__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorDouble__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorDouble__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorDouble.new", 
  "    VectorDouble.new()\n" "    VectorDouble.new(std::vector< double > const &)\n"
  "    VectorDouble.new(std::vector< double >::size_type size)\n"
  "    VectorDouble.new(std::vector< double >::size_type size, std::vector< double >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.front

  call-seq:
    front -> value_type

Return the first element in VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_front(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","front", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double >::value_type *) &((std::vector< double > const *)arg1)->front();
  vresult = SWIG_From_double(static_cast< double >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.back

  call-seq:
    back -> value_type

Return the last element in VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_back(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","back", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double >::value_type *) &((std::vector< double > const *)arg1)->back();
  vresult = SWIG_From_double(static_cast< double >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.assign

  call-seq:
    assign(n, x)

Assign a new VectorDouble or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorDouble_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::size_type arg2 ;
  std::vector< double >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  std::vector< double >::value_type temp3 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","assign", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::size_type >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::value_type","assign", 3, argv[1] )); }
    temp3 = static_cast< std::vector< double >::value_type >(val3); arg3 = &temp3;
  (arg1)->assign(arg2,(std::vector< double >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::size_type arg2 ;
  std::vector< double >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  std::vector< double >::value_type temp3 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","resize", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::size_type >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::value_type","resize", 3, argv[1] )); }
    temp3 = static_cast< std::vector< double >::value_type >(val3); arg3 = &temp3;
  (arg1)->resize(arg2,(std::vector< double >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorDouble_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorDouble_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorDouble.resize", 
  "    void VectorDouble.resize(std::vector< double >::size_type new_size)\n"
  "    void VectorDouble.resize(std::vector< double >::size_type new_size, std::vector< double >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.insert

  call-seq:
    insert(pos, argc, ?) -> VectorDouble
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::iterator arg2 ;
  std::vector< double >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< double >::value_type temp3 ; double val3 ; int ecode3 = 0 ; std::vector< double >::iterator result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< double >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::value_type","insert", 3, argv[1] )); }
    temp3 = static_cast< std::vector< double >::value_type >(val3); arg3 = &temp3;
  result = (arg1)->insert(arg2,(std::vector< double >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< double >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::iterator arg2 ;
  std::vector< double >::size_type arg3 ; std::vector< double >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  swig::Iterator *iter2 = 0 ; int res2 ; size_t val3 ; int ecode3 = 0 ; std::vector< double >::value_type temp4 ; double val4 ;
  int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< double >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< double >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< double >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< double >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< double >::size_type >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "std::vector< double >::value_type","insert", 4, argv[2] )); }
    temp4 = static_cast< std::vector< double >::value_type >(val4); arg4 = &temp4;
  (arg1)->insert(arg2,arg3,(std::vector< double >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< double >::iterator > *>(iter) != 0));} 
    if (!_v) goto check_1; { { int res = SWIG_AsVal_double(argv[2], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorDouble_insert__SWIG_1(nargs, args, self);}  check_1: if (argc >= 3) {
    return _wrap_VectorDouble_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorDouble_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< double >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< double >::iterator pos, std::vector< double >::value_type const &x)\n"
  "    void insert(std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorDouble for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorDouble_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; std::vector< double >::size_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","reserve", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< double >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< double >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorDouble.
*/
SWIGINTERN VALUE _wrap_VectorDouble_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< double > * >(argp1); result = ((std::vector< double > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorDouble_map_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","map_bang", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1);
  result = (std::vector< double,std::allocator< double > > *)std_vector_Sl_double_Sg__map_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorDouble.__delete__

  call-seq:
    __delete__(val) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE _wrap_VectorDouble___delete__(int argc, VALUE *argv, VALUE self) {
  std::vector< double > *arg1 = (std::vector< double > *) 0 ; double *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; double temp2 ;
  double val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< double > *","__delete__", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< double > * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","__delete__", 2, argv[0] )); }  
  temp2 = static_cast< double >(val2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_double_Sg____delete__(arg1,(double const &)*arg2); vresult = result; return vresult; fail:
  return Qnil; }
SWIGINTERN void
free_std_vector_Sl_double_Sg_(std::vector< double > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorString;


/*
  Document-method: OpenBabel::VectorString.dup

  call-seq:
    dup -> VectorString

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorString_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","dup", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorString_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = (VALUE)std_vector_Sl_std_string_Sg__inspect(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.to_a

  call-seq:
    to_a -> VALUE

Convert VectorString to an Array.
*/
SWIGINTERN VALUE _wrap_VectorString_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","to_a", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = (VALUE)std_vector_Sl_std_string_Sg__to_a(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorString_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","to_s", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = (VALUE)std_vector_Sl_std_string_Sg__to_s(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  std::vector< std::string >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","slice", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::string >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_std_string_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.each

  call-seq:
    each -> VectorString

Iterate thru each element in the VectorString.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorString_each(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","each", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.select

  call-seq:
    select -> VectorString

Iterate thru each element in the VectorString and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorString_select(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","select", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.reject_bang

  call-seq:
    reject_bang -> VectorString

Iterate thru each element in the VectorString and reject those that fail a condition.  A block must be provided.  VectorString is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorString_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorString_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_std_string_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::value_type *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","__delete2__", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","__delete2__", 2, argv[0])); }
     arg2 = ptr; }  result = (VALUE)std_vector_Sl_std_string_Sg____delete2__(arg1,(std::string const &)*arg2); vresult = result;
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }

/*
  Document-method: OpenBabel::VectorString.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","pop", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = (VALUE)std_vector_Sl_std_string_Sg__pop(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_push(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::value_type *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; std::vector< std::string >::value_type result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","push", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","push", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","push", 2, argv[0])); }
     arg2 = ptr; }  result = std_vector_Sl_std_string_Sg__push(arg1,(std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult;
  fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }

/*
  Document-method: OpenBabel::VectorString.reject

  call-seq:
    reject -> VectorString

Iterate thru each element in the VectorString and reject those that fail a condition returning a new VectorString.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorString_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","reject", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorString_at(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_std_string_Sg__at((std::vector< std::string > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorString___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  std::vector< std::string >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::string >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_std_string_Sg____getitem____SWIG_0((std::vector< std::string > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_std_string_Sg____getitem____SWIG_1((std::vector< std::string > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_std_string_Sg____getitem____SWIG_2((std::vector< std::string > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorString___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorString___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorString___getitem____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< std::string >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n"); return Qnil; }

/*
  Document-method: OpenBabel::VectorString.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorString___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  std::vector< std::string >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2); { std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","__setitem__", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","__setitem__", 3, argv[1])); }
     arg3 = ptr; }  result = (VALUE)std_vector_Sl_std_string_Sg____setitem____SWIG_0(arg1,arg2,(std::string const &)*arg3);
  vresult = result; if (SWIG_IsNewObj(res3)) delete arg3; return vresult; fail: if (SWIG_IsNewObj(res3)) delete arg3;
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorString___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  std::vector< std::string >::difference_type arg3 ; std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::string >::difference_type >(val3); {
    std::vector<std::string,std::allocator< std::string > > *ptr = (std::vector<std::string,std::allocator< std::string > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string,std::allocator< std::string > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string,std::allocator< std::string > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_std_string_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorString___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorString___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorString___setitem____SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, std::vector< std::string,std::allocator< std::string > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorString.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","shift", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = (VALUE)std_vector_Sl_std_string_Sg__shift(arg1);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.insert

  call-seq:
    insert(pos, argc, ?) -> VectorString
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::difference_type arg2 ;
  int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.unshift

  call-seq:
    unshift(argc, ?) -> VectorString

Add one or more elements at the beginning of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ; void *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil;
  if (argc < 1) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorString__SWIG_0(int argc, VALUE *argv, VALUE self) { std::vector< std::string > *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< std::string > *)new std::vector< std::string >(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorString__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< std::string > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< std::string > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<std::string,std::allocator< std::string > > *ptr = (std::vector<std::string,std::allocator< std::string > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const &","std::vector<(std::string)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > const &","std::vector<(std::string)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< std::string > *)new std::vector< std::string >((std::vector< std::string > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorString.empty

  call-seq:
    empty -> bool

Check if the VectorString is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorString_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (bool)((std::vector< std::string > const *)arg1)->empty(); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.size

  call-seq:
    size -> size_type

Size or Length of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_size(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = ((std::vector< std::string > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.clear

  call-seq:
    clear

Clear VectorString contents.
*/
SWIGINTERN VALUE _wrap_VectorString_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","clear", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","swap", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::string > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< std::string > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< std::string > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = ((std::vector< std::string > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< std::string >::allocator_type(static_cast< const std::vector< std::string >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = ((std::vector< std::string > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::string >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_end(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = ((std::vector< std::string > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::string >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = ((std::vector< std::string > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::string >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); result = ((std::vector< std::string > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< std::string >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorString__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ; std::vector< std::string > *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","std::vector<(std::string)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< std::string >::size_type >(val1);
  result = (std::vector< std::string > *)new std::vector< std::string >(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorString.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::size_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","resize", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::iterator arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; std::vector< std::string >::iterator result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::string >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::string >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::string >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::iterator arg2 ;
  std::vector< std::string >::iterator arg3 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  swig::Iterator *iter3 = 0 ; int res3 ; std::vector< std::string >::iterator result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","erase", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::string >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::string >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< std::string >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::string >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::string >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorString_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorString_erase__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorString.erase", 
  "    std::vector< std::string >::iterator VectorString.erase(std::vector< std::string >::iterator pos)\n"
  "    std::vector< std::string >::iterator VectorString.erase(std::vector< std::string >::iterator first, std::vector< std::string >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorString_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorString_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorString__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string >::size_type arg1 ; std::vector< std::string >::value_type *arg2 = 0 ; size_t val1 ; int ecode1 = 0 ;
  int res2 = SWIG_OLDOBJ ; std::vector< std::string > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","std::vector<(std::string)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< std::string >::size_type >(val1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","std::vector<(std::string)>", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","std::vector<(std::string)>", 2, argv[1])); }
     arg2 = ptr; } 
  result = (std::vector< std::string > *)new std::vector< std::string >(arg1,(std::vector< std::string >::value_type const &)*arg2);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res2)) delete arg2; return self; fail: if (SWIG_IsNewObj(res2)) delete arg2;
  return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorString(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorString__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorString__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorString__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorString__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorString.new", 
  "    VectorString.new()\n" "    VectorString.new(std::vector< std::string > const &)\n"
  "    VectorString.new(std::vector< std::string >::size_type size)\n"
  "    VectorString.new(std::vector< std::string >::size_type size, std::vector< std::string >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorString.front

  call-seq:
    front -> value_type

Return the first element in VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_front(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string >::value_type *) &((std::vector< std::string > const *)arg1)->front();
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.back

  call-seq:
    back -> value_type

Return the last element in VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_back(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string >::value_type *) &((std::vector< std::string > const *)arg1)->back();
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.assign

  call-seq:
    assign(n, x)

Assign a new VectorString or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorString_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::size_type arg2 ;
  std::vector< std::string >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","assign", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::size_type >(val2); { std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","assign", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","assign", 3, argv[1])); }
     arg3 = ptr; }  (arg1)->assign(arg2,(std::vector< std::string >::value_type const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail: if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }

/*
  Document-method: OpenBabel::VectorString.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::size_type arg2 ;
  std::vector< std::string >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  int res3 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","resize", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::size_type >(val2); { std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","resize", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","resize", 3, argv[1])); }
     arg3 = ptr; }  (arg1)->resize(arg2,(std::vector< std::string >::value_type const &)*arg3);
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail: if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorString_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorString_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorString.resize", 
  "    void VectorString.resize(std::vector< std::string >::size_type new_size)\n"
  "    void VectorString.resize(std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorString.insert

  call-seq:
    insert(pos, argc, ?) -> VectorString
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::iterator arg2 ;
  std::vector< std::string >::value_type *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  int res3 = SWIG_OLDOBJ ; std::vector< std::string >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::string >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::string >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","insert", 2, argv[0] )); }
     }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","insert", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","insert", 3, argv[1])); }
     arg3 = ptr; }  result = (arg1)->insert(arg2,(std::vector< std::string >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::string >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); if (SWIG_IsNewObj(res3)) delete arg3; return vresult; fail:
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::iterator arg2 ;
  std::vector< std::string >::size_type arg3 ; std::vector< std::string >::value_type *arg4 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; size_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","insert", 1, self ));  } 
  arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< std::string >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< std::string >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< std::string >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< std::string >::size_type >(val3); { std::string *ptr = (std::string *)0;
    res4 = SWIG_AsPtr_std_string(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string >::value_type const &","insert", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string >::value_type const &","insert", 4, argv[2])); }
     arg4 = ptr; }  (arg1)->insert(arg2,arg3,(std::vector< std::string >::value_type const &)*arg4);
  if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< std::string >::iterator > *>(iter) != 0));} 
    if (!_v) goto check_1; { int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_VectorString_insert__SWIG_1(nargs, args, self);}  check_1: if (argc >= 3) {
    return _wrap_VectorString_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorString_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< std::string >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const &x)\n"
  "    void insert(std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorString.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorString for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorString_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::vector< std::string >::size_type arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< std::string >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< std::string >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorString.
*/
SWIGINTERN VALUE _wrap_VectorString_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = ((std::vector< std::string > const *)arg1)->capacity(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorString_map_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","map_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1);
  result = (std::vector< std::string,std::allocator< std::string > > *)std_vector_Sl_std_string_Sg__map_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorString.__delete__

  call-seq:
    __delete__(val) -> VALUE

Delete a matching element.
*/
SWIGINTERN VALUE _wrap_VectorString___delete__(int argc, VALUE *argv, VALUE self) {
  std::vector< std::string > *arg1 = (std::vector< std::string > *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< std::string > *","__delete__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< std::string > * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","__delete__", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","__delete__", 2, argv[0])); }
     arg2 = ptr; }  result = (VALUE)std_vector_Sl_std_string_Sg____delete__(arg1,(std::string const &)*arg2); vresult = result;
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN void
free_std_vector_Sl_std_string_Sg_(std::vector< std::string > *arg1) {
    delete arg1;
}

swig_class SwigClassVVector3;


/*
  Document-method: OpenBabel::VVector3.dup

  call-seq:
    dup -> VVector3

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VVector3_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VVector3_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.to_a

  call-seq:
    to_a -> VALUE

Convert VVector3 to an Array.
*/
SWIGINTERN VALUE _wrap_VVector3_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VVector3_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; std::vector< OpenBabel::vector3 >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.each

  call-seq:
    each -> VVector3

Iterate thru each element in the VVector3.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VVector3_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.select

  call-seq:
    select -> VVector3

Iterate thru each element in the VVector3 and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VVector3_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.reject_bang

  call-seq:
    reject_bang -> VVector3

Iterate thru each element in the VVector3 and reject those that fail a condition.  A block must be provided.  VVector3 is modified in place.
*/
SWIGINTERN VALUE _wrap_VVector3_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VVector3_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VVector3___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","__delete2__", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","__delete2__", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg____delete2__(arg1,(OpenBabel::vector3 const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","pop", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__pop(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_push(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  std::vector< OpenBabel::vector3 >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","push", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","push", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","push", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp2);
  result = std_vector_Sl_OpenBabel_vector3_Sg__push(arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::vector3 >::value_type(static_cast< const std::vector< OpenBabel::vector3 >::value_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.reject

  call-seq:
    reject -> VVector3

Iterate thru each element in the VVector3 and reject those that fail a condition returning a new VVector3.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VVector3_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VVector3_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__at((std::vector< OpenBabel::vector3 > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VVector3___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; std::vector< OpenBabel::vector3 >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg____getitem____SWIG_0((std::vector< OpenBabel::vector3 > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg____getitem____SWIG_1((std::vector< OpenBabel::vector3 > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg____getitem____SWIG_2((std::vector< OpenBabel::vector3 > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VVector3___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VVector3___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VVector3___getitem____SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< OpenBabel::vector3 >::difference_type i, std::vector< OpenBabel::vector3 >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< OpenBabel::vector3 >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VVector3___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; std::vector< OpenBabel::vector3 >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","__setitem__", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","__setitem__", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg____setitem____SWIG_0(arg1,arg2,(OpenBabel::vector3 const &)*arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; std::vector< OpenBabel::vector3 >::difference_type arg3 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val3); {
    std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *ptr = (std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VVector3___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VVector3___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VVector3___setitem____SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< OpenBabel::vector3 >::difference_type i, std::vector< OpenBabel::vector3 >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< OpenBabel::vector3 >::difference_type i, std::vector< OpenBabel::vector3 >::difference_type j, std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_vector3_Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.insert

  call-seq:
    insert(pos, argc, ?) -> VVector3
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.unshift

  call-seq:
    unshift(argc, ?) -> VVector3

Add one or more elements at the beginning of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)std_vector_Sl_OpenBabel_vector3_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVector3__SWIG_0(int argc, VALUE *argv, VALUE self) { std::vector< OpenBabel::vector3 > *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::vector3 > *)new std::vector< OpenBabel::vector3 >(); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVector3__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< OpenBabel::vector3 > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< OpenBabel::vector3 > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *ptr = (std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const &","std::vector<(OpenBabel::vector3)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 > const &","std::vector<(OpenBabel::vector3)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::vector3 > *)new std::vector< OpenBabel::vector3 >((std::vector< OpenBabel::vector3 > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.empty

  call-seq:
    empty -> bool

Check if the VVector3 is empty or not.
*/
SWIGINTERN VALUE _wrap_VVector3_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (bool)((std::vector< OpenBabel::vector3 > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.size

  call-seq:
    size -> size_type

Size or Length of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->size(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.clear

  call-seq:
    clear

Clear VVector3 contents.
*/
SWIGINTERN VALUE _wrap_VVector3_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< OpenBabel::vector3 > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::vector3 >::allocator_type(static_cast< const std::vector< OpenBabel::vector3 >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::vector3 >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::vector3 >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::vector3 >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::vector3 >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVector3__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< OpenBabel::vector3 > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","std::vector<(OpenBabel::vector3)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val1);
  result = (std::vector< OpenBabel::vector3 > *)new std::vector< OpenBabel::vector3 >(arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< OpenBabel::vector3 >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::vector3 >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::iterator arg2 ; std::vector< OpenBabel::vector3 >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::vector3 >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::vector3 >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VVector3_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VVector3_erase__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VVector3.erase", 
  "    std::vector< OpenBabel::vector3 >::iterator VVector3.erase(std::vector< OpenBabel::vector3 >::iterator pos)\n"
  "    std::vector< OpenBabel::vector3 >::iterator VVector3.erase(std::vector< OpenBabel::vector3 >::iterator first, std::vector< OpenBabel::vector3 >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VVector3_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VVector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VVector3__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 >::size_type arg1 ; std::vector< OpenBabel::vector3 >::value_type *arg2 = 0 ; size_t val1 ;
  int ecode1 = 0 ; void *argp2 ; int res2 = 0 ; std::vector< OpenBabel::vector3 > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","std::vector<(OpenBabel::vector3)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","std::vector<(OpenBabel::vector3)>", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","std::vector<(OpenBabel::vector3)>", 2, argv[1])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp2);
  result = (std::vector< OpenBabel::vector3 > *)new std::vector< OpenBabel::vector3 >(arg1,(std::vector< OpenBabel::vector3 >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VVector3(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VVector3__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VVector3__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VVector3__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VVector3__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VVector3.new", 
  "    VVector3.new()\n" "    VVector3.new(std::vector< OpenBabel::vector3 > const &)\n"
  "    VVector3.new(std::vector< OpenBabel::vector3 >::size_type size)\n"
  "    VVector3.new(std::vector< OpenBabel::vector3 >::size_type size, std::vector< OpenBabel::vector3 >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.front

  call-seq:
    front -> value_type

Return the first element in VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3 >::value_type *) &((std::vector< OpenBabel::vector3 > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.back

  call-seq:
    back -> value_type

Return the last element in VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = (std::vector< OpenBabel::vector3 >::value_type *) &((std::vector< OpenBabel::vector3 > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.assign

  call-seq:
    assign(n, x)

Assign a new VVector3 or portion of it.
*/
SWIGINTERN VALUE _wrap_VVector3_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::size_type arg2 ; std::vector< OpenBabel::vector3 >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","assign", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","assign", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< OpenBabel::vector3 >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VVector3.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::size_type arg2 ; std::vector< OpenBabel::vector3 >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","resize", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","resize", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< OpenBabel::vector3 >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VVector3_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VVector3_resize__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VVector3.resize", 
  "    void VVector3.resize(std::vector< OpenBabel::vector3 >::size_type new_size)\n"
  "    void VVector3.resize(std::vector< OpenBabel::vector3 >::size_type new_size, std::vector< OpenBabel::vector3 >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.insert

  call-seq:
    insert(pos, argc, ?) -> VVector3
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::iterator arg2 ; std::vector< OpenBabel::vector3 >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 ; int res3 = 0 ;
  std::vector< OpenBabel::vector3 >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","insert", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","insert", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< OpenBabel::vector3 >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::vector3 >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::iterator arg2 ; std::vector< OpenBabel::vector3 >::size_type arg3 ;
  std::vector< OpenBabel::vector3 >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::value_type const &","insert", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::vector3 >::value_type const &","insert", 4, argv[2])); }
   arg4 = reinterpret_cast< std::vector< OpenBabel::vector3 >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< OpenBabel::vector3 >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VVector3_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::vector3 >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VVector3_insert__SWIG_1(nargs, args, self);}  check_1:
  if (argc >= 3) { return _wrap_VVector3_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VVector3_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::vector3 >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::vector3 >::iterator pos, std::vector< OpenBabel::vector3 >::value_type const &x)\n"
  "    void insert(std::vector< OpenBabel::vector3 >::iterator pos, std::vector< OpenBabel::vector3 >::size_type n, std::vector< OpenBabel::vector3 >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.reserve

  call-seq:
    reserve(n)

Reserve memory in the VVector3 for a number of elements.
*/
SWIGINTERN VALUE _wrap_VVector3_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ;
  std::vector< OpenBabel::vector3 >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::vector3 >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VVector3.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VVector3.
*/
SWIGINTERN VALUE _wrap_VVector3_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::vector3 > *arg1 = (std::vector< OpenBabel::vector3 > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3 >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::vector3 > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::vector3 > * >(argp1);
  result = ((std::vector< OpenBabel::vector3 > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_vector3_Sg_(std::vector< OpenBabel::vector3 > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorMol;


/*
  Document-method: OpenBabel::VectorMol.dup

  call-seq:
    dup -> VectorMol

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorMol_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorMol_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.to_a

  call-seq:
    to_a -> VALUE

Convert VectorMol to an Array.
*/
SWIGINTERN VALUE _wrap_VectorMol_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorMol_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; std::vector< OpenBabel::OBMol >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.each

  call-seq:
    each -> VectorMol

Iterate thru each element in the VectorMol.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorMol_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.select

  call-seq:
    select -> VectorMol

Iterate thru each element in the VectorMol and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorMol_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.reject_bang

  call-seq:
    reject_bang -> VectorMol

Iterate thru each element in the VectorMol and reject those that fail a condition.  A block must be provided.  VectorMol is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorMol_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorMol_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","__delete2__", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","__delete2__", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg____delete2__(arg1,(OpenBabel::OBMol const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","pop", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__pop(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_push(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  std::vector< OpenBabel::OBMol >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","push", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","push", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","push", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp2);
  result = std_vector_Sl_OpenBabel_OBMol_Sg__push(arg1,(OpenBabel::OBMol const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBMol >::value_type(static_cast< const std::vector< OpenBabel::OBMol >::value_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.reject

  call-seq:
    reject -> VectorMol

Iterate thru each element in the VectorMol and reject those that fail a condition returning a new VectorMol.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorMol_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorMol_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__at((std::vector< OpenBabel::OBMol > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorMol___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; std::vector< OpenBabel::OBMol >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg____getitem____SWIG_0((std::vector< OpenBabel::OBMol > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg____getitem____SWIG_1((std::vector< OpenBabel::OBMol > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg____getitem____SWIG_2((std::vector< OpenBabel::OBMol > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorMol___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorMol___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorMol___getitem____SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< OpenBabel::OBMol >::difference_type i, std::vector< OpenBabel::OBMol >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< OpenBabel::OBMol >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorMol___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; std::vector< OpenBabel::OBMol >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","__setitem__", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","__setitem__", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg____setitem____SWIG_0(arg1,arg2,(OpenBabel::OBMol const &)*arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; std::vector< OpenBabel::OBMol >::difference_type arg3 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2); ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val3); {
    std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *ptr = (std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorMol___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorMol___setitem____SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< OpenBabel::OBMol >::difference_type i, std::vector< OpenBabel::OBMol >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< OpenBabel::OBMol >::difference_type i, std::vector< OpenBabel::OBMol >::difference_type j, std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBMol_Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.insert

  call-seq:
    insert(pos, argc, ?) -> VectorMol
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.unshift

  call-seq:
    unshift(argc, ?) -> VectorMol

Add one or more elements at the beginning of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)std_vector_Sl_OpenBabel_OBMol_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorMol__SWIG_0(int argc, VALUE *argv, VALUE self) { std::vector< OpenBabel::OBMol > *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::OBMol > *)new std::vector< OpenBabel::OBMol >(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorMol__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< OpenBabel::OBMol > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< OpenBabel::OBMol > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *ptr = (std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const &","std::vector<(OpenBabel::OBMol)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol > const &","std::vector<(OpenBabel::OBMol)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::OBMol > *)new std::vector< OpenBabel::OBMol >((std::vector< OpenBabel::OBMol > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.empty

  call-seq:
    empty -> bool

Check if the VectorMol is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorMol_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (bool)((std::vector< OpenBabel::OBMol > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.size

  call-seq:
    size -> size_type

Size or Length of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->size(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.clear

  call-seq:
    clear

Clear VectorMol contents.
*/
SWIGINTERN VALUE _wrap_VectorMol_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; std::vector< OpenBabel::OBMol > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< OpenBabel::OBMol > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBMol >::allocator_type(static_cast< const std::vector< OpenBabel::OBMol >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBMol >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBMol >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBMol >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBMol >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorMol__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ; std::vector< OpenBabel::OBMol > *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","std::vector<(OpenBabel::OBMol)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val1);
  result = (std::vector< OpenBabel::OBMol > *)new std::vector< OpenBabel::OBMol >(arg1); DATA_PTR(self) = result; return self;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< OpenBabel::OBMol >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBMol >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::iterator arg2 ; std::vector< OpenBabel::OBMol >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::OBMol >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBMol >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VectorMol_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorMol_erase__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VectorMol.erase", 
  "    std::vector< OpenBabel::OBMol >::iterator VectorMol.erase(std::vector< OpenBabel::OBMol >::iterator pos)\n"
  "    std::vector< OpenBabel::OBMol >::iterator VectorMol.erase(std::vector< OpenBabel::OBMol >::iterator first, std::vector< OpenBabel::OBMol >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorMol_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorMol_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorMol__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol >::size_type arg1 ; std::vector< OpenBabel::OBMol >::value_type *arg2 = 0 ; size_t val1 ;
  int ecode1 = 0 ; void *argp2 ; int res2 = 0 ; std::vector< OpenBabel::OBMol > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","std::vector<(OpenBabel::OBMol)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","std::vector<(OpenBabel::OBMol)>", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","std::vector<(OpenBabel::OBMol)>", 2, argv[1])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp2);
  result = (std::vector< OpenBabel::OBMol > *)new std::vector< OpenBabel::OBMol >(arg1,(std::vector< OpenBabel::OBMol >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorMol(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorMol__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorMol__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorMol__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorMol__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorMol.new", 
  "    VectorMol.new()\n" "    VectorMol.new(std::vector< OpenBabel::OBMol > const &)\n"
  "    VectorMol.new(std::vector< OpenBabel::OBMol >::size_type size)\n"
  "    VectorMol.new(std::vector< OpenBabel::OBMol >::size_type size, std::vector< OpenBabel::OBMol >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.front

  call-seq:
    front -> value_type

Return the first element in VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol >::value_type *) &((std::vector< OpenBabel::OBMol > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.back

  call-seq:
    back -> value_type

Return the last element in VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = (std::vector< OpenBabel::OBMol >::value_type *) &((std::vector< OpenBabel::OBMol > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.assign

  call-seq:
    assign(n, x)

Assign a new VectorMol or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorMol_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::size_type arg2 ; std::vector< OpenBabel::OBMol >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","assign", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","assign", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< OpenBabel::OBMol >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::size_type arg2 ; std::vector< OpenBabel::OBMol >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","resize", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","resize", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< OpenBabel::OBMol >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VectorMol_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorMol_resize__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VectorMol.resize", 
  "    void VectorMol.resize(std::vector< OpenBabel::OBMol >::size_type new_size)\n"
  "    void VectorMol.resize(std::vector< OpenBabel::OBMol >::size_type new_size, std::vector< OpenBabel::OBMol >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.insert

  call-seq:
    insert(pos, argc, ?) -> VectorMol
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::iterator arg2 ; std::vector< OpenBabel::OBMol >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 ; int res3 = 0 ;
  std::vector< OpenBabel::OBMol >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","insert", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","insert", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< OpenBabel::OBMol >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBMol >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::iterator arg2 ; std::vector< OpenBabel::OBMol >::size_type arg3 ;
  std::vector< OpenBabel::OBMol >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::value_type const &","insert", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBMol >::value_type const &","insert", 4, argv[2])); }
   arg4 = reinterpret_cast< std::vector< OpenBabel::OBMol >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< OpenBabel::OBMol >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorMol_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBMol >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VectorMol_insert__SWIG_1(nargs, args, self);}  check_1:
  if (argc >= 3) { return _wrap_VectorMol_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorMol_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::OBMol >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::OBMol >::iterator pos, std::vector< OpenBabel::OBMol >::value_type const &x)\n"
  "    void insert(std::vector< OpenBabel::OBMol >::iterator pos, std::vector< OpenBabel::OBMol >::size_type n, std::vector< OpenBabel::OBMol >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorMol for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorMol_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ;
  std::vector< OpenBabel::OBMol >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBMol >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorMol.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorMol.
*/
SWIGINTERN VALUE _wrap_VectorMol_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBMol > *arg1 = (std::vector< OpenBabel::OBMol > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBMol > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBMol > * >(argp1);
  result = ((std::vector< OpenBabel::OBMol > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBMol_Sg_(std::vector< OpenBabel::OBMol > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorBond;


/*
  Document-method: OpenBabel::VectorBond.dup

  call-seq:
    dup -> VectorBond

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorBond_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorBond_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.to_a

  call-seq:
    to_a -> VALUE

Convert VectorBond to an Array.
*/
SWIGINTERN VALUE _wrap_VectorBond_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorBond_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; std::vector< OpenBabel::OBBond >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.each

  call-seq:
    each -> VectorBond

Iterate thru each element in the VectorBond.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorBond_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.select

  call-seq:
    select -> VectorBond

Iterate thru each element in the VectorBond and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorBond_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.reject_bang

  call-seq:
    reject_bang -> VectorBond

Iterate thru each element in the VectorBond and reject those that fail a condition.  A block must be provided.  VectorBond is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorBond_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorBond_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","__delete2__", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","__delete2__", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg____delete2__(arg1,(OpenBabel::OBBond const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","pop", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__pop(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_push(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  std::vector< OpenBabel::OBBond >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","push", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","push", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","push", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp2);
  result = std_vector_Sl_OpenBabel_OBBond_Sg__push(arg1,(OpenBabel::OBBond const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBBond >::value_type(static_cast< const std::vector< OpenBabel::OBBond >::value_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.reject

  call-seq:
    reject -> VectorBond

Iterate thru each element in the VectorBond and reject those that fail a condition returning a new VectorBond.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorBond_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorBond_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__at((std::vector< OpenBabel::OBBond > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorBond___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; std::vector< OpenBabel::OBBond >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg____getitem____SWIG_0((std::vector< OpenBabel::OBBond > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg____getitem____SWIG_1((std::vector< OpenBabel::OBBond > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg____getitem____SWIG_2((std::vector< OpenBabel::OBBond > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorBond___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorBond___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorBond___getitem____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< OpenBabel::OBBond >::difference_type i, std::vector< OpenBabel::OBBond >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< OpenBabel::OBBond >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorBond___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; std::vector< OpenBabel::OBBond >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","__setitem__", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","__setitem__", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg____setitem____SWIG_0(arg1,arg2,(OpenBabel::OBBond const &)*arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; std::vector< OpenBabel::OBBond >::difference_type arg3 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val3); {
    std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *ptr = (std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorBond___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorBond___setitem____SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< OpenBabel::OBBond >::difference_type i, std::vector< OpenBabel::OBBond >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< OpenBabel::OBBond >::difference_type i, std::vector< OpenBabel::OBBond >::difference_type j, std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBBond_Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.insert

  call-seq:
    insert(pos, argc, ?) -> VectorBond
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.unshift

  call-seq:
    unshift(argc, ?) -> VectorBond

Add one or more elements at the beginning of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)std_vector_Sl_OpenBabel_OBBond_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorBond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::OBBond > *)new std::vector< OpenBabel::OBBond >(); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorBond__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< OpenBabel::OBBond > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< OpenBabel::OBBond > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *ptr = (std::vector<OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const &","std::vector<(OpenBabel::OBBond)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond > const &","std::vector<(OpenBabel::OBBond)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::OBBond > *)new std::vector< OpenBabel::OBBond >((std::vector< OpenBabel::OBBond > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.empty

  call-seq:
    empty -> bool

Check if the VectorBond is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorBond_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (bool)((std::vector< OpenBabel::OBBond > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.size

  call-seq:
    size -> size_type

Size or Length of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->size(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.clear

  call-seq:
    clear

Clear VectorBond contents.
*/
SWIGINTERN VALUE _wrap_VectorBond_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; std::vector< OpenBabel::OBBond > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< OpenBabel::OBBond > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBBond >::allocator_type(static_cast< const std::vector< OpenBabel::OBBond >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBBond >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBBond >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBBond >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBBond >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorBond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< OpenBabel::OBBond > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","std::vector<(OpenBabel::OBBond)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val1);
  result = (std::vector< OpenBabel::OBBond > *)new std::vector< OpenBabel::OBBond >(arg1); DATA_PTR(self) = result; return self;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< OpenBabel::OBBond >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBBond >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::iterator arg2 ; std::vector< OpenBabel::OBBond >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::OBBond >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBBond >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VectorBond_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorBond_erase__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VectorBond.erase", 
  "    std::vector< OpenBabel::OBBond >::iterator VectorBond.erase(std::vector< OpenBabel::OBBond >::iterator pos)\n"
  "    std::vector< OpenBabel::OBBond >::iterator VectorBond.erase(std::vector< OpenBabel::OBBond >::iterator first, std::vector< OpenBabel::OBBond >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorBond_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorBond__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond >::size_type arg1 ; std::vector< OpenBabel::OBBond >::value_type *arg2 = 0 ; size_t val1 ;
  int ecode1 = 0 ; void *argp2 ; int res2 = 0 ; std::vector< OpenBabel::OBBond > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","std::vector<(OpenBabel::OBBond)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","std::vector<(OpenBabel::OBBond)>", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","std::vector<(OpenBabel::OBBond)>", 2, argv[1])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp2);
  result = (std::vector< OpenBabel::OBBond > *)new std::vector< OpenBabel::OBBond >(arg1,(std::vector< OpenBabel::OBBond >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorBond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorBond__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorBond__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorBond__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorBond__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorBond.new", 
  "    VectorBond.new()\n" "    VectorBond.new(std::vector< OpenBabel::OBBond > const &)\n"
  "    VectorBond.new(std::vector< OpenBabel::OBBond >::size_type size)\n"
  "    VectorBond.new(std::vector< OpenBabel::OBBond >::size_type size, std::vector< OpenBabel::OBBond >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.front

  call-seq:
    front -> value_type

Return the first element in VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond >::value_type *) &((std::vector< OpenBabel::OBBond > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.back

  call-seq:
    back -> value_type

Return the last element in VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = (std::vector< OpenBabel::OBBond >::value_type *) &((std::vector< OpenBabel::OBBond > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.assign

  call-seq:
    assign(n, x)

Assign a new VectorBond or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorBond_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::size_type arg2 ; std::vector< OpenBabel::OBBond >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","assign", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","assign", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< OpenBabel::OBBond >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::size_type arg2 ; std::vector< OpenBabel::OBBond >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","resize", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","resize", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< OpenBabel::OBBond >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorBond_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorBond_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorBond.resize", 
  "    void VectorBond.resize(std::vector< OpenBabel::OBBond >::size_type new_size)\n"
  "    void VectorBond.resize(std::vector< OpenBabel::OBBond >::size_type new_size, std::vector< OpenBabel::OBBond >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.insert

  call-seq:
    insert(pos, argc, ?) -> VectorBond
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::iterator arg2 ; std::vector< OpenBabel::OBBond >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 ; int res3 = 0 ;
  std::vector< OpenBabel::OBBond >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","insert", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","insert", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< OpenBabel::OBBond >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBBond >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::iterator arg2 ; std::vector< OpenBabel::OBBond >::size_type arg3 ;
  std::vector< OpenBabel::OBBond >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::value_type const &","insert", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBBond >::value_type const &","insert", 4, argv[2])); }
   arg4 = reinterpret_cast< std::vector< OpenBabel::OBBond >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< OpenBabel::OBBond >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorBond_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBBond >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VectorBond_insert__SWIG_1(nargs, args, self);}  check_1:
  if (argc >= 3) { return _wrap_VectorBond_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorBond_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::OBBond >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::OBBond >::iterator pos, std::vector< OpenBabel::OBBond >::value_type const &x)\n"
  "    void insert(std::vector< OpenBabel::OBBond >::iterator pos, std::vector< OpenBabel::OBBond >::size_type n, std::vector< OpenBabel::OBBond >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorBond for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorBond_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ;
  std::vector< OpenBabel::OBBond >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBBond >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorBond.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorBond.
*/
SWIGINTERN VALUE _wrap_VectorBond_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBBond > *arg1 = (std::vector< OpenBabel::OBBond > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBBond >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBBond > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBBond > * >(argp1);
  result = ((std::vector< OpenBabel::OBBond > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBBond_Sg_(std::vector< OpenBabel::OBBond > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorResidue;


/*
  Document-method: OpenBabel::VectorResidue.dup

  call-seq:
    dup -> VectorResidue

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorResidue_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorResidue_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.to_a

  call-seq:
    to_a -> VALUE

Convert VectorResidue to an Array.
*/
SWIGINTERN VALUE _wrap_VectorResidue_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorResidue_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; std::vector< OpenBabel::OBResidue >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.each

  call-seq:
    each -> VectorResidue

Iterate thru each element in the VectorResidue.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorResidue_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.select

  call-seq:
    select -> VectorResidue

Iterate thru each element in the VectorResidue and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorResidue_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.reject_bang

  call-seq:
    reject_bang -> VectorResidue

Iterate thru each element in the VectorResidue and reject those that fail a condition.  A block must be provided.  VectorResidue is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorResidue_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorResidue_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","__delete2__", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","__delete2__", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg____delete2__(arg1,(OpenBabel::OBResidue const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","pop", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__pop(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_push(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  std::vector< OpenBabel::OBResidue >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","push", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","push", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","push", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp2);
  result = std_vector_Sl_OpenBabel_OBResidue_Sg__push(arg1,(OpenBabel::OBResidue const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBResidue >::value_type(static_cast< const std::vector< OpenBabel::OBResidue >::value_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.reject

  call-seq:
    reject -> VectorResidue

Iterate thru each element in the VectorResidue and reject those that fail a condition returning a new VectorResidue.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorResidue_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorResidue_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__at((std::vector< OpenBabel::OBResidue > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorResidue___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; std::vector< OpenBabel::OBResidue >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg____getitem____SWIG_0((std::vector< OpenBabel::OBResidue > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg____getitem____SWIG_1((std::vector< OpenBabel::OBResidue > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; VALUE arg2 = (VALUE) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg____getitem____SWIG_2((std::vector< OpenBabel::OBResidue > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorResidue___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorResidue___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorResidue___getitem____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< OpenBabel::OBResidue >::difference_type i, std::vector< OpenBabel::OBResidue >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< OpenBabel::OBResidue >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorResidue___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; std::vector< OpenBabel::OBResidue >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","__setitem__", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","__setitem__", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg____setitem____SWIG_0(arg1,arg2,(OpenBabel::OBResidue const &)*arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; std::vector< OpenBabel::OBResidue >::difference_type arg3 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val3); {
    std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *ptr = (std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorResidue___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorResidue___setitem____SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< OpenBabel::OBResidue >::difference_type i, std::vector< OpenBabel::OBResidue >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< OpenBabel::OBResidue >::difference_type i, std::vector< OpenBabel::OBResidue >::difference_type j, std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBResidue_Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.insert

  call-seq:
    insert(pos, argc, ?) -> VectorResidue
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.unshift

  call-seq:
    unshift(argc, ?) -> VectorResidue

Add one or more elements at the beginning of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)std_vector_Sl_OpenBabel_OBResidue_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorResidue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::OBResidue > *)new std::vector< OpenBabel::OBResidue >(); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorResidue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = 0 ; int res1 = SWIG_OLDOBJ ; std::vector< OpenBabel::OBResidue > *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *ptr = (std::vector<OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const &","std::vector<(OpenBabel::OBResidue)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue > const &","std::vector<(OpenBabel::OBResidue)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::OBResidue > *)new std::vector< OpenBabel::OBResidue >((std::vector< OpenBabel::OBResidue > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.empty

  call-seq:
    empty -> bool

Check if the VectorResidue is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorResidue_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (bool)((std::vector< OpenBabel::OBResidue > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.size

  call-seq:
    size -> size_type

Size or Length of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.clear

  call-seq:
    clear

Clear VectorResidue contents.
*/
SWIGINTERN VALUE _wrap_VectorResidue_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< OpenBabel::OBResidue > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBResidue >::allocator_type(static_cast< const std::vector< OpenBabel::OBResidue >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorResidue__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< OpenBabel::OBResidue > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","std::vector<(OpenBabel::OBResidue)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val1);
  result = (std::vector< OpenBabel::OBResidue > *)new std::vector< OpenBabel::OBResidue >(arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< OpenBabel::OBResidue >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::iterator arg2 ; std::vector< OpenBabel::OBResidue >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::OBResidue >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorResidue_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorResidue_erase__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorResidue.erase", 
  "    std::vector< OpenBabel::OBResidue >::iterator VectorResidue.erase(std::vector< OpenBabel::OBResidue >::iterator pos)\n"
  "    std::vector< OpenBabel::OBResidue >::iterator VectorResidue.erase(std::vector< OpenBabel::OBResidue >::iterator first, std::vector< OpenBabel::OBResidue >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorResidue_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorResidue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorResidue__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue >::size_type arg1 ; std::vector< OpenBabel::OBResidue >::value_type *arg2 = 0 ;
  size_t val1 ; int ecode1 = 0 ; void *argp2 ; int res2 = 0 ; std::vector< OpenBabel::OBResidue > *result = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","std::vector<(OpenBabel::OBResidue)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","std::vector<(OpenBabel::OBResidue)>", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","std::vector<(OpenBabel::OBResidue)>", 2, argv[1])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp2);
  result = (std::vector< OpenBabel::OBResidue > *)new std::vector< OpenBabel::OBResidue >(arg1,(std::vector< OpenBabel::OBResidue >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorResidue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorResidue__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorResidue__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorResidue__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorResidue__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "VectorResidue.new",  "    VectorResidue.new()\n"
  "    VectorResidue.new(std::vector< OpenBabel::OBResidue > const &)\n"
  "    VectorResidue.new(std::vector< OpenBabel::OBResidue >::size_type size)\n"
  "    VectorResidue.new(std::vector< OpenBabel::OBResidue >::size_type size, std::vector< OpenBabel::OBResidue >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.front

  call-seq:
    front -> value_type

Return the first element in VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue >::value_type *) &((std::vector< OpenBabel::OBResidue > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.back

  call-seq:
    back -> value_type

Return the last element in VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = (std::vector< OpenBabel::OBResidue >::value_type *) &((std::vector< OpenBabel::OBResidue > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.assign

  call-seq:
    assign(n, x)

Assign a new VectorResidue or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorResidue_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::size_type arg2 ; std::vector< OpenBabel::OBResidue >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","assign", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","assign", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< OpenBabel::OBResidue >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::size_type arg2 ; std::vector< OpenBabel::OBResidue >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","resize", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","resize", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< OpenBabel::OBResidue >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorResidue_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorResidue_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorResidue.resize", 
  "    void VectorResidue.resize(std::vector< OpenBabel::OBResidue >::size_type new_size)\n"
  "    void VectorResidue.resize(std::vector< OpenBabel::OBResidue >::size_type new_size, std::vector< OpenBabel::OBResidue >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.insert

  call-seq:
    insert(pos, argc, ?) -> VectorResidue
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::iterator arg2 ; std::vector< OpenBabel::OBResidue >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 ; int res3 = 0 ;
  std::vector< OpenBabel::OBResidue >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","insert", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","insert", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< OpenBabel::OBResidue >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBResidue >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::iterator arg2 ; std::vector< OpenBabel::OBResidue >::size_type arg3 ;
  std::vector< OpenBabel::OBResidue >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::value_type const &","insert", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBResidue >::value_type const &","insert", 4, argv[2])); }
   arg4 = reinterpret_cast< std::vector< OpenBabel::OBResidue >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< OpenBabel::OBResidue >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorResidue_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBResidue >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VectorResidue_insert__SWIG_1(nargs, args, self);} 
  check_1: if (argc >= 3) { return _wrap_VectorResidue_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorResidue_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::OBResidue >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::OBResidue >::iterator pos, std::vector< OpenBabel::OBResidue >::value_type const &x)\n"
  "    void insert(std::vector< OpenBabel::OBResidue >::iterator pos, std::vector< OpenBabel::OBResidue >::size_type n, std::vector< OpenBabel::OBResidue >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorResidue for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorResidue_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ;
  std::vector< OpenBabel::OBResidue >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBResidue >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorResidue.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorResidue.
*/
SWIGINTERN VALUE _wrap_VectorResidue_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBResidue > *arg1 = (std::vector< OpenBabel::OBResidue > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBResidue >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBResidue > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBResidue > * >(argp1);
  result = ((std::vector< OpenBabel::OBResidue > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBResidue_Sg_(std::vector< OpenBabel::OBResidue > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorRing;


/*
  Document-method: OpenBabel::VectorRing.dup

  call-seq:
    dup -> VectorRing

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorRing_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorRing_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.to_a

  call-seq:
    to_a -> VALUE

Convert VectorRing to an Array.
*/
SWIGINTERN VALUE _wrap_VectorRing_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorRing_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; std::vector< OpenBabel::OBRing >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.each

  call-seq:
    each -> VectorRing

Iterate thru each element in the VectorRing.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorRing_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.select

  call-seq:
    select -> VectorRing

Iterate thru each element in the VectorRing and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorRing_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.reject_bang

  call-seq:
    reject_bang -> VectorRing

Iterate thru each element in the VectorRing and reject those that fail a condition.  A block must be provided.  VectorRing is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorRing_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorRing_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","__delete2__", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","__delete2__", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg____delete2__(arg1,(OpenBabel::OBRing const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.pop

  call-seq:
    pop -> VALUE

Remove and return element at the end of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_pop(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","pop", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__pop(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.push

  call-seq:
    push(e) -> value_type

Add an element at the end of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_push(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  std::vector< OpenBabel::OBRing >::value_type result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","push", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","push", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","push", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp2);
  result = std_vector_Sl_OpenBabel_OBRing_Sg__push(arg1,(OpenBabel::OBRing const &)*arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBRing >::value_type(static_cast< const std::vector< OpenBabel::OBRing >::value_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.reject

  call-seq:
    reject -> VectorRing

Iterate thru each element in the VectorRing and reject those that fail a condition returning a new VectorRing.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorRing_reject(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","reject", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__reject(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.at

  call-seq:
    at(i) -> VALUE

Return element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorRing_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__at((std::vector< OpenBabel::OBRing > const *)arg1,arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.[]

  call-seq:
    [](i, j) -> VALUE
    [](i) -> VALUE
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorRing___getitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; std::vector< OpenBabel::OBRing >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","__getitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg____getitem____SWIG_0((std::vector< OpenBabel::OBRing > const *)arg1,arg2,arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing___getitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg____getitem____SWIG_1((std::vector< OpenBabel::OBRing > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing___getitem____SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; VALUE arg2 = (VALUE) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); arg2 = argv[0];
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg____getitem____SWIG_2((std::vector< OpenBabel::OBRing > const *)arg1,arg2);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing___getitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_VectorRing___getitem____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_VectorRing___getitem____SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorRing___getitem____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "__getitem__", 
  "    VALUE __getitem__(std::vector< OpenBabel::OBRing >::difference_type i, std::vector< OpenBabel::OBRing >::difference_type j)\n"
  "    VALUE __getitem__(std::vector< OpenBabel::OBRing >::difference_type i)\n" "    VALUE __getitem__(VALUE i)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.[]=

  call-seq:
    []=(i, x) -> VALUE
    []=(i, j, v) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorRing___setitem____SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; std::vector< OpenBabel::OBRing >::value_type *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","__setitem__", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","__setitem__", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg____setitem____SWIG_0(arg1,arg2,(OpenBabel::OBRing const &)*arg3);
  vresult = result; return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing___setitem____SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; std::vector< OpenBabel::OBRing >::difference_type arg3 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; int res4 = SWIG_OLDOBJ ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","__setitem__", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val3); {
    std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *ptr = (std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > const &","__setitem__", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > const &","__setitem__", 4, argv[2])); }
     arg4 = ptr; }  try {
    result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg____setitem____SWIG_1(arg1,arg2,arg3,(std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > const &)*arg4);}
   catch(std::invalid_argument &_e) { SWIG_exception_fail(SWIG_ValueError, (&_e)->what()); }  vresult = result;
  if (SWIG_IsNewObj(res4)) delete arg4; return vresult; fail: if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing___setitem__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_VectorRing___setitem____SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorRing___setitem____SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "__setitem__", 
  "    VALUE __setitem__(std::vector< OpenBabel::OBRing >::difference_type i, std::vector< OpenBabel::OBRing >::value_type const &x)\n"
  "    VALUE __setitem__(std::vector< OpenBabel::OBRing >::difference_type i, std::vector< OpenBabel::OBRing >::difference_type j, std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > const &v)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.insert

  call-seq:
    insert(pos, argc, ?) -> VectorRing
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.unshift

  call-seq:
    unshift(argc, ?) -> VectorRing

Add one or more elements at the beginning of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)std_vector_Sl_OpenBabel_OBRing_Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorRing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::OBRing > *)new std::vector< OpenBabel::OBRing >(); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorRing__SWIG_1(int argc, VALUE *argv, VALUE self) { std::vector< OpenBabel::OBRing > *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; std::vector< OpenBabel::OBRing > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *ptr = (std::vector<OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const &","std::vector<(OpenBabel::OBRing)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing > const &","std::vector<(OpenBabel::OBRing)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::OBRing > *)new std::vector< OpenBabel::OBRing >((std::vector< OpenBabel::OBRing > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.empty

  call-seq:
    empty -> bool

Check if the VectorRing is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorRing_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (bool)((std::vector< OpenBabel::OBRing > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.size

  call-seq:
    size -> size_type

Size or Length of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->size(); vresult = SWIG_From_size_t(static_cast< size_t >(result));
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.clear

  call-seq:
    clear

Clear VectorRing contents.
*/
SWIGINTERN VALUE _wrap_VectorRing_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; std::vector< OpenBabel::OBRing > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< OpenBabel::OBRing > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBRing >::allocator_type(static_cast< const std::vector< OpenBabel::OBRing >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< OpenBabel::OBRing > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","std::vector<(OpenBabel::OBRing)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val1);
  result = (std::vector< OpenBabel::OBRing > *)new std::vector< OpenBabel::OBRing >(arg1); DATA_PTR(self) = result; return self;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< OpenBabel::OBRing >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::iterator arg2 ; std::vector< OpenBabel::OBRing >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::OBRing >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_VectorRing_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorRing_erase__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "VectorRing.erase", 
  "    std::vector< OpenBabel::OBRing >::iterator VectorRing.erase(std::vector< OpenBabel::OBRing >::iterator pos)\n"
  "    std::vector< OpenBabel::OBRing >::iterator VectorRing.erase(std::vector< OpenBabel::OBRing >::iterator first, std::vector< OpenBabel::OBRing >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorRing_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorRing__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing >::size_type arg1 ; std::vector< OpenBabel::OBRing >::value_type *arg2 = 0 ; size_t val1 ;
  int ecode1 = 0 ; void *argp2 ; int res2 = 0 ; std::vector< OpenBabel::OBRing > *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","std::vector<(OpenBabel::OBRing)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","std::vector<(OpenBabel::OBRing)>", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","std::vector<(OpenBabel::OBRing)>", 2, argv[1])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp2);
  result = (std::vector< OpenBabel::OBRing > *)new std::vector< OpenBabel::OBRing >(arg1,(std::vector< OpenBabel::OBRing >::value_type const &)*arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorRing(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorRing__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorRing__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorRing__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorRing__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorRing.new", 
  "    VectorRing.new()\n" "    VectorRing.new(std::vector< OpenBabel::OBRing > const &)\n"
  "    VectorRing.new(std::vector< OpenBabel::OBRing >::size_type size)\n"
  "    VectorRing.new(std::vector< OpenBabel::OBRing >::size_type size, std::vector< OpenBabel::OBRing >::value_type const &value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.front

  call-seq:
    front -> value_type

Return the first element in VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing >::value_type *) &((std::vector< OpenBabel::OBRing > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.back

  call-seq:
    back -> value_type

Return the last element in VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::value_type *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = (std::vector< OpenBabel::OBRing >::value_type *) &((std::vector< OpenBabel::OBRing > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.assign

  call-seq:
    assign(n, x)

Assign a new VectorRing or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorRing_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::size_type arg2 ; std::vector< OpenBabel::OBRing >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","assign", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","assign", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp3);
  (arg1)->assign(arg2,(std::vector< OpenBabel::OBRing >::value_type const &)*arg3); return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::size_type arg2 ; std::vector< OpenBabel::OBRing >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","resize", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","resize", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp3);
  (arg1)->resize(arg2,(std::vector< OpenBabel::OBRing >::value_type const &)*arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorRing_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorRing_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorRing.resize", 
  "    void VectorRing.resize(std::vector< OpenBabel::OBRing >::size_type new_size)\n"
  "    void VectorRing.resize(std::vector< OpenBabel::OBRing >::size_type new_size, std::vector< OpenBabel::OBRing >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.insert

  call-seq:
    insert(pos, argc, ?) -> VectorRing
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::iterator arg2 ; std::vector< OpenBabel::OBRing >::value_type *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 ; int res3 = 0 ;
  std::vector< OpenBabel::OBRing >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","insert", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","insert", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp3);
  result = (arg1)->insert(arg2,(std::vector< OpenBabel::OBRing >::value_type const &)*arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::iterator arg2 ; std::vector< OpenBabel::OBRing >::size_type arg3 ;
  std::vector< OpenBabel::OBRing >::value_type *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::value_type const &","insert", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing >::value_type const &","insert", 4, argv[2])); }
   arg4 = reinterpret_cast< std::vector< OpenBabel::OBRing >::value_type * >(argp4);
  (arg1)->insert(arg2,arg3,(std::vector< OpenBabel::OBRing >::value_type const &)*arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorRing_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VectorRing_insert__SWIG_1(nargs, args, self);}  check_1:
  if (argc >= 3) { return _wrap_VectorRing_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorRing_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::OBRing >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::OBRing >::iterator pos, std::vector< OpenBabel::OBRing >::value_type const &x)\n"
  "    void insert(std::vector< OpenBabel::OBRing >::iterator pos, std::vector< OpenBabel::OBRing >::size_type n, std::vector< OpenBabel::OBRing >::value_type const &x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorRing for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorRing_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ;
  std::vector< OpenBabel::OBRing >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorRing.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorRing.
*/
SWIGINTERN VALUE _wrap_VectorRing_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing > *arg1 = (std::vector< OpenBabel::OBRing > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBRing_Sg_(std::vector< OpenBabel::OBRing > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorpRing;


/*
  Document-method: OpenBabel::VectorpRing.dup

  call-seq:
    dup -> VectorpRing

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorpRing_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorpRing_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__inspect(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.to_a

  call-seq:
    to_a -> VALUE

Convert VectorpRing to an Array.
*/
SWIGINTERN VALUE _wrap_VectorpRing_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__to_a(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorpRing_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__to_s(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::difference_type arg2 ; std::vector< OpenBabel::OBRing * >::difference_type arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBRing * >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.each

  call-seq:
    each -> VectorpRing

Iterate thru each element in the VectorpRing.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorpRing_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.select

  call-seq:
    select -> VectorpRing

Iterate thru each element in the VectorpRing and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorpRing_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.reject_bang

  call-seq:
    reject_bang -> VectorpRing

Iterate thru each element in the VectorpRing and reject those that fail a condition.  A block must be provided.  VectorpRing is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorpRing_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorpRing_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  std::vector< OpenBabel::OBRing * >::value_type temp2 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","__delete2__", 2, argv[0] ));  }
   temp2 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg____delete2__(arg1,(OpenBabel::OBRing *const &)*arg2); vresult = result;
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.[]

  call-seq:
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorpRing___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg____getitem__(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.[]=

  call-seq:
    []=(i, x) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorpRing___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::difference_type arg2 ;
  std::vector< OpenBabel::OBRing * >::value_type arg3 = (std::vector< OpenBabel::OBRing * >::value_type) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","__setitem__", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg____setitem__(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__shift(arg1); vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.insert

  call-seq:
    insert(pos, argc, ?) -> VectorpRing
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil; if (argc < 2) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; } 
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.unshift

  call-seq:
    unshift(argc, ?) -> VectorpRing

Add one or more elements at the beginning of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; int arg2 ; VALUE *arg3 = (VALUE *) 0 ;
  void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil; if (argc < 1) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *)std_vector_Sl_OpenBabel_OBRing_Sm__Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorpRing__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::OBRing * > *)new std::vector< OpenBabel::OBRing * >(); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorpRing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = 0 ; int res1 = SWIG_OLDOBJ ; std::vector< OpenBabel::OBRing * > *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > > *ptr = (std::vector<OpenBabel::OBRing*,std::allocator< OpenBabel::OBRing * > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const &","std::vector<(p.OpenBabel::OBRing)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing * > const &","std::vector<(p.OpenBabel::OBRing)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::OBRing * > *)new std::vector< OpenBabel::OBRing * >((std::vector< OpenBabel::OBRing * > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.empty

  call-seq:
    empty -> bool

Check if the VectorpRing is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorpRing_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (bool)((std::vector< OpenBabel::OBRing * > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.size

  call-seq:
    size -> size_type

Size or Length of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.clear

  call-seq:
    clear

Clear VectorpRing contents.
*/
SWIGINTERN VALUE _wrap_VectorpRing_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing * > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::allocator< OpenBabel::OBRing * > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBRing * >::allocator_type(static_cast< const std::vector< OpenBabel::OBRing * >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::const_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::const_reverse_iterator result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorpRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< OpenBabel::OBRing * > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","std::vector<(p.OpenBabel::OBRing)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val1);
  result = (std::vector< OpenBabel::OBRing * > *)new std::vector< OpenBabel::OBRing * >(arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ;
  std::vector< OpenBabel::OBRing * >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::iterator arg2 ; std::vector< OpenBabel::OBRing * >::iterator arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::OBRing * >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorpRing_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorpRing_erase__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorpRing.erase", 
  "    std::vector< OpenBabel::OBRing * >::iterator VectorpRing.erase(std::vector< OpenBabel::OBRing * >::iterator pos)\n"
  "    std::vector< OpenBabel::OBRing * >::iterator VectorpRing.erase(std::vector< OpenBabel::OBRing * >::iterator first, std::vector< OpenBabel::OBRing * >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorpRing_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorpRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorpRing__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * >::size_type arg1 ;
  std::vector< OpenBabel::OBRing * >::value_type arg2 = (std::vector< OpenBabel::OBRing * >::value_type) 0 ; size_t val1 ;
  int ecode1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; std::vector< OpenBabel::OBRing * > *result = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","std::vector<(p.OpenBabel::OBRing)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","std::vector<(p.OpenBabel::OBRing)>", 2, argv[1] ));  }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp2);
  result = (std::vector< OpenBabel::OBRing * > *)new std::vector< OpenBabel::OBRing * >(arg1,arg2); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorpRing(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorpRing__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorpRing__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorpRing__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorpRing__SWIG_3(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "VectorpRing.new", 
  "    VectorpRing.new()\n" "    VectorpRing.new(std::vector< OpenBabel::OBRing * > const &)\n"
  "    VectorpRing.new(std::vector< OpenBabel::OBRing * >::size_type size)\n"
  "    VectorpRing.new(std::vector< OpenBabel::OBRing * >::size_type size, std::vector< OpenBabel::OBRing * >::value_type value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.front

  call-seq:
    front -> value_type

Return the first element in VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::value_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (std::vector< OpenBabel::OBRing * >::value_type)((std::vector< OpenBabel::OBRing * > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.back

  call-seq:
    back -> value_type

Return the last element in VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::value_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = (std::vector< OpenBabel::OBRing * >::value_type)((std::vector< OpenBabel::OBRing * > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.assign

  call-seq:
    assign(n, x)

Assign a new VectorpRing or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorpRing_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::size_type arg2 ;
  std::vector< OpenBabel::OBRing * >::value_type arg3 = (std::vector< OpenBabel::OBRing * >::value_type) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","assign", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp3); (arg1)->assign(arg2,arg3); return Qnil;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::size_type arg2 ;
  std::vector< OpenBabel::OBRing * >::value_type arg3 = (std::vector< OpenBabel::OBRing * >::value_type) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","resize", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp3); (arg1)->resize(arg2,arg3); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorpRing_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorpRing_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorpRing.resize", 
  "    void VectorpRing.resize(std::vector< OpenBabel::OBRing * >::size_type new_size)\n"
  "    void VectorpRing.resize(std::vector< OpenBabel::OBRing * >::size_type new_size, std::vector< OpenBabel::OBRing * >::value_type x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.insert

  call-seq:
    insert(pos, argc, ?) -> VectorpRing
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::iterator arg2 ;
  std::vector< OpenBabel::OBRing * >::value_type arg3 = (std::vector< OpenBabel::OBRing * >::value_type) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 = 0 ; int res3 = 0 ;
  std::vector< OpenBabel::OBRing * >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","insert", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp3); result = (arg1)->insert(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing * >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::iterator arg2 ; std::vector< OpenBabel::OBRing * >::size_type arg3 ;
  std::vector< OpenBabel::OBRing * >::value_type arg4 = (std::vector< OpenBabel::OBRing * >::value_type) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::value_type","insert", 4, argv[2] ));  }
   arg4 = reinterpret_cast< std::vector< OpenBabel::OBRing * >::value_type >(argp4); (arg1)->insert(arg2,arg3,arg4);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorpRing_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBRing * >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VectorpRing_insert__SWIG_1(nargs, args, self);}  check_1:
  if (argc >= 3) { return _wrap_VectorpRing_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorpRing_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::OBRing * >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::OBRing * >::iterator pos, std::vector< OpenBabel::OBRing * >::value_type x)\n"
  "    void insert(std::vector< OpenBabel::OBRing * >::iterator pos, std::vector< OpenBabel::OBRing * >::size_type n, std::vector< OpenBabel::OBRing * >::value_type x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorpRing for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorpRing_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ;
  std::vector< OpenBabel::OBRing * >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBRing * >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorpRing.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorpRing.
*/
SWIGINTERN VALUE _wrap_VectorpRing_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBRing * > *arg1 = (std::vector< OpenBabel::OBRing * > *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing * >::size_type result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing * > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBRing * > * >(argp1);
  result = ((std::vector< OpenBabel::OBRing * > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBRing_Sm__Sg_(std::vector< OpenBabel::OBRing * > *arg1) {
    delete arg1;
}

swig_class SwigClassVectorGenericData;


/*
  Document-method: OpenBabel::VectorGenericData.dup

  call-seq:
    dup -> VectorGenericData

Create a duplicate of the class and unfreeze it if needed.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_dup(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","dup", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__dup(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.inspect

  call-seq:
    inspect -> VALUE

Inspect class and its contents.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_inspect(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","inspect", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__inspect(arg1); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.to_a

  call-seq:
    to_a -> VALUE

Convert VectorGenericData to an Array.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_to_a(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","to_a", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__to_a(arg1); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.to_s

  call-seq:
    to_s -> VALUE

Convert class to a String representation.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_to_s(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","to_s", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__to_s(arg1); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.slice

  call-seq:
    slice(i, j) -> VALUE

Return a slice (portion of) the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_slice(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::difference_type arg2 ;
  std::vector< OpenBabel::OBGenericData * >::difference_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ;
  int ecode2 = 0 ; ptrdiff_t val3 ; int ecode3 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","slice", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::difference_type","slice", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::difference_type >(val2);
  ecode3 = SWIG_AsVal_ptrdiff_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::difference_type","slice", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBGenericData * >::difference_type >(val3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__slice(arg1,arg2,arg3); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.each

  call-seq:
    each -> VectorGenericData

Iterate thru each element in the VectorGenericData.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_each(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","each", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__each(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.select

  call-seq:
    select -> VectorGenericData

Iterate thru each element in the VectorGenericData and select those that match a condition.  A block must be provided.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_select(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","select", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__select(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.reject_bang

  call-seq:
    reject_bang -> VectorGenericData

Iterate thru each element in the VectorGenericData and reject those that fail a condition.  A block must be provided.  VectorGenericData is modified in place.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_reject_bang(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","reject_bang", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__reject_bang(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.delete_at

  call-seq:
    delete_at(i) -> VALUE

Delete an element at a certain index.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_delete_at(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ;
  int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","delete_at", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::difference_type","delete_at", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__delete_at(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData___delete_2__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::value_type *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; std::vector< OpenBabel::OBGenericData * >::value_type temp2 ; VALUE result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","__delete2__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","__delete2__", 2, argv[0] ));  }
   temp2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp2); arg2 = &temp2;
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____delete2__(arg1,(OpenBabel::OBGenericData *const &)*arg2);
  vresult = result; return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.[]

  call-seq:
    [](i) -> VALUE

Element accessor/slicing.
*/
SWIGINTERN VALUE _wrap_VectorGenericData___getitem__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::difference_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ;
  int ecode2 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","__getitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::difference_type","__getitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::difference_type >(val2);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____getitem__(arg1,arg2); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.[]=

  call-seq:
    []=(i, x) -> VALUE

Element setter/slicing.
*/
SWIGINTERN VALUE _wrap_VectorGenericData___setitem__(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::difference_type arg2 ;
  std::vector< OpenBabel::OBGenericData * >::value_type arg3 = (std::vector< OpenBabel::OBGenericData * >::value_type) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; VALUE result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","__setitem__", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::difference_type","__setitem__", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::difference_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","__setitem__", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp3);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg____setitem__(arg1,arg2,arg3); vresult = result; return vresult;
  fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.shift

  call-seq:
    shift -> VALUE

Remove and return element at the beginning of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_shift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; VALUE result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","shift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (VALUE)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__shift(arg1); vresult = result; return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.insert

  call-seq:
    insert(pos, argc, ?) -> VectorGenericData
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_insert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::difference_type arg2 ; int arg3 ; VALUE *arg4 = (VALUE *) 0 ; void *arg5 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; ptrdiff_t val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if (argc < 2) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_ptrdiff_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::difference_type","insert", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::difference_type >(val2); { arg3 = argc - 1; arg4 = argv + 1; }
  
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__insert__SWIG_0(arg1,arg2,arg3,arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.unshift

  call-seq:
    unshift(argc, ?) -> VectorGenericData

Add one or more elements at the beginning of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_unshift(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; int arg2 ;
  VALUE *arg3 = (VALUE *) 0 ; void *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if (argc < 1) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","unshift", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); { arg2 = argc; arg3 = argv; } 
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *)std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg__unshift(arg1,arg2,arg3,arg4);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorGenericData__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (std::vector< OpenBabel::OBGenericData * > *)new std::vector< OpenBabel::OBGenericData * >();
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorGenericData__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = 0 ; int res1 = SWIG_OLDOBJ ;
  std::vector< OpenBabel::OBGenericData * > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  {
    std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > *ptr = (std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const &","std::vector<(p.OpenBabel::OBGenericData)>", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData * > const &","std::vector<(p.OpenBabel::OBGenericData)>", 1, argv[0])); }
     arg1 = ptr; } 
  result = (std::vector< OpenBabel::OBGenericData * > *)new std::vector< OpenBabel::OBGenericData * >((std::vector< OpenBabel::OBGenericData * > const &)*arg1);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.empty

  call-seq:
    empty -> bool

Check if the VectorGenericData is empty or not.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_empty(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","empty", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (bool)((std::vector< OpenBabel::OBGenericData * > const *)arg1)->empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.size

  call-seq:
    size -> size_type

Size or Length of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_size(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::size_type result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","size", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->size();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.clear

  call-seq:
    clear

Clear VectorGenericData contents.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_clear(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","clear", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); (arg1)->clear(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_swap(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","swap", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > &","swap", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData * > &","swap", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp2); (arg1)->swap(*arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_get_allocator(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; SwigValueWrapper< std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","get_allocator", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->get_allocator();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBGenericData * >::allocator_type(static_cast< const std::vector< OpenBabel::OBGenericData * >::allocator_type& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.begin

  call-seq:
    begin -> const_iterator

Return an iterator to the beginning of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_begin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::const_iterator result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","begin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->begin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.end

  call-seq:
    end -> const_iterator

Return an iterator to past the end of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_end(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::const_iterator result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","end", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->end();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::const_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.rbegin

  call-seq:
    rbegin -> const_reverse_iterator

Return a reverse iterator to the beginning (the end) of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_rbegin(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::const_reverse_iterator result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","rbegin", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->rbegin();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.rend

  call-seq:
    rend -> const_reverse_iterator

Return a reverse iterator to past the end (past the beginning) of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_rend(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::const_reverse_iterator result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","rend", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->rend();
  vresult = SWIG_NewPointerObj(swig::make_const_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::const_reverse_iterator & >(result),
  self), swig::ConstIterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorGenericData__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * >::size_type arg1 ; size_t val1 ; int ecode1 = 0 ;
  std::vector< OpenBabel::OBGenericData * > *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_size_t(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","std::vector<(p.OpenBabel::OBGenericData)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val1);
  result = (std::vector< OpenBabel::OBGenericData * > *)new std::vector< OpenBabel::OBGenericData * >(arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_resize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val2); (arg1)->resize(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.erase

  call-seq:
    erase(pos) -> iterator
    erase(first, last) -> iterator

Delete a portion of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_erase__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::iterator arg2 ; void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ;
  int res2 ; std::vector< OpenBabel::OBGenericData * >::iterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","erase", 2, argv[0] )); }
     }  result = (arg1)->erase(arg2);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_erase__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::iterator arg2 ; std::vector< OpenBabel::OBGenericData * >::iterator arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; swig::Iterator *iter3 = 0 ; int res3 ;
  std::vector< OpenBabel::OBGenericData * >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","erase", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","erase", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","erase", 2, argv[0] )); }
     }  res3 = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter3), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res3) || !iter3) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","erase", 3, argv[1] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *>(iter3);
    if (iter_t) { arg3 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","erase", 3, argv[1] )); }
     }  result = (arg1)->erase(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_erase(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorGenericData_erase__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorGenericData_erase__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorGenericData.erase", 
  "    std::vector< OpenBabel::OBGenericData * >::iterator VectorGenericData.erase(std::vector< OpenBabel::OBGenericData * >::iterator pos)\n"
  "    std::vector< OpenBabel::OBGenericData * >::iterator VectorGenericData.erase(std::vector< OpenBabel::OBGenericData * >::iterator first, std::vector< OpenBabel::OBGenericData * >::iterator last)\n");
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_VectorGenericData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_VectorGenericData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_VectorGenericData__SWIG_3(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * >::size_type arg1 ;
  std::vector< OpenBabel::OBGenericData * >::value_type arg2 = (std::vector< OpenBabel::OBGenericData * >::value_type) 0 ;
  size_t val1 ; int ecode1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; std::vector< OpenBabel::OBGenericData * > *result = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_size_t(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","std::vector<(p.OpenBabel::OBGenericData)>", 1, argv[0] )); }
    arg1 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","std::vector<(p.OpenBabel::OBGenericData)>", 2, argv[1] ));  }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp2);
  result = (std::vector< OpenBabel::OBGenericData * > *)new std::vector< OpenBabel::OBGenericData * >(arg1,arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_VectorGenericData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs; if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_VectorGenericData__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { {
        int res = SWIG_AsVal_size_t(argv[0], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_new_VectorGenericData__SWIG_2(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_VectorGenericData__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_VectorGenericData__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "VectorGenericData.new",  "    VectorGenericData.new()\n"
  "    VectorGenericData.new(std::vector< OpenBabel::OBGenericData * > const &)\n"
  "    VectorGenericData.new(std::vector< OpenBabel::OBGenericData * >::size_type size)\n"
  "    VectorGenericData.new(std::vector< OpenBabel::OBGenericData * >::size_type size, std::vector< OpenBabel::OBGenericData * >::value_type value)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.front

  call-seq:
    front -> value_type

Return the first element in VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_front(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::value_type result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","front", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData * >::value_type)((std::vector< OpenBabel::OBGenericData * > const *)arg1)->front();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.back

  call-seq:
    back -> value_type

Return the last element in VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_back(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::value_type result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","back", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData * >::value_type)((std::vector< OpenBabel::OBGenericData * > const *)arg1)->back();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.assign

  call-seq:
    assign(n, x)

Assign a new VectorGenericData or portion of it.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_assign(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::size_type arg2 ;
  std::vector< OpenBabel::OBGenericData * >::value_type arg3 = (std::vector< OpenBabel::OBGenericData * >::value_type) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","assign", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","assign", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","assign", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp3); (arg1)->assign(arg2,arg3);
  return Qnil; fail: return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.resize

  call-seq:
    resize(new_size)
    resize(new_size, x)

Resize the size of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_resize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::size_type arg2 ;
  std::vector< OpenBabel::OBGenericData * >::value_type arg3 = (std::vector< OpenBabel::OBGenericData * >::value_type) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","resize", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","resize", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","resize", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp3); (arg1)->resize(arg2,arg3);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_resize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_VectorGenericData_resize__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_VectorGenericData_resize__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "VectorGenericData.resize", 
  "    void VectorGenericData.resize(std::vector< OpenBabel::OBGenericData * >::size_type new_size)\n"
  "    void VectorGenericData.resize(std::vector< OpenBabel::OBGenericData * >::size_type new_size, std::vector< OpenBabel::OBGenericData * >::value_type x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.insert

  call-seq:
    insert(pos, argc, ?) -> VectorGenericData
    insert(pos, x) -> iterator
    insert(pos, n, x)

Insert one or more new elements in the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_insert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::iterator arg2 ;
  std::vector< OpenBabel::OBGenericData * >::value_type arg3 = (std::vector< OpenBabel::OBGenericData * >::value_type) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; void *argp3 = 0 ; int res3 = 0 ;
  std::vector< OpenBabel::OBGenericData * >::iterator result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","insert", 2, argv[0] )); }
     } 
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","insert", 3, argv[1] ));  }
   arg3 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp3); result = (arg1)->insert(arg2,arg3);
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBGenericData * >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_insert__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::iterator arg2 ; std::vector< OpenBabel::OBGenericData * >::size_type arg3 ;
  std::vector< OpenBabel::OBGenericData * >::value_type arg4 = (std::vector< OpenBabel::OBGenericData * >::value_type) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; swig::Iterator *iter2 = 0 ; int res2 ; size_t val3 ; int ecode3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","insert", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], SWIG_as_voidptrptr(&iter2), swig::Iterator::descriptor(), 0);
  if (!SWIG_IsOK(res2) || !iter2) {
    SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","insert", 2, argv[0] )); }
   else {
    swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *iter_t = dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *>(iter2);
    if (iter_t) { arg2 = iter_t->get_current(); }  else {
      SWIG_exception_fail(SWIG_ArgError(SWIG_TypeError), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::iterator","insert", 2, argv[0] )); }
     }  ecode3 = SWIG_AsVal_size_t(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","insert", 3, argv[1] )); }
    arg3 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::value_type","insert", 4, argv[2] ));  }
   arg4 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * >::value_type >(argp4); (arg1)->insert(arg2,arg3,arg4);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VectorGenericData_insert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { swig::ConstIterator *iter = 0; int res = SWIG_ConvertPtr(argv[1], SWIG_as_voidptrptr(&iter), 
      swig::Iterator::descriptor(), 0);
      _v = (SWIG_IsOK(res) && iter && (dynamic_cast<swig::Iterator_T<std::vector< OpenBabel::OBGenericData * >::iterator > *>(iter) != 0));}
     if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_VectorGenericData_insert__SWIG_1(nargs, args, self);} 
  check_1: if (argc >= 3) { return _wrap_VectorGenericData_insert__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_VectorGenericData_insert__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "insert", 
  "    void insert(std::vector< OpenBabel::OBGenericData * >::difference_type pos, int argc, VALUE *argv, ...)\n"
  "    void insert(std::vector< OpenBabel::OBGenericData * >::iterator pos, std::vector< OpenBabel::OBGenericData * >::value_type x)\n"
  "    void insert(std::vector< OpenBabel::OBGenericData * >::iterator pos, std::vector< OpenBabel::OBGenericData * >::size_type n, std::vector< OpenBabel::OBGenericData * >::value_type x)\n");
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.reserve

  call-seq:
    reserve(n)

Reserve memory in the VectorGenericData for a number of elements.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_reserve(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ;
  std::vector< OpenBabel::OBGenericData * >::size_type arg2 ; void *argp1 = 0 ; int res1 = 0 ; size_t val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > *","reserve", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1); ecode2 = SWIG_AsVal_size_t(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * >::size_type","reserve", 2, argv[0] )); }
    arg2 = static_cast< std::vector< OpenBabel::OBGenericData * >::size_type >(val2); (arg1)->reserve(arg2); return Qnil; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::VectorGenericData.capacity

  call-seq:
    capacity -> size_type

Reserved capacity of the VectorGenericData.
*/
SWIGINTERN VALUE _wrap_VectorGenericData_capacity(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBGenericData * > *arg1 = (std::vector< OpenBabel::OBGenericData * > *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; std::vector< OpenBabel::OBGenericData * >::size_type result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData * > const *","capacity", 1, self ));  }
   arg1 = reinterpret_cast< std::vector< OpenBabel::OBGenericData * > * >(argp1);
  result = ((std::vector< OpenBabel::OBGenericData * > const *)arg1)->capacity();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg_(std::vector< OpenBabel::OBGenericData * > *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_to_pair_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBPairData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","toPairData", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1); result = (OpenBabel::OBPairData *)toPairData(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_to_unit_cell(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBUnitCell *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","toUnitCell", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1); result = (OpenBabel::OBUnitCell *)toUnitCell(arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); return vresult; fail:
  return Qnil; }
swig_class SwigClassOBGlobalDataBase;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBGlobalDataBase_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBGlobalDataBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGlobalDataBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBGlobalDataBase(int argc, VALUE *argv, VALUE self) { OpenBabel::OBGlobalDataBase *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBGlobalDataBase *)new OpenBabel::OBGlobalDataBase(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBGlobalDataBase(OpenBabel::OBGlobalDataBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBGlobalDataBase_init(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGlobalDataBase *","Init", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1); (arg1)->Init(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGlobalDataBase_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGlobalDataBase *","GetSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1); result = (unsigned int)(arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGlobalDataBase_set_read_directory(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGlobalDataBase *","SetReadDirectory", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","SetReadDirectory", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetReadDirectory(arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBGlobalDataBase_set_environment_variable(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGlobalDataBase *","SetEnvironmentVariable", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","SetEnvironmentVariable", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetEnvironmentVariable(arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBGlobalDataBase_parse_line(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGlobalDataBase *arg1 = (OpenBabel::OBGlobalDataBase *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGlobalDataBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGlobalDataBase *","ParseLine", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGlobalDataBase * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","ParseLine", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->ParseLine((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
swig_class SwigClassOBElement;

SWIGINTERN VALUE _wrap_new_OBElement__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBElement *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBElement *)new OpenBabel::OBElement(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBElement_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBElement_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBElement);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBElement__SWIG_1(int argc, VALUE *argv, VALUE self) { int arg1 ; char *arg2 = (char *) 0 ;
  double arg3 ; double arg4 ; double arg5 ; int arg6 ; double arg7 ; double arg8 ; double arg9 ; double arg10 ; double arg11 ;
  double arg12 ; double arg13 ; std::string arg14 ; int val1 ; int ecode1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ; double val5 ; int ecode5 = 0 ; int val6 ; int ecode6 = 0 ;
  double val7 ; int ecode7 = 0 ; double val8 ; int ecode8 = 0 ; double val9 ; int ecode9 = 0 ; double val10 ; int ecode10 = 0 ;
  double val11 ; int ecode11 = 0 ; double val12 ; int ecode12 = 0 ; double val13 ; int ecode13 = 0 ;
  OpenBabel::OBElement *result = 0 ; if ((argc < 14) || (argc > 14)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 14)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","OpenBabel::OBElement", 1, argv[0] )); }  
  arg1 = static_cast< int >(val1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBElement", 2, argv[1] )); } 
  arg2 = reinterpret_cast< char * >(buf2); ecode3 = SWIG_AsVal_double(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 3, argv[2] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 4, argv[3] )); }  
  arg4 = static_cast< double >(val4); ecode5 = SWIG_AsVal_double(argv[4], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 5, argv[4] )); }  
  arg5 = static_cast< double >(val5); ecode6 = SWIG_AsVal_int(argv[5], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","OpenBabel::OBElement", 6, argv[5] )); }  
  arg6 = static_cast< int >(val6); ecode7 = SWIG_AsVal_double(argv[6], &val7); if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 7, argv[6] )); }  
  arg7 = static_cast< double >(val7); ecode8 = SWIG_AsVal_double(argv[7], &val8); if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 8, argv[7] )); }  
  arg8 = static_cast< double >(val8); ecode9 = SWIG_AsVal_double(argv[8], &val9); if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 9, argv[8] )); }  
  arg9 = static_cast< double >(val9); ecode10 = SWIG_AsVal_double(argv[9], &val10); if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 10, argv[9] )); }  
  arg10 = static_cast< double >(val10); ecode11 = SWIG_AsVal_double(argv[10], &val11); if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 11, argv[10] )); }  
  arg11 = static_cast< double >(val11); ecode12 = SWIG_AsVal_double(argv[11], &val12); if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 12, argv[11] )); }  
  arg12 = static_cast< double >(val12); ecode13 = SWIG_AsVal_double(argv[12], &val13); if (!SWIG_IsOK(ecode13)) {
    SWIG_exception_fail(SWIG_ArgError(ecode13), Ruby_Format_TypeError( "", "double","OpenBabel::OBElement", 13, argv[12] )); }  
  arg13 = static_cast< double >(val13); { std::string *ptr = (std::string *)0; int res = SWIG_AsPtr_std_string(argv[13], &ptr);
    if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenBabel::OBElement", 14, argv[13] ));  }
     arg14 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; } 
  result = (OpenBabel::OBElement *)new OpenBabel::OBElement(arg1,(char const *)arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14);
  DATA_PTR(self) = result; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return self; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBElement(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[14]; int ii; argc = nargs;
  if (argc > 14) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBElement__SWIG_0(nargs, args, self);}  if (argc == 14) {
    return _wrap_new_OBElement__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 14, "OBElement.new", 
  "    OBElement.new()\n"
  "    OBElement.new(int num, char const *sym, double ARENeg, double rcov, double rvdw, int maxbo, double mass, double elNeg, double ionize, double elAffin, double red, double green, double blue, std::string name)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetAtomicNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (int)(arg1)->GetAtomicNum();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_symbol(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetSymbol", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (char *)(arg1)->GetSymbol();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_covalent_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetCovalentRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetCovalentRad();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_vdw_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetVdwRad", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetVdwRad();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetMass", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_max_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetMaxBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (int)(arg1)->GetMaxBonds();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_electro_neg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetElectroNeg", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetElectroNeg();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_allred_rochow_electro_neg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetAllredRochowElectroNeg", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetAllredRochowElectroNeg();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_ionization(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetIonization", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetIonization();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_electron_affinity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetElectronAffinity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetElectronAffinity();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetName", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_red(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetRed", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetRed();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_green(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetGreen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetGreen();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElement_get_blue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElement *arg1 = (OpenBabel::OBElement *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElement, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElement *","GetBlue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElement * >(argp1); result = (double)(arg1)->GetBlue();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBElement(OpenBabel::OBElement *arg1) {
    delete arg1;
}

swig_class SwigClassOBElementTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBElementTable_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBElementTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBElementTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBElementTable(int argc, VALUE *argv, VALUE self) { OpenBabel::OBElementTable *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBElementTable *)new OpenBabel::OBElementTable(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBElementTable(OpenBabel::OBElementTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBElementTable_get_number_of_elements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetNumberOfElements", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); result = (unsigned int)(arg1)->GetNumberOfElements();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_atomic_num__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetAtomicNum", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (int)(arg1)->GetAtomicNum((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_atomic_num__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; char *arg2 = (char *) 0 ; int *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetAtomicNum", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int &","GetAtomicNum", 3, argv[1] ));  }  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetAtomicNum", 3, argv[1])); }
   arg3 = reinterpret_cast< int * >(argp3); result = (int)(arg1)->GetAtomicNum((char const *)arg2,*arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_atomic_num(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBElementTable_get_atomic_num__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBElementTable_get_atomic_num__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBElementTable.get_atomic_num", 
  "    int OBElementTable.get_atomic_num(char const *)\n" "    int OBElementTable.get_atomic_num(char const *, int &iso)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_symbol(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; char *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetSymbol", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetSymbol", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (char *)(arg1)->GetSymbol(arg2); vresult = SWIG_FromCharPtr((const char *)result);
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_vdw_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetVdwRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetVdwRad", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetVdwRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_covalent_rad(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetCovalentRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetCovalentRad", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetCovalentRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetMass", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetMass", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_corrected_bond_rad__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","CorrectedBondRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","CorrectedBondRad", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","CorrectedBondRad", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (double)(arg1)->CorrectedBondRad(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_corrected_bond_rad__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","CorrectedBondRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","CorrectedBondRad", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->CorrectedBondRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_corrected_bond_rad(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBElementTable_corrected_bond_rad__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBElementTable_corrected_bond_rad__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBElementTable.corrected_bond_rad", 
  "    double OBElementTable.corrected_bond_rad(int, int)\n" "    double OBElementTable.corrected_bond_rad(int)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_corrected_vdw_rad__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","CorrectedVdwRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","CorrectedVdwRad", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","CorrectedVdwRad", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (double)(arg1)->CorrectedVdwRad(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_corrected_vdw_rad__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","CorrectedVdwRad", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","CorrectedVdwRad", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->CorrectedVdwRad(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_corrected_vdw_rad(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBElementTable_corrected_vdw_rad__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBElementTable_corrected_vdw_rad__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBElementTable.corrected_vdw_rad", 
  "    double OBElementTable.corrected_vdw_rad(int, int)\n" "    double OBElementTable.corrected_vdw_rad(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_max_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetMaxBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetMaxBonds", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)(arg1)->GetMaxBonds(arg2); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_electro_neg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetElectroNeg", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetElectroNeg", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetElectroNeg(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_allred_rochow_electro_neg(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetAllredRochowElectroNeg", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAllredRochowElectroNeg", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetAllredRochowElectroNeg(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_ionization(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetIonization", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetIonization", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetIonization(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_electron_affinity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetElectronAffinity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetElectronAffinity", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetElectronAffinity(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_rgb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetRGB", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetRGB", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->GetRGB(arg2);
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBElementTable_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBElementTable *arg1 = (OpenBabel::OBElementTable *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBElementTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBElementTable *","GetName", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBElementTable * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetName", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->GetName(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBIsotopeTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBIsotopeTable_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBIsotopeTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBIsotopeTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBIsotopeTable(int argc, VALUE *argv, VALUE self) { OpenBabel::OBIsotopeTable *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBIsotopeTable *)new OpenBabel::OBIsotopeTable(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBIsotopeTable(OpenBabel::OBIsotopeTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBIsotopeTable_get_exact_mass__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ; unsigned int arg2 ; unsigned int arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; unsigned int val2 ; int ecode2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBIsotopeTable *","GetExactMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetExactMass", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","GetExactMass", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); result = (double)(arg1)->GetExactMass(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBIsotopeTable_get_exact_mass__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBIsotopeTable *arg1 = (OpenBabel::OBIsotopeTable *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBIsotopeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBIsotopeTable *","GetExactMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetExactMass", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (double)(arg1)->GetExactMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBIsotopeTable_get_exact_mass(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBIsotopeTable_get_exact_mass__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBIsotopeTable_get_exact_mass__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBIsotopeTable.get_exact_mass", 
  "    double OBIsotopeTable.get_exact_mass(unsigned int const atomicNum, unsigned int const isotope)\n"
  "    double OBIsotopeTable.get_exact_mass(unsigned int const atomicNum)\n"); return Qnil; }
swig_class SwigClassOBTypeTable;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBTypeTable_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBTypeTable_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBTypeTable);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBTypeTable(int argc, VALUE *argv, VALUE self) { OpenBabel::OBTypeTable *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBTypeTable *)new OpenBabel::OBTypeTable(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBTypeTable(OpenBabel::OBTypeTable *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBTypeTable_set_from_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","SetFromType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetFromType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->SetFromType((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_set_to_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","SetToType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetToType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->SetToType((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; char *arg2 = (char *) 0 ; char *arg3 = (char *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","Translate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","Translate", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Translate", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (bool)(arg1)->Translate(arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","Translate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Translate", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Translate", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); { std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","Translate", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Translate", 3, argv[1])); }
     arg3 = ptr; }  result = (bool)(arg1)->Translate(*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res3)) delete arg3; return vresult; fail:
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_translate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","Translate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","Translate", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Translate", 2, argv[0])); }
     arg2 = ptr; }  result = (arg1)->Translate((std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult;
  fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_translate(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBTypeTable_translate__SWIG_2(nargs, args, self);}  if (argc == 3) { int _v = 0; {
      void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; { int res = SWIG_AsPtr_std_string(argv[2], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBTypeTable_translate__SWIG_1(nargs, args, self);}  check_2: if (argc == 3) {
    return _wrap_OBTypeTable_translate__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBTypeTable.translate", 
  "    std::string OBTypeTable.translate(char *to, char const *from)\n"
  "    std::string OBTypeTable.translate(std::string &to, std::string const &from)\n"
  "    std::string OBTypeTable.translate(std::string const &from)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_get_from_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","GetFromType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1); result = (arg1)->GetFromType();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTypeTable_get_to_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTypeTable *arg1 = (OpenBabel::OBTypeTable *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTypeTable, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTypeTable *","GetToType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTypeTable * >(argp1); result = (arg1)->GetToType();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBResidueData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBResidueData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBResidueData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBResidueData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBResidueData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBResidueData *)new OpenBabel::OBResidueData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueData_set_res_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueData *","SetResName", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetResName", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetResName", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(arg1)->SetResName((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueData_lookup_bo__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueData *","LookupBO", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","LookupBO", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","LookupBO", 2, argv[0])); }
     arg2 = ptr; }  result = (int)(arg1)->LookupBO((std::string const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueData_lookup_bo__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; int res3 = SWIG_OLDOBJ ; int result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueData *","LookupBO", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","LookupBO", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","LookupBO", 2, argv[0])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","LookupBO", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","LookupBO", 3, argv[1])); }
     arg3 = ptr; }  result = (int)(arg1)->LookupBO((std::string const &)*arg2,(std::string const &)*arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueData_lookup_bo(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBResidueData_lookup_bo__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBResidueData_lookup_bo__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBResidueData.lookup_bo",  "    int OBResidueData.lookup_bo(std::string const &)\n"
  "    int OBResidueData.lookup_bo(std::string const &, std::string const &)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueData_lookup_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ;
  int *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueData *","LookupType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","LookupType", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","LookupType", 2, argv[0])); }
     arg2 = ptr; }  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string &","LookupType", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","LookupType", 3, argv[1])); }
   arg3 = reinterpret_cast< std::string * >(argp3); res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "int &","LookupType", 4, argv[2] ));  }  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","LookupType", 4, argv[2])); } 
  arg4 = reinterpret_cast< int * >(argp4); result = (bool)(arg1)->LookupType((std::string const &)*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueData_assign_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueData *arg1 = (OpenBabel::OBResidueData *) 0 ; OpenBabel::OBMol *arg2 = 0 ; OpenBabel::OBBitVec *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueData *","AssignBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","AssignBonds", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","AssignBonds", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","AssignBonds", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","AssignBonds", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3); result = (bool)(arg1)->AssignBonds(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBResidueData(OpenBabel::OBResidueData *arg1) {
    delete arg1;
}

swig_class SwigClassDoubleType;

SWIGINTERN VALUE _wrap_DoubleType_hi_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","hi", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","hi", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); if (arg1) (arg1)->hi = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_DoubleType_hi_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","hi", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1); result = (unsigned int) ((arg1)->hi);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_DoubleType_lo_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","lo", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","lo", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); if (arg1) (arg1)->lo = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_DoubleType_lo_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","lo", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1); result = (unsigned int) ((arg1)->lo);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_DoubleType_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_DoubleType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__DoubleType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_DoubleType(int argc, VALUE *argv, VALUE self) { OpenBabel::DoubleType *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::DoubleType *)new OpenBabel::DoubleType(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_DoubleType(OpenBabel::DoubleType *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_double_multiply(int argc, VALUE *argv, VALUE self) { unsigned int arg1 ; unsigned int arg2 ;
  OpenBabel::DoubleType *arg3 = (OpenBabel::DoubleType *) 0 ; unsigned int val1 ; int ecode1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_unsigned_SS_int(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "unsigned int","OpenBabel::DoubleMultiply", 1, argv[0] )); }
    arg1 = static_cast< unsigned int >(val1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","OpenBabel::DoubleMultiply", 2, argv[1] )); }
    arg2 = static_cast< unsigned int >(val2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","OpenBabel::DoubleMultiply", 3, argv[2] ));  }
   arg3 = reinterpret_cast< OpenBabel::DoubleType * >(argp3); OpenBabel::DoubleMultiply(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_double_add(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","OpenBabel::DoubleAdd", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","OpenBabel::DoubleAdd", 2, argv[1] )); }
    arg2 = static_cast< unsigned int >(val2); OpenBabel::DoubleAdd(arg1,arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_double_modulus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::DoubleType *arg1 = (OpenBabel::DoubleType *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__DoubleType, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::DoubleType *","OpenBabel::DoubleModulus", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::DoubleType * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","OpenBabel::DoubleModulus", 2, argv[1] )); }
    arg2 = static_cast< unsigned int >(val2); result = (unsigned int)OpenBabel::DoubleModulus(arg1,arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBRandom;

SWIGINTERN VALUE _wrap_new_OBRandom__SWIG_0(int argc, VALUE *argv, VALUE self) { bool arg1 ; bool val1 ; int ecode1 = 0 ;
  OpenBabel::OBRandom *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_bool(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "bool","OpenBabel::OBRandom", 1, argv[0] )); }  
  arg1 = static_cast< bool >(val1); result = (OpenBabel::OBRandom *)new OpenBabel::OBRandom(arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBRandom_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBRandom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRandom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBRandom__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRandom *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBRandom *)new OpenBabel::OBRandom(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBRandom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBRandom__SWIG_1(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBRandom__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "OBRandom.new", 
  "    OBRandom.new(bool useSys)\n" "    OBRandom.new()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBRandom_seed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRandom *","Seed", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Seed", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->Seed(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRandom_time_seed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRandom *","TimeSeed", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1); (arg1)->TimeSeed(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRandom_next_int(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRandom *","NextInt", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1); result = (int)(arg1)->NextInt();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRandom_next_float(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRandom *arg1 = (OpenBabel::OBRandom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRandom *","NextFloat", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRandom * >(argp1); result = (double)(arg1)->NextFloat();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBRandom(OpenBabel::OBRandom *arg1) {
    delete arg1;
}

swig_class SwigClassOBStopwatch;

SWIGINTERN VALUE _wrap_OBStopwatch_start(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBStopwatch *","Start", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1); (arg1)->Start(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBStopwatch_lap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBStopwatch *","Lap", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1); result = (double)(arg1)->Lap();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBStopwatch_elapsed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBStopwatch *arg1 = (OpenBabel::OBStopwatch *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBStopwatch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBStopwatch *","Elapsed", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBStopwatch * >(argp1); result = (double)(arg1)->Elapsed();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBStopwatch_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBStopwatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBStopwatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBStopwatch(int argc, VALUE *argv, VALUE self) { OpenBabel::OBStopwatch *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBStopwatch *)new OpenBabel::OBStopwatch(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBStopwatch(OpenBabel::OBStopwatch *arg1) {
    delete arg1;
}

swig_class SwigClassOBSqrtTbl;

SWIGINTERN VALUE _wrap_new_OBSqrtTbl__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSqrtTbl *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBSqrtTbl *)new OpenBabel::OBSqrtTbl(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBSqrtTbl_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBSqrtTbl_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSqrtTbl);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBSqrtTbl__SWIG_1(int argc, VALUE *argv, VALUE self) { double arg1 ; double arg2 ; double val1 ;
  int ecode1 = 0 ; double val2 ; int ecode2 = 0 ; OpenBabel::OBSqrtTbl *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "double","OpenBabel::OBSqrtTbl", 1, argv[0] )); }  
  arg1 = static_cast< double >(val1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::OBSqrtTbl", 2, argv[1] )); }  
  arg2 = static_cast< double >(val2); result = (OpenBabel::OBSqrtTbl *)new OpenBabel::OBSqrtTbl(arg1,arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBSqrtTbl(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBSqrtTbl__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_OBSqrtTbl__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "OBSqrtTbl.new", 
  "    OBSqrtTbl.new()\n" "    OBSqrtTbl.new(double const max, double const incr)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBSqrtTbl(OpenBabel::OBSqrtTbl *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBSqrtTbl_sqrt(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *arg1 = (OpenBabel::OBSqrtTbl *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSqrtTbl, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSqrtTbl const *","Sqrt", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSqrtTbl * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","Sqrt", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); result = (double)((OpenBabel::OBSqrtTbl const *)arg1)->Sqrt(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSqrtTbl_init(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSqrtTbl *arg1 = (OpenBabel::OBSqrtTbl *) 0 ; double arg2 ; double arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSqrtTbl, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSqrtTbl *","Init", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSqrtTbl * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","Init", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","Init", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); (arg1)->Init(arg2,arg3); return Qnil; fail: return Qnil; }
swig_class SwigClassVector3;

SWIGINTERN VALUE _wrap_new_Vector3__SWIG_0(int argc, VALUE *argv, VALUE self) { double arg1 ; double arg2 ; double arg3 ;
  double val1 ; int ecode1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; OpenBabel::vector3 *result = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_double(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "double","OpenBabel::vector3", 1, argv[0] )); }  
  arg1 = static_cast< double >(val1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::vector3", 2, argv[1] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","OpenBabel::vector3", 3, argv[2] )); }  
  arg3 = static_cast< double >(val3); result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1,arg2,arg3);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_Vector3__SWIG_1(int argc, VALUE *argv, VALUE self) { double arg1 ; double arg2 ; double val1 ;
  int ecode1 = 0 ; double val2 ; int ecode2 = 0 ; OpenBabel::vector3 *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "double","OpenBabel::vector3", 1, argv[0] )); }  
  arg1 = static_cast< double >(val1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::vector3", 2, argv[1] )); }  
  arg2 = static_cast< double >(val2); result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1,arg2); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_Vector3__SWIG_2(int argc, VALUE *argv, VALUE self) { double arg1 ; double val1 ; int ecode1 = 0 ;
  OpenBabel::vector3 *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_double(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "double","OpenBabel::vector3", 1, argv[0] )); }  
  arg1 = static_cast< double >(val1); result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_Vector3__SWIG_3(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::vector3 *)new OpenBabel::vector3(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_Vector3__SWIG_4(int argc, VALUE *argv, VALUE self) { double *arg1 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double [3]","OpenBabel::vector3", 1, argv[0] ));  }  
  arg1 = reinterpret_cast< double * >(argp1); result = (OpenBabel::vector3 *)new OpenBabel::vector3(arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_Vector3_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_Vector3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__vector3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_Vector3__SWIG_5(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::vector3 *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::vector3", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::vector3", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  result = (OpenBabel::vector3 *)new OpenBabel::vector3((OpenBabel::vector3 const &)*arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_Vector3(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs;
  if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_Vector3__SWIG_3(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_double, 0); _v = SWIG_CheckState(res);}  if (!_v) goto check_2;
    return _wrap_new_Vector3__SWIG_4(nargs, args, self);}  check_2: if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_3; return _wrap_new_Vector3__SWIG_5(nargs, args, self);}  check_3: if (argc == 1) {
    return _wrap_new_Vector3__SWIG_2(nargs, args, self);}  if (argc == 2) { return _wrap_new_Vector3__SWIG_1(nargs, args, self);}
   if (argc == 3) { return _wrap_new_Vector3__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "vector3.new", 
  "    vector3.new(double const inX, double const inY, double const inZ)\n"
  "    vector3.new(double const inX, double const inY)\n" "    vector3.new(double const inX)\n" "    vector3.new()\n"
  "    vector3.new(double inV[3])\n" "    vector3.new(OpenBabel::vector3 const &v)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_vector3(OpenBabel::vector3 *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_Vector3_set__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; double arg2 ; double arg3 ; double arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","Set", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","Set", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","Set", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","Set", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (arg1)->Set(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_set__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","Set", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const *","Set", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); (arg1)->Set((double const *)arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_set(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_Vector3_set__SWIG_1(nargs, args, self);}  if (argc == 4) { return _wrap_Vector3_set__SWIG_0(nargs, args, self);}
   fail: Ruby_Format_OverloadedError( argc, 5, "Vector3.set", 
  "    void Vector3.set(double const inX, double const inY, double const inZ)\n" "    void Vector3.set(double const *c)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_set_x(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","SetX", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetX", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetX(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_set_y(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","SetY", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetY", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetY(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_set_z(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","SetZ", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetZ", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetZ(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_get(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","Get", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) { SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","Get", 2, argv[0] ));  }
   arg2 = reinterpret_cast< double * >(argp2); (arg1)->Get(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_as_array(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","AsArray", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *)((OpenBabel::vector3 const *)arg1)->AsArray();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_random_unit_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; OpenBabel::OBRandom *arg2 = (OpenBabel::OBRandom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","randomUnitVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBRandom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBRandom *","randomUnitVector", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBRandom * >(argp2); (arg1)->randomUnitVector(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_random_unit_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","randomUnitVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); (arg1)->randomUnitVector(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_random_unit_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_Vector3_random_unit_vector__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_Vector3_random_unit_vector__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "Vector3.random_unit_vector", 
  "    void Vector3.random_unit_vector(OpenBabel::OBRandom *oeRand)\n" "    void Vector3.random_unit_vector()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_normalize(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","normalize", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (OpenBabel::vector3 *) &(arg1)->normalize();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_can_be_normalized(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","CanBeNormalized", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (bool)((OpenBabel::vector3 const *)arg1)->CanBeNormalized();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_length_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","length_2", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double)((OpenBabel::vector3 const *)arg1)->length_2();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::Vector3.length

  call-seq:
    length -> double

Size or Length of the Vector3.
*/
SWIGINTERN VALUE _wrap_Vector3_length(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","length", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double)((OpenBabel::vector3 const *)arg1)->length();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_x__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","x", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *) &((OpenBabel::vector3 const *)arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_y__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","y", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *) &((OpenBabel::vector3 const *)arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_z__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","z", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *) &((OpenBabel::vector3 const *)arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_x__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","x", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *) &(arg1)->x();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_x(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_Vector3_x__SWIG_1(nargs, args, self);}  if (argc == 1) { return _wrap_Vector3_x__SWIG_0(nargs, args, self);} 
  fail: Ruby_Format_OverloadedError( argc, 2, "Vector3.x",  "    double & Vector3.x()\n" "    double & Vector3.x()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_y__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","y", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *) &(arg1)->y();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_y(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_Vector3_y__SWIG_1(nargs, args, self);}  if (argc == 1) { return _wrap_Vector3_y__SWIG_0(nargs, args, self);} 
  fail: Ruby_Format_OverloadedError( argc, 2, "Vector3.y",  "    double & Vector3.y()\n" "    double & Vector3.y()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_z__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 *","z", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = (double *) &(arg1)->z();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_z(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_Vector3_z__SWIG_1(nargs, args, self);}  if (argc == 1) { return _wrap_Vector3_z__SWIG_0(nargs, args, self);} 
  fail: Ruby_Format_OverloadedError( argc, 2, "Vector3.z",  "    double & Vector3.z()\n" "    double & Vector3.z()\n");
  return Qnil; }

/*
  Document-method: OpenBabel::Vector3.==

  call-seq:
    ==(?) -> int

Equality comparison operator.
*/
SWIGINTERN VALUE _wrap_Vector3___eq__(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ;
  OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","operator ==", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","operator ==", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","operator ==", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (int)((OpenBabel::vector3 const *)arg1)->operator ==((OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_is_approx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; OpenBabel::vector3 *arg2 = 0 ; double *arg3 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; double temp3 ; double val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","IsApprox", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","IsApprox", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","IsApprox", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","IsApprox", 3, argv[1] )); }  
  temp3 = static_cast< double >(val3); arg3 = &temp3;
  result = (bool)((OpenBabel::vector3 const *)arg1)->IsApprox((OpenBabel::vector3 const &)*arg2,(double const &)*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_dist_sq(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","distSq", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","distSq", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","distSq", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)((OpenBabel::vector3 const *)arg1)->distSq((OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_Vector3_create_ortho_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = (OpenBabel::vector3 *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const *","createOrthoVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","createOrthoVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","createOrthoVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (bool)((OpenBabel::vector3 const *)arg1)->createOrthoVector(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::OpenBabel.<<

  call-seq:
    <<(?, ?) -> std::ostream

Left shifting or appending operator.
*/
SWIGINTERN VALUE _wrap___lshift__(int argc, VALUE *argv, VALUE self) { std::ostream *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; std::ostream *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__ostream,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::ostream &","OpenBabel::operator <<", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","OpenBabel::operator <<", 1, argv[0])); }
   arg1 = reinterpret_cast< std::ostream * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator <<", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator <<", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (std::ostream *) &OpenBabel::operator <<(*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 ); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::OpenBabel.+

  call-seq:
    +(v1, v2) -> Vector3

Add operator.
*/
SWIGINTERN VALUE _wrap___add__(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ; void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator +", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator +", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator +", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator +", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator +((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::OpenBabel.-

  call-seq:
    -(v1, v2) -> Vector3
    -(v) -> Vector3

Substraction operator.
*/
SWIGINTERN VALUE _wrap___sub____SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ; void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator -", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator -", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator -", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator -", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator -((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap___sub____SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator -", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator -", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); result = OpenBabel::operator -((OpenBabel::vector3 const &)*arg1);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap___sub__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) {
    return _wrap___sub____SWIG_1(nargs, args, self);}  if (argc == 2) { return _wrap___sub____SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "__sub__", 
  "    OpenBabel::vector3 __sub__(OpenBabel::vector3 const &v1, OpenBabel::vector3 const &v2)\n"
  "    OpenBabel::vector3 __sub__(OpenBabel::vector3 const &v)\n"); return Qnil; }
SWIGINTERN VALUE _wrap___mul____SWIG_0(int argc, VALUE *argv, VALUE self) { double *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ;
  double temp1 ; double val1 ; int ecode1 = 0 ; void *argp2 ; int res2 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_double(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "double","OpenBabel::operator *", 1, argv[0] )); }  
  temp1 = static_cast< double >(val1); arg1 = &temp1;
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator *", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator *", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator *((double const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap___mul____SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ; double *arg2 = 0 ;
  void *argp1 ; int res1 = 0 ; double temp2 ; double val2 ; int ecode2 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator *", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator *", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::operator *", 2, argv[1] )); }  
  temp2 = static_cast< double >(val2); arg2 = &temp2;
  result = OpenBabel::operator *((OpenBabel::vector3 const &)*arg1,(double const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap___div__(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ; double *arg2 = 0 ;
  void *argp1 ; int res1 = 0 ; double temp2 ; double val2 ; int ecode2 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator /", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator /", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::operator /", 2, argv[1] )); }  
  temp2 = static_cast< double >(val2); arg2 = &temp2;
  result = OpenBabel::operator /((OpenBabel::vector3 const &)*arg1,(double const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap___mul____SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::matrix3x3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ; void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__matrix3x3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::matrix3x3 const &","OpenBabel::operator *", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::matrix3x3 const &","OpenBabel::operator *", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::matrix3x3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::operator *", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::operator *", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::operator *((OpenBabel::matrix3x3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap___mul__(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 2) { int _v = 0; {
      void *vptr = 0; int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; { { int res = SWIG_AsVal_double(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap___mul____SWIG_1(nargs, args, self);}  check_1: if (argc == 2) { int _v = 0; {
      void *vptr = 0; int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__matrix3x3, 0); _v = SWIG_CheckState(res);}
     if (!_v) goto check_2; return _wrap___mul____SWIG_2(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap___mul____SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "__mul__", 
  "    OpenBabel::vector3 __mul__(double const &c, OpenBabel::vector3 const &v)\n"
  "    OpenBabel::vector3 __mul__(OpenBabel::vector3 const &v, double const &c)\n"
  "    OpenBabel::vector3 __mul__(OpenBabel::matrix3x3 const &m, OpenBabel::vector3 const &v)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_dot(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::dot", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::dot", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::dot", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::dot", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::dot((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_cross(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ;
  void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::cross", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::cross", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::cross", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::cross", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = OpenBabel::cross((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_vector_angle(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ; void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::vectorAngle", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::vectorAngle", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::vectorAngle", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::vectorAngle", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::vectorAngle((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_calc_torsion_angle(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ; OpenBabel::vector3 *arg4 = 0 ; void *argp1 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; void *argp3 ; int res3 = 0 ; void *argp4 ; int res4 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 4) || (argc > 4)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 3, argv[2])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 4, argv[3] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","OpenBabel::CalcTorsionAngle", 4, argv[3])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::CalcTorsionAngle((OpenBabel::vector3 const &)*arg1,(OpenBabel::vector3 const &)*arg2,(OpenBabel::vector3 const &)*arg3,(OpenBabel::vector3 const &)*arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_point_2plane(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 arg1 ; OpenBabel::vector3 arg2 ;
  OpenBabel::vector3 arg3 ; OpenBabel::vector3 arg4 ; void *argp1 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; void *argp3 ;
  int res3 = 0 ; void *argp4 ; int res4 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;}  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3","OpenBabel::Point2Plane", 1, argv[0] ));  }
       if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3","OpenBabel::Point2Plane", 1, argv[0])); }
     else { arg1 = *(reinterpret_cast< OpenBabel::vector3 * >(argp1)); }  }  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3","OpenBabel::Point2Plane", 2, argv[1] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3","OpenBabel::Point2Plane", 2, argv[1])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2)); }  }  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3","OpenBabel::Point2Plane", 3, argv[2] ));  }
       if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3","OpenBabel::Point2Plane", 3, argv[2])); }
     else { arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3)); }  }  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3","OpenBabel::Point2Plane", 4, argv[3] ));  }
       if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3","OpenBabel::Point2Plane", 4, argv[3])); }
     else { arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4)); }  } 
  result = (double)OpenBabel::Point2Plane(arg1,arg2,arg3,arg4); vresult = SWIG_From_double(static_cast< double >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_point_2plane_angle(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 arg1 ;
  OpenBabel::vector3 arg2 ; OpenBabel::vector3 arg3 ; OpenBabel::vector3 arg4 ; void *argp1 ; int res1 = 0 ; void *argp2 ;
  int res2 = 0 ; void *argp3 ; int res3 = 0 ; void *argp4 ; int res4 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 4) || (argc > 4)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;}  {
    res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 1, argv[0] ));  }
       if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 1, argv[0])); }
     else { arg1 = *(reinterpret_cast< OpenBabel::vector3 * >(argp1)); }  }  {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 2, argv[1] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 2, argv[1])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2)); }  }  {
    res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 3, argv[2] ));  }
       if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 3, argv[2])); }
     else { arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3)); }  }  {
    res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 4, argv[3] ));  }
       if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","OpenBabel::Point2PlaneAngle", 4, argv[3])); }
     else { arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4)); }  } 
  result = (double)OpenBabel::Point2PlaneAngle(arg1,arg2,arg3,arg4); vresult = SWIG_From_double(static_cast< double >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_VZero_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VZero), SWIGTYPE_p_OpenBabel__vector3,  0 ); return _val; }
SWIGINTERN VALUE _wrap_VX_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VX), SWIGTYPE_p_OpenBabel__vector3,  0 ); return _val; }
SWIGINTERN VALUE _wrap_VY_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VY), SWIGTYPE_p_OpenBabel__vector3,  0 ); return _val; }
SWIGINTERN VALUE _wrap_VZ_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::VZ), SWIGTYPE_p_OpenBabel__vector3,  0 ); return _val; }
swig_class SwigClassOBGenericData;

SWIGINTERN VALUE _wrap_new_OBGenericData__SWIG_0(int argc, VALUE *argv, VALUE self) { std::string arg1 ; unsigned int arg2 ;
  OpenBabel::DataOrigin arg3 ; unsigned int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ;
  OpenBabel::OBGenericData *result = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","OpenBabel::OBGenericData", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","OpenBabel::OBGenericData", 2, argv[1] )); }
    arg2 = static_cast< unsigned int >(val2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","OpenBabel::OBGenericData", 3, argv[2] )); }
    arg3 = static_cast< OpenBabel::DataOrigin >(val3);
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1,arg2,arg3); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBGenericData__SWIG_1(int argc, VALUE *argv, VALUE self) { std::string arg1 ; unsigned int arg2 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","OpenBabel::OBGenericData", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  ecode2 = SWIG_AsVal_unsigned_SS_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","OpenBabel::OBGenericData", 2, argv[1] )); }
    arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1,arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBGenericData__SWIG_2(int argc, VALUE *argv, VALUE self) { std::string arg1 ;
  OpenBabel::OBGenericData *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","OpenBabel::OBGenericData", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; } 
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBGenericData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBGenericData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGenericData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBGenericData__SWIG_3(int argc, VALUE *argv, VALUE self) { OpenBabel::OBGenericData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBGenericData *)new OpenBabel::OBGenericData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBGenericData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs;
  if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBGenericData__SWIG_3(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBGenericData__SWIG_2(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_OBGenericData__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_new_OBGenericData__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBGenericData.new", 
  "    OBGenericData.new(std::string const attr, unsigned int const type, OpenBabel::DataOrigin const source)\n"
  "    OBGenericData.new(std::string const attr, unsigned int const type)\n" "    OBGenericData.new(std::string const attr)\n"
  "    OBGenericData.new()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBGenericData_clone(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData const *","Clone", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Clone", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  result = (OpenBabel::OBGenericData *)((OpenBabel::OBGenericData const *)arg1)->Clone(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBGenericData(OpenBabel::OBGenericData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBGenericData_set_attribute(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetAttribute", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetAttribute", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetAttribute", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetAttribute((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBGenericData_set_origin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetOrigin", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","SetOrigin", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::DataOrigin >(val2); (arg1)->SetOrigin(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGenericData_get_attribute(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData const *","GetAttribute", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (std::string *) &((OpenBabel::OBGenericData const *)arg1)->GetAttribute();
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGenericData_get_data_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData const *","GetDataType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (unsigned int)((OpenBabel::OBGenericData const *)arg1)->GetDataType();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGenericData_get_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData const *","GetValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (std::string *) &((OpenBabel::OBGenericData const *)arg1)->GetValue();
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGenericData_get_origin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGenericData *arg1 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::DataOrigin result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData const *","GetOrigin", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGenericData * >(argp1);
  result = (OpenBabel::DataOrigin)((OpenBabel::OBGenericData const *)arg1)->GetOrigin();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBBase;

SWIGINTERN void
free_OpenBabel_OBBase(OpenBabel::OBBase *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBBase_clear(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); result = (bool)(arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_class_description(int argc, VALUE *argv, VALUE self) { char *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (char *)OpenBabel::OBBase::ClassDescription(); vresult = SWIG_FromCharPtr((const char *)result); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_1;
    return _wrap_OBBase_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_2;
    return _wrap_OBBase_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBBase_has_data__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data", 
  "    bool OBBase.has_data(std::string const &)\n" "    bool OBBase.has_data(char const *)\n"
  "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","DeleteData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","DeleteData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","DeleteData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","DeleteData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBBase_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) { int _v = 0; {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBBase_delete_data__SWIG_2(nargs, args, self);}  check_2:
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_3; return _wrap_OBBase_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBBase_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_set_data(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","CloneData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_data_size(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase const *","DataSize", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); result = (unsigned int)((OpenBabel::OBBase const *)arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetAllData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBBase_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBBase_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBBase_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBBase_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBBase_get_data__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","BeginData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); result = (arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBase_end_data(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","EndData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); result = (arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBBase_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBBase_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBBase);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBBase(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBBase *)new OpenBabel::OBBase(); DATA_PTR(self) = result; return self; fail: return Qnil; }
swig_class SwigClassOBCommentData;

SWIGINTERN VALUE _wrap_new_OBCommentData__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBCommentData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBCommentData *)new OpenBabel::OBCommentData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBCommentData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBCommentData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBCommentData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBCommentData__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBCommentData *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBCommentData *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBCommentData,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBCommentData const &","OpenBabel::OBCommentData", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBCommentData const &","OpenBabel::OBCommentData", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  result = (OpenBabel::OBCommentData *)new OpenBabel::OBCommentData((OpenBabel::OBCommentData const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBCommentData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBCommentData__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBCommentData__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBCommentData.new",  "    OBCommentData.new()\n"
  "    OBCommentData.new(OpenBabel::OBCommentData const &)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBCommentData_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBCommentData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetData", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetData((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBCommentData_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBCommentData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetData((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBCommentData_set_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBCommentData_set_data__SWIG_0(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBCommentData_set_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBCommentData.set_data",  "    void OBCommentData.set_data(std::string const &data)\n"
  "    void OBCommentData.set_data(char const *d)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBCommentData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBCommentData *arg1 = (OpenBabel::OBCommentData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBCommentData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBCommentData const *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBCommentData * >(argp1);
  result = (std::string *) &((OpenBabel::OBCommentData const *)arg1)->GetData();
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBCommentData(OpenBabel::OBCommentData *arg1) {
    delete arg1;
}

swig_class SwigClassOBExternalBond;

SWIGINTERN VALUE _wrap_new_OBExternalBond__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBExternalBond *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBExternalBond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; int arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ;
  OpenBabel::OBExternalBond *result = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBExternalBond", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","OpenBabel::OBExternalBond", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBExternalBond", 3, argv[2] )); }  
  arg3 = static_cast< int >(val3); result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond(arg1,arg2,arg3);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBExternalBond_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBExternalBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBExternalBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBExternalBond__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBExternalBond *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBExternalBond *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBExternalBond,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond const &","OpenBabel::OBExternalBond", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBExternalBond const &","OpenBabel::OBExternalBond", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBExternalBond *)new OpenBabel::OBExternalBond((OpenBabel::OBExternalBond const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBExternalBond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs;
  if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBExternalBond__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBExternalBond__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_new_OBExternalBond__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBExternalBond.new",  "    OBExternalBond.new()\n"
  "    OBExternalBond.new(OpenBabel::OBAtom *, OpenBabel::OBBond *, int)\n"
  "    OBExternalBond.new(OpenBabel::OBExternalBond const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBExternalBond(OpenBabel::OBExternalBond *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBExternalBond_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (int)((OpenBabel::OBExternalBond const *)arg1)->GetIdx(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBond_get_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond const *","GetAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBExternalBond const *)arg1)->GetAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBond_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond const *","GetBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBExternalBond const *)arg1)->GetBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBond_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBond_set_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond *","SetAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->SetAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBond_set_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBond *arg1 = (OpenBabel::OBExternalBond *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBond *","SetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBExternalBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); (arg1)->SetBond(arg2); return Qnil; fail: return Qnil; }
swig_class SwigClassOBExternalBondData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBExternalBondData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBExternalBondData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBExternalBondData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBExternalBondData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBExternalBondData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBExternalBondData *)new OpenBabel::OBExternalBondData(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBondData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ; int arg4 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBondData *","SetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetData", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetData", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","SetData", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->SetData(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBExternalBondData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBExternalBondData *arg1 = (OpenBabel::OBExternalBondData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBExternalBond,std::allocator< OpenBabel::OBExternalBond > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBExternalBondData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBExternalBondData *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBExternalBondData * >(argp1);
  result = (std::vector< OpenBabel::OBExternalBond,std::allocator< OpenBabel::OBExternalBond > > *)(arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBExternalBondData(OpenBabel::OBExternalBondData *arg1) {
    delete arg1;
}

swig_class SwigClassOBPairData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBPairData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBPairData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBPairData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBPairData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBPairData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBPairData *)new OpenBabel::OBPairData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBPairData_set_value__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPairData *","SetValue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetValue", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetValue((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPairData_set_value__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPairData *arg1 = (OpenBabel::OBPairData *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPairData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPairData *","SetValue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPairData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetValue", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetValue", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetValue((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPairData_set_value(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBPairData_set_value__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBPairData_set_value__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBPairData.set_value",  "    void OBPairData.set_value(char const *v)\n"
  "    void OBPairData.set_value(std::string const &v)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBPairData(OpenBabel::OBPairData *arg1) {
    delete arg1;
}

swig_class SwigClassOBSetData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBSetData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBSetData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSetData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBSetData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSetData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBSetData *)new OpenBabel::OBSetData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_add_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","AddData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","AddData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (arg1)->AddData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","SetData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","SetData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (arg1)->SetData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData const *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &((OpenBabel::OBSetData const *)arg1)->GetData();
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(*result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBSetData_get_data__SWIG_2(nargs, args, self);}  if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_2;
    return _wrap_OBSetData_get_data__SWIG_1(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBSetData_get_data__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBSetData.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > const & OBSetData.get_data(char const *s)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > const & OBSetData.get_data(std::string const &s)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > const & OBSetData.get_data()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_get_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","GetBegin", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1); result = (arg1)->GetBegin();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_get_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","GetEnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1); result = (arg1)->GetEnd();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSetData_delete_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSetData *arg1 = (OpenBabel::OBSetData *) 0 ; OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSetData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSetData *","DeleteData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSetData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBSetData(OpenBabel::OBSetData *arg1) {
    delete arg1;
}

swig_class SwigClassOBVirtualBond;

SWIGINTERN VALUE _wrap_new_OBVirtualBond__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBVirtualBond *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBVirtualBond__SWIG_1(int argc, VALUE *argv, VALUE self) { int arg1 ; int arg2 ; int arg3 ;
  int arg4 ; int val1 ; int ecode1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  OpenBabel::OBVirtualBond *result = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 1, argv[0] )); }  
  arg1 = static_cast< int >(val1); ecode2 = SWIG_AsVal_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 2, argv[1] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 3, argv[2] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 4, argv[3] )); }  
  arg4 = static_cast< int >(val4); result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(arg1,arg2,arg3,arg4);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBVirtualBond_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBVirtualBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVirtualBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBVirtualBond__SWIG_2(int argc, VALUE *argv, VALUE self) { int arg1 ; int arg2 ; int arg3 ;
  int val1 ; int ecode1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; OpenBabel::OBVirtualBond *result = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  ecode1 = SWIG_AsVal_int(argv[0], &val1); if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 1, argv[0] )); }  
  arg1 = static_cast< int >(val1); ecode2 = SWIG_AsVal_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 2, argv[1] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBVirtualBond", 3, argv[2] )); }  
  arg3 = static_cast< int >(val3); result = (OpenBabel::OBVirtualBond *)new OpenBabel::OBVirtualBond(arg1,arg2,arg3);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBVirtualBond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs;
  if (argc > 4) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBVirtualBond__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_new_OBVirtualBond__SWIG_2(nargs, args, self);}  if (argc == 4) {
    return _wrap_new_OBVirtualBond__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBVirtualBond.new",  "    OBVirtualBond.new()\n"
  "    OBVirtualBond.new(int, int, int, int stereo)\n" "    OBVirtualBond.new(int, int, int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBVirtualBond_get_bgn(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVirtualBond *","GetBgn", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1); result = (int)(arg1)->GetBgn();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBVirtualBond_get_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVirtualBond *","GetEnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1); result = (int)(arg1)->GetEnd();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBVirtualBond_get_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVirtualBond *","GetOrder", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1); result = (int)(arg1)->GetOrder();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBVirtualBond_get_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVirtualBond *arg1 = (OpenBabel::OBVirtualBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVirtualBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVirtualBond *","GetStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVirtualBond * >(argp1); result = (int)(arg1)->GetStereo();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBVirtualBond(OpenBabel::OBVirtualBond *arg1) {
    delete arg1;
}

swig_class SwigClassOBRingData;

SWIGINTERN VALUE _wrap_new_OBRingData__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRingData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBRingData *)new OpenBabel::OBRingData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBRingData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBRingData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRingData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBRingData__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRingData *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBRingData *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBRingData,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData const &","OpenBabel::OBRingData", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBRingData const &","OpenBabel::OBRingData", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (OpenBabel::OBRingData *)new OpenBabel::OBRingData((OpenBabel::OBRingData const &)*arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBRingData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBRingData__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBRingData__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "OBRingData.new", 
  "    OBRingData.new()\n" "    OBRingData.new(OpenBabel::OBRingData const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBRingData(OpenBabel::OBRingData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBRingData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > &","SetData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > &","SetData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > * >(argp2);
  (arg1)->SetData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingData_push_back(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ; OpenBabel::OBRing *arg2 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","PushBack", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","PushBack", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2); (arg1)->PushBack(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *) &(arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingData_begin_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","BeginRings", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1); result = (arg1)->BeginRings();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingData_end_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","EndRings", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1); result = (arg1)->EndRings();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingData_begin_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBRing *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","BeginRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator &","BeginRing", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator &","BeginRing", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator * >(argp2);
  result = (OpenBabel::OBRing *)(arg1)->BeginRing(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBRingData_next_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingData *arg1 = (OpenBabel::OBRingData *) 0 ;
  std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBRing *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingData *","NextRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator &","NextRing", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator &","NextRing", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator * >(argp2);
  result = (OpenBabel::OBRing *)(arg1)->NextRing(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); return vresult; fail:
  return Qnil; }
swig_class SwigClassOBUnitCell;

SWIGINTERN VALUE _wrap_new_OBUnitCell__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBUnitCell *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBUnitCell *)new OpenBabel::OBUnitCell(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBUnitCell_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBUnitCell_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBUnitCell);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBUnitCell__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBUnitCell *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBUnitCell *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBUnitCell,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell const &","OpenBabel::OBUnitCell", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBUnitCell const &","OpenBabel::OBUnitCell", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (OpenBabel::OBUnitCell *)new OpenBabel::OBUnitCell((OpenBabel::OBUnitCell const &)*arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBUnitCell(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBUnitCell__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBUnitCell__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "OBUnitCell.new", 
  "    OBUnitCell.new()\n" "    OBUnitCell.new(OpenBabel::OBUnitCell const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBUnitCell(OpenBabel::OBUnitCell *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBUnitCell_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; double arg2 ; double arg3 ; double arg4 ; double arg5 ;
  double arg6 ; double arg7 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ;
  double val4 ; int ecode4 = 0 ; double val5 ; int ecode5 = 0 ; double val6 ; int ecode6 = 0 ; double val7 ; int ecode7 = 0 ;
  if ((argc < 6) || (argc > 6)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetData", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetData", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","SetData", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); ecode5 = SWIG_AsVal_double(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","SetData", 5, argv[3] )); }  
  arg5 = static_cast< double >(val5); ecode6 = SWIG_AsVal_double(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "double","SetData", 6, argv[4] )); }  
  arg6 = static_cast< double >(val6); ecode7 = SWIG_AsVal_double(argv[5], &val7); if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), Ruby_Format_TypeError( "", "double","SetData", 7, argv[5] )); }  
  arg7 = static_cast< double >(val7); (arg1)->SetData(arg2,arg3,arg4,arg5,arg6,arg7); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; OpenBabel::vector3 arg2 ; OpenBabel::vector3 arg3 ;
  OpenBabel::vector3 arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; void *argp3 ; int res3 = 0 ;
  void *argp4 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","SetData", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","SetData", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2)); }  }  {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","SetData", 3, argv[1] ));  }
       if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","SetData", 3, argv[1])); }
     else { arg3 = *(reinterpret_cast< OpenBabel::vector3 * >(argp3)); }  }  {
    res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","SetData", 4, argv[2] ));  }
       if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","SetData", 4, argv[2])); }
     else { arg4 = *(reinterpret_cast< OpenBabel::vector3 * >(argp4)); }  }  (arg1)->SetData(arg2,arg3,arg4); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[8]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 8) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 4) { return _wrap_OBUnitCell_set_data__SWIG_1(nargs, args, self);}  if (argc == 7) {
    return _wrap_OBUnitCell_set_data__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 8, "OBUnitCell.set_data", 
  "    void OBUnitCell.set_data(double const a, double const b, double const c, double const alpha, double const beta, double const gamma)\n"
  "    void OBUnitCell.set_data(OpenBabel::vector3 const v1, OpenBabel::vector3 const v2, OpenBabel::vector3 const v3)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_offset(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; OpenBabel::vector3 arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetOffset", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const","SetOffset", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const","SetOffset", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2)); }  }  (arg1)->SetOffset(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_space_group__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; OpenBabel::SpaceGroup *arg2 = (OpenBabel::SpaceGroup *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetSpaceGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__SpaceGroup, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::SpaceGroup const *","SetSpaceGroup", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::SpaceGroup * >(argp2); (arg1)->SetSpaceGroup((OpenBabel::SpaceGroup const *)arg2);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_space_group__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetSpaceGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","SetSpaceGroup", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetSpaceGroup(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_space_group__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetSpaceGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetSpaceGroup", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetSpaceGroup(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_space_group(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__SpaceGroup, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBUnitCell_set_space_group__SWIG_0(nargs, args, self);} 
  check_1: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_2; return _wrap_OBUnitCell_set_space_group__SWIG_2(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBUnitCell_set_space_group__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBUnitCell.set_space_group", 
  "    void OBUnitCell.set_space_group(OpenBabel::SpaceGroup const *sg)\n"
  "    void OBUnitCell.set_space_group(std::string const sg)\n" "    void OBUnitCell.set_space_group(int const sg)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_set_lattice_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; OpenBabel::OBUnitCell::LatticeType arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","SetLatticeType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell::LatticeType","SetLatticeType", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::OBUnitCell::LatticeType >(val2); (arg1)->SetLatticeType(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_fill_unit_cell(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","FillUnitCell", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FillUnitCell", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (arg1)->FillUnitCell(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_a(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetA", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetA();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_b(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetB", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetB();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_c(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetC", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetC();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_alpha(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetAlpha", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetAlpha();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_beta(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetBeta", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetBeta();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_gamma(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetGamma", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetGamma();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_offset(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetOffset", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (arg1)->GetOffset();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_space_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::SpaceGroup *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetSpaceGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (OpenBabel::SpaceGroup *)(arg1)->GetSpaceGroup();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__SpaceGroup, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_space_group_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetSpaceGroupName", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (arg1)->GetSpaceGroupName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_lattice_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBUnitCell::LatticeType result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetLatticeType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetLatticeType", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (OpenBabel::OBUnitCell::LatticeType)(arg1)->GetLatticeType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_lattice_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBUnitCell::LatticeType result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetLatticeType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1);
  result = (OpenBabel::OBUnitCell::LatticeType)(arg1)->GetLatticeType(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_lattice_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBUnitCell_get_lattice_type__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBUnitCell_get_lattice_type__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBUnitCell.get_lattice_type", 
  "    OpenBabel::OBUnitCell::LatticeType OBUnitCell.get_lattice_type(int spacegroup)\n"
  "    OpenBabel::OBUnitCell::LatticeType OBUnitCell.get_lattice_type()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_cell_vectors(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetCellVectors", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (arg1)->GetCellVectors();
  vresult = swig::from(static_cast< std::vector<OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_cell_matrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::matrix3x3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetCellMatrix", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (arg1)->GetCellMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_ortho_matrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::matrix3x3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetOrthoMatrix", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (arg1)->GetOrthoMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_fractional_matrix(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::matrix3x3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetFractionalMatrix", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (arg1)->GetFractionalMatrix();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_space_group_number__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetSpaceGroupNumber", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","GetSpaceGroupNumber", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  result = (int)(arg1)->GetSpaceGroupNumber(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_space_group_number__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetSpaceGroupNumber", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (int)(arg1)->GetSpaceGroupNumber();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_space_group_number(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBUnitCell_get_space_group_number__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBUnitCell_get_space_group_number__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBUnitCell.get_space_group_number", 
  "    int OBUnitCell.get_space_group_number(std::string name)\n" "    int OBUnitCell.get_space_group_number()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBUnitCell_get_cell_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBUnitCell *arg1 = (OpenBabel::OBUnitCell *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBUnitCell, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBUnitCell *","GetCellVolume", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBUnitCell * >(argp1); result = (double)(arg1)->GetCellVolume();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBConformerData;

SWIGINTERN VALUE _wrap_new_OBConformerData__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBConformerData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBConformerData *)new OpenBabel::OBConformerData(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBConformerData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBConformerData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBConformerData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBConformerData__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBConformerData *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBConformerData *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBConformerData,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData const &","OpenBabel::OBConformerData", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBConformerData const &","OpenBabel::OBConformerData", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1);
  result = (OpenBabel::OBConformerData *)new OpenBabel::OBConformerData((OpenBabel::OBConformerData const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBConformerData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBConformerData__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBConformerData__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBConformerData.new",  "    OBConformerData.new()\n"
  "    OBConformerData.new(OpenBabel::OBConformerData const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBConformerData(OpenBabel::OBConformerData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBConformerData_set_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper< std::vector< unsigned short,std::allocator< unsigned short > > > arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","SetDimension", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned short,std::allocator< unsigned short > >","SetDimension", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned short,std::allocator< unsigned short > >","SetDimension", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< std::vector< unsigned short,std::allocator< unsigned short > > * >(argp2)); }  } 
  (arg1)->SetDimension(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_set_energies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; std::vector< double,std::allocator< double > > arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","SetEnergies", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); {
    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    int res = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > >","SetEnergies", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetEnergies(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_set_forces(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","SetForces", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >","SetForces", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >","SetForces", 2, argv[0])); }
     else {
      arg2 = *(reinterpret_cast< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > * >(argp2)); }
     }  (arg1)->SetForces(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_set_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","SetVelocities", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >","SetVelocities", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >","SetVelocities", 2, argv[0])); }
     else {
      arg2 = *(reinterpret_cast< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > * >(argp2)); }
     }  (arg1)->SetVelocities(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_set_displacements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","SetDisplacements", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >","SetDisplacements", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >","SetDisplacements", 2, argv[0])); }
     else {
      arg2 = *(reinterpret_cast< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > * >(argp2)); }
     }  (arg1)->SetDisplacements(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ;
  std::vector< std::string,std::allocator< std::string > > arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","SetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); {
    std::vector<std::string,std::allocator< std::string > > *ptr = (std::vector<std::string,std::allocator< std::string > > *)0;
    int res = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::vector< std::string,std::allocator< std::string > >","SetData", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_get_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< unsigned short,std::allocator< unsigned short > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","GetDimension", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); result = (arg1)->GetDimension();
  vresult = SWIG_NewPointerObj((new std::vector< unsigned short,std::allocator< unsigned short > >(static_cast< const std::vector< unsigned short,std::allocator< unsigned short > >& >(result))), SWIGTYPE_p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_get_energies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","GetEnergies", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); result = (arg1)->GetEnergies();
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_get_forces(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","GetForces", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); result = (arg1)->GetForces();
  vresult = SWIG_NewPointerObj((new std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >(static_cast< const std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >& >(result))), SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_get_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","GetVelocities", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); result = (arg1)->GetVelocities();
  vresult = SWIG_NewPointerObj((new std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >(static_cast< const std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >& >(result))), SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_get_displacements(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","GetDisplacements", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); result = (arg1)->GetDisplacements();
  vresult = SWIG_NewPointerObj((new std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >(static_cast< const std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >& >(result))), SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConformerData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConformerData *arg1 = (OpenBabel::OBConformerData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConformerData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConformerData *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConformerData * >(argp1); result = (arg1)->GetData();
  vresult = swig::from(static_cast< std::vector<std::string,std::allocator< std::string > > >(result)); return vresult; fail:
  return Qnil; }
swig_class SwigClassOBSymmetryData;

SWIGINTERN VALUE _wrap_new_OBSymmetryData__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSymmetryData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBSymmetryData *)new OpenBabel::OBSymmetryData(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBSymmetryData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBSymmetryData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSymmetryData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBSymmetryData__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSymmetryData *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBSymmetryData *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSymmetryData,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData const &","OpenBabel::OBSymmetryData", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBSymmetryData const &","OpenBabel::OBSymmetryData", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1);
  result = (OpenBabel::OBSymmetryData *)new OpenBabel::OBSymmetryData((OpenBabel::OBSymmetryData const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBSymmetryData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBSymmetryData__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBSymmetryData__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBSymmetryData.new",  "    OBSymmetryData.new()\n"
  "    OBSymmetryData.new(OpenBabel::OBSymmetryData const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBSymmetryData(OpenBabel::OBSymmetryData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBSymmetryData_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ; std::string arg2 ; std::string arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SetData", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SetData", 3, argv[1] ));  }
     arg3 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetData(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSymmetryData_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SetData", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSymmetryData_set_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBSymmetryData_set_data__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBSymmetryData_set_data__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBSymmetryData.set_data", 
  "    void OBSymmetryData.set_data(std::string pg, std::string sg)\n" "    void OBSymmetryData.set_data(std::string pg)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBSymmetryData_set_point_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData *","SetPointGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SetPointGroup", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetPointGroup(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSymmetryData_set_space_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData *","SetSpaceGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SetSpaceGroup", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetSpaceGroup(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSymmetryData_get_point_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData *","GetPointGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1); result = (arg1)->GetPointGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSymmetryData_get_space_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSymmetryData *arg1 = (OpenBabel::OBSymmetryData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSymmetryData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSymmetryData *","GetSpaceGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSymmetryData * >(argp1); result = (arg1)->GetSpaceGroup();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBTorsion;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBTorsion_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBTorsion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBTorsion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBTorsion__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBTorsion *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::OBTorsion *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBTorsion,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion const &","OpenBabel::OBTorsion", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBTorsion const &","OpenBabel::OBTorsion", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (OpenBabel::OBTorsion *)new OpenBabel::OBTorsion((OpenBabel::OBTorsion const &)*arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBTorsion(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) {
    return _wrap_new_OBTorsion__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "new_OBTorsion.new", 
  "    new_OBTorsion.new(OpenBabel::OBTorsion const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBTorsion(OpenBabel::OBTorsion *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBTorsion_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); (arg1)->Clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","Empty", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); result = (bool)(arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_add_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","AddTorsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddTorsion", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddTorsion", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddTorsion", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddTorsion", 5, argv[3] ));  } 
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5); result = (bool)(arg1)->AddTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_add_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ;
  OpenBabel::quad< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","AddTorsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::quad< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &","AddTorsion", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::quad< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &","AddTorsion", 2, argv[0])); }
  
  arg2 = reinterpret_cast< OpenBabel::quad< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > * >(argp2);
  result = (bool)(arg1)->AddTorsion(*arg2); vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_add_torsion(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 6) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBTorsion_add_torsion__SWIG_1(nargs, args, self);}  if (argc == 5) {
    return _wrap_OBTorsion_add_torsion__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBTorsion.add_torsion", 
  "    bool OBTorsion.add_torsion(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b, OpenBabel::OBAtom *c, OpenBabel::OBAtom *d)\n"
  "    bool OBTorsion.add_torsion(OpenBabel::quad< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &atoms)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_set_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; double arg2 ; unsigned int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","SetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetAngle", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SetAngle", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); result = (bool)(arg1)->SetAngle(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_set_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","SetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetAngle", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); result = (bool)(arg1)->SetAngle(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_set_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBTorsion_set_angle__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBTorsion_set_angle__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBTorsion.set_angle", 
  "    bool OBTorsion.set_angle(double radians, unsigned int index)\n" "    bool OBTorsion.set_angle(double radians)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetData", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(arg1)->SetData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; double *arg2 = 0 ; unsigned int arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double &","GetAngle", 2, argv[0] ));  }  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "double &","GetAngle", 2, argv[0])); }
   arg2 = reinterpret_cast< double * >(argp2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","GetAngle", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); result = (bool)(arg1)->GetAngle(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; double *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double &","GetAngle", 2, argv[0] ));  }  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "double &","GetAngle", 2, argv[0])); }
   arg2 = reinterpret_cast< double * >(argp2); result = (bool)(arg1)->GetAngle(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBTorsion_get_angle__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBTorsion_get_angle__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBTorsion.get_angle", 
  "    bool OBTorsion.get_angle(double &radians, unsigned int index)\n" "    bool OBTorsion.get_angle(double &radians)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_bond_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","GetBondIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); result = (unsigned int)(arg1)->GetBondIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion const *","GetSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1);
  result = (unsigned int)((OpenBabel::OBTorsion const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_bc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::pair< OpenBabel::OBAtom *,OpenBabel::OBAtom * > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","GetBC", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); result = (arg1)->GetBC();
  vresult = SWIG_NewPointerObj((new std::pair< OpenBabel::OBAtom *,OpenBabel::OBAtom * >(static_cast< const std::pair< OpenBabel::OBAtom *,OpenBabel::OBAtom * >& >(result))), SWIGTYPE_p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_get_ads(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double >,std::allocator< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > > > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","GetADs", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); result = (arg1)->GetADs();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double >,std::allocator< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > >(static_cast< const std::vector< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double >,std::allocator< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsion_is_proton_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsion *arg1 = (OpenBabel::OBTorsion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion *","IsProtonRotor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTorsion * >(argp1); result = (bool)(arg1)->IsProtonRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBTorsionData;

SWIGINTERN VALUE _wrap_OBTorsionData_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsionData *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1); (arg1)->Clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsionData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBTorsion,std::allocator< OpenBabel::OBTorsion > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsionData const *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1); result = ((OpenBabel::OBTorsionData const *)arg1)->GetData();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBTorsion,std::allocator< OpenBabel::OBTorsion > >(static_cast< const std::vector< OpenBabel::OBTorsion,std::allocator< OpenBabel::OBTorsion > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsionData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsionData const *","GetSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  result = (unsigned int)((OpenBabel::OBTorsionData const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsionData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ; OpenBabel::OBTorsion *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsionData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBTorsion,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBTorsion &","SetData", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBTorsion &","SetData", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBTorsion * >(argp2); (arg1)->SetData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBTorsionData_fill_torsion_array(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBTorsionData *arg1 = (OpenBabel::OBTorsionData *) 0 ;
  std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBTorsionData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBTorsionData *","FillTorsionArray", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBTorsionData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &","FillTorsionArray", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &","FillTorsionArray", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > * >(argp2);
  result = (bool)(arg1)->FillTorsionArray(*arg2); vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBTorsionData(OpenBabel::OBTorsionData *arg1) {
    delete arg1;
}

swig_class SwigClassOBAngle;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBAngle_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBAngle_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAngle);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBAngle__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAngle *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::OBAngle *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAngle,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle const &","OpenBabel::OBAngle", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAngle const &","OpenBabel::OBAngle", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  result = (OpenBabel::OBAngle *)new OpenBabel::OBAngle((OpenBabel::OBAngle const &)*arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBAngle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) {
    return _wrap_new_OBAngle__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "new_OBAngle.new", 
  "    new_OBAngle.new(OpenBabel::OBAngle const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBAngle(OpenBabel::OBAngle *arg1) {
    delete arg1;
}


/*
  Document-method: OpenBabel::OBAngle.==

  call-seq:
    ==(?) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE _wrap_OBAngle___eq__(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::OBAngle *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle *","operator ==", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAngle,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAngle const &","operator ==", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAngle const &","operator ==", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBAngle * >(argp2);
  result = (bool)(arg1)->operator ==((OpenBabel::OBAngle const &)*arg2); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngle_clear(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1); (arg1)->Clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngle_get_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle const *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1); result = (double)((OpenBabel::OBAngle const *)arg1)->GetAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngle_set_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle *","SetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetAngle", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetAngle(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngle_set_atoms__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle *","SetAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtoms", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtoms", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtoms", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4); (arg1)->SetAtoms(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngle_set_atoms__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngle *arg1 = (OpenBabel::OBAngle *) 0 ;
  OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngle, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngle *","SetAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngle * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &","SetAtoms", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &","SetAtoms", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > * >(argp2);
  (arg1)->SetAtoms(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngle_set_atoms(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBAngle_set_atoms__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBAngle_set_atoms__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBAngle.set_atoms", 
  "    void OBAngle.set_atoms(OpenBabel::OBAtom *vertex, OpenBabel::OBAtom *a, OpenBabel::OBAtom *b)\n"
  "    void OBAngle.set_atoms(OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > &atoms)\n");
  return Qnil; }
swig_class SwigClassOBAngleData;

SWIGINTERN VALUE _wrap_OBAngleData_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngleData *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1); (arg1)->Clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngleData_fill_angle_array__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ; int **arg2 = (int **) 0 ; unsigned int *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngleData *","FillAngleArray", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_int, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int **","FillAngleArray", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< int ** >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_unsigned_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "unsigned int &","FillAngleArray", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "unsigned int &","FillAngleArray", 3, argv[1])); }
   arg3 = reinterpret_cast< unsigned int * >(argp3); result = (unsigned int)(arg1)->FillAngleArray(arg2,*arg3);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngleData_fill_angle_array__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ;
  std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngleData *","FillAngleArray", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &","FillAngleArray", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &","FillAngleArray", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > * >(argp2);
  result = (bool)(arg1)->FillAngleArray(*arg2); vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAngleData_fill_angle_array(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBAngleData_fill_angle_array__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBAngleData_fill_angle_array__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBAngleData.fill_angle_array", 
  "    bool OBAngleData.fill_angle_array(int **angles, unsigned int &size)\n"
  "    bool OBAngleData.fill_angle_array(std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > &angles)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAngleData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ; OpenBabel::OBAngle *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngleData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAngle,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAngle &","SetData", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAngle &","SetData", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBAngle * >(argp2); (arg1)->SetData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAngleData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAngleData *arg1 = (OpenBabel::OBAngleData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAngleData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAngleData const *","GetSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAngleData * >(argp1);
  result = (unsigned int)((OpenBabel::OBAngleData const *)arg1)->GetSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBAngleData(OpenBabel::OBAngleData *arg1) {
    delete arg1;
}

swig_class SwigClassOBChiralData;

SWIGINTERN VALUE _wrap_new_OBChiralData__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBChiralData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBChiralData *)new OpenBabel::OBChiralData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBChiralData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBChiralData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBChiralData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBChiralData__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBChiralData *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBChiralData *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBChiralData,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData const &","OpenBabel::OBChiralData", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBChiralData const &","OpenBabel::OBChiralData", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1);
  result = (OpenBabel::OBChiralData *)new OpenBabel::OBChiralData((OpenBabel::OBChiralData const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBChiralData(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBChiralData__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBChiralData__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "OBChiralData.new", 
  "    OBChiralData.new()\n" "    OBChiralData.new(OpenBabel::OBChiralData const &src)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBChiralData(OpenBabel::OBChiralData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBChiralData_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1); (arg1)->Clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBChiralData_get_atom_4refs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ; OpenBabel::atomreftype arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; std::vector< unsigned int,std::allocator< unsigned int > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData const *","GetAtom4Refs", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::atomreftype","GetAtom4Refs", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::atomreftype >(val2); result = ((OpenBabel::OBChiralData const *)arg1)->GetAtom4Refs(arg2);
  vresult = swig::from(static_cast< std::vector<unsigned int,std::allocator< unsigned int > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBChiralData_get_atom_ref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ; int arg2 ; OpenBabel::atomreftype arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData *","GetAtomRef", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAtomRef", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::atomreftype","GetAtomRef", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::atomreftype >(val3); result = (unsigned int)(arg1)->GetAtomRef(arg2,arg3);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBChiralData_set_atom_4refs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > arg2 ; OpenBabel::atomreftype arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; int val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData *","SetAtom4Refs", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1); {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    int res = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > >","SetAtom4Refs", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::atomreftype","SetAtom4Refs", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::atomreftype >(val3); result = (bool)(arg1)->SetAtom4Refs(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBChiralData_add_atom_ref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ; unsigned int arg2 ; OpenBabel::atomreftype arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData *","AddAtomRef", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","AddAtomRef", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::atomreftype","AddAtomRef", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::atomreftype >(val3); result = (int)(arg1)->AddAtomRef(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBChiralData_get_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBChiralData *arg1 = (OpenBabel::OBChiralData *) 0 ; OpenBabel::atomreftype arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBChiralData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBChiralData const *","GetSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBChiralData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::atomreftype","GetSize", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::atomreftype >(val2);
  result = (unsigned int)((OpenBabel::OBChiralData const *)arg1)->GetSize(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBSerialNums;

SWIGINTERN VALUE _wrap_new_OBSerialNums__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSerialNums *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBSerialNums *)new OpenBabel::OBSerialNums(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBSerialNums_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBSerialNums_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSerialNums);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBSerialNums__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSerialNums *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBSerialNums *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSerialNums,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSerialNums const &","OpenBabel::OBSerialNums", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBSerialNums const &","OpenBabel::OBSerialNums", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  result = (OpenBabel::OBSerialNums *)new OpenBabel::OBSerialNums((OpenBabel::OBSerialNums const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBSerialNums(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBSerialNums__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBSerialNums__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "OBSerialNums.new", 
  "    OBSerialNums.new()\n" "    OBSerialNums.new(OpenBabel::OBSerialNums const &cp)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBSerialNums_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSerialNums *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  result = (std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > *) &(arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSerialNums_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSerialNums *arg1 = (OpenBabel::OBSerialNums *) 0 ;
  std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSerialNums, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSerialNums *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSerialNums * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > &","SetData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > &","SetData", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > * >(argp2);
  (arg1)->SetData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBSerialNums(OpenBabel::OBSerialNums *arg1) {
    delete arg1;
}

swig_class SwigClassOBVibrationData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBVibrationData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBVibrationData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVibrationData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBVibrationData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBVibrationData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBVibrationData *)new OpenBabel::OBVibrationData(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBVibrationData(OpenBabel::OBVibrationData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBVibrationData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ;
  std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ; std::vector< double,std::allocator< double > > *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; int res3 = SWIG_OLDOBJ ; int res4 = SWIG_OLDOBJ ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVibrationData *","SetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > const &","SetData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > const &","SetData", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > * >(argp2);
  { std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    res3 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > > const &","SetData", 3, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double,std::allocator< double > > const &","SetData", 3, argv[1])); }
     arg3 = ptr; }  { std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    res4 = swig::asptr(argv[2], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > > const &","SetData", 4, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double,std::allocator< double > > const &","SetData", 4, argv[2])); }
     arg4 = ptr; } 
  (arg1)->SetData((std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,(std::vector< double,std::allocator< double > > const &)*arg4);
  if (SWIG_IsNewObj(res3)) delete arg3; if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; fail:
  if (SWIG_IsNewObj(res3)) delete arg3; if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_OBVibrationData_get_lx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVibrationData const *","GetLx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1); result = ((OpenBabel::OBVibrationData const *)arg1)->GetLx();
  vresult = SWIG_NewPointerObj((new std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >(static_cast< const std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > >& >(result))), SWIGTYPE_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBVibrationData_get_frequencies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVibrationData const *","GetFrequencies", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetFrequencies();
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBVibrationData_get_intensities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVibrationData const *","GetIntensities", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = ((OpenBabel::OBVibrationData const *)arg1)->GetIntensities();
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBVibrationData_get_number_of_frequencies(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVibrationData *arg1 = (OpenBabel::OBVibrationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVibrationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVibrationData const *","GetNumberOfFrequencies", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVibrationData * >(argp1);
  result = (unsigned int)((OpenBabel::OBVibrationData const *)arg1)->GetNumberOfFrequencies();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBRotationData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBRotationData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBRotationData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRotationData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBRotationData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRotationData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBRotationData *)new OpenBabel::OBRotationData(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBRotationData(OpenBabel::OBRotationData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBRotationData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRotationData *arg1 = (OpenBabel::OBRotationData *) 0 ; OpenBabel::OBRotationData::RType arg2 ;
  std::vector< double,std::allocator< double > > arg3 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  int val4 ; int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRotationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRotationData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRotationData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::OBRotationData::RType","SetData", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::OBRotationData::RType >(val2); {
    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    int res = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > >","SetData", 3, argv[1] ));  }
     arg3 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","SetData", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->SetData(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRotationData_get_rot_consts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRotationData *arg1 = (OpenBabel::OBRotationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRotationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRotationData const *","GetRotConsts", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRotationData * >(argp1);
  result = ((OpenBabel::OBRotationData const *)arg1)->GetRotConsts();
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBRotationData_get_symmetry_number(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRotationData *arg1 = (OpenBabel::OBRotationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRotationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRotationData const *","GetSymmetryNumber", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRotationData * >(argp1);
  result = (int)((OpenBabel::OBRotationData const *)arg1)->GetSymmetryNumber();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRotationData_get_rotor_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRotationData *arg1 = (OpenBabel::OBRotationData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBRotationData::RType result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRotationData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRotationData const *","GetRotorType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRotationData * >(argp1);
  result = (OpenBabel::OBRotationData::RType)((OpenBabel::OBRotationData const *)arg1)->GetRotorType();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBVectorData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBVectorData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBVectorData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBVectorData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBVectorData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBVectorData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBVectorData *)new OpenBabel::OBVectorData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBVectorData(OpenBabel::OBVectorData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBVectorData_set_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVectorData *arg1 = (OpenBabel::OBVectorData *) 0 ; double arg2 ; double arg3 ; double arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVectorData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVectorData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBVectorData * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetData", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetData", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","SetData", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (arg1)->SetData(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBVectorData_set_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVectorData *arg1 = (OpenBabel::OBVectorData *) 0 ; OpenBabel::vector3 arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVectorData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVectorData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBVectorData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3","SetData", 2, argv[0] ));  }   
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3","SetData", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2)); }  }  (arg1)->SetData(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBVectorData_set_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBVectorData_set_data__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBVectorData_set_data__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBVectorData.set_data", 
  "    void OBVectorData.set_data(double x, double y, double z)\n" "    void OBVectorData.set_data(OpenBabel::vector3 data)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBVectorData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBVectorData *arg1 = (OpenBabel::OBVectorData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBVectorData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBVectorData const *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBVectorData * >(argp1); result = ((OpenBabel::OBVectorData const *)arg1)->GetData();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
swig_class SwigClassOBMatrixData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMatrixData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMatrixData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMatrixData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMatrixData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMatrixData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMatrixData *)new OpenBabel::OBMatrixData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMatrixData(OpenBabel::OBMatrixData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMatrixData_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMatrixData *arg1 = (OpenBabel::OBMatrixData *) 0 ; OpenBabel::matrix3x3 arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMatrixData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMatrixData *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMatrixData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__matrix3x3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::matrix3x3","SetData", 2, argv[0] ));  }   
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::matrix3x3","SetData", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::matrix3x3 * >(argp2)); }  }  (arg1)->SetData(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMatrixData_get_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMatrixData *arg1 = (OpenBabel::OBMatrixData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::matrix3x3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMatrixData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMatrixData const *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMatrixData * >(argp1); result = ((OpenBabel::OBMatrixData const *)arg1)->GetData();
  vresult = SWIG_NewPointerObj((new OpenBabel::matrix3x3(static_cast< const OpenBabel::matrix3x3& >(result))), SWIGTYPE_p_OpenBabel__matrix3x3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
swig_class SwigClassOBGridData;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBGridData_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBGridData_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBGridData);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBGridData(int argc, VALUE *argv, VALUE self) { OpenBabel::OBGridData *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBGridData *)new OpenBabel::OBGridData(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBGridData(OpenBabel::OBGridData *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBGridData_get_axes__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; double *arg2 ; double *arg3 ; double *arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetAxes", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [3]","GetAxes", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double [3]","GetAxes", 3, argv[1] ));  }  
  arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double [3]","GetAxes", 4, argv[2] ));  }  
  arg4 = reinterpret_cast< double * >(argp4); ((OpenBabel::OBGridData const *)arg1)->GetAxes(arg2,arg3,arg4); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_xaxis(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetXAxis", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); result = ((OpenBabel::OBGridData const *)arg1)->GetXAxis();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_yaxis(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetYAxis", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); result = ((OpenBabel::OBGridData const *)arg1)->GetYAxis();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_zaxis(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetZAxis", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); result = ((OpenBabel::OBGridData const *)arg1)->GetZAxis();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_axes__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetAxes", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetAxes", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetAxes", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetAxes", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetAxes", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetAxes", 4, argv[2] ));  } 
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetAxes", 4, argv[2])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4); ((OpenBabel::OBGridData const *)arg1)->GetAxes(*arg2,*arg3,*arg4);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_axes(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 4) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_double, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_double, 0); _v = SWIG_CheckState(res);}  if (!_v) goto check_1; {
      void *vptr = 0; int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_double, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBGridData_get_axes__SWIG_0(nargs, args, self);}  check_1: if (argc == 4) {
    return _wrap_OBGridData_get_axes__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBGridData.get_axes", 
  "    void OBGridData.get_axes(double x[3], double y[3], double z[3])\n"
  "    void OBGridData.get_axes(OpenBabel::vector3 &v1, OpenBabel::vector3 &v2, OpenBabel::vector3 &v3)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_number_of_points__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; int *arg2 = 0 ; int *arg3 = 0 ; int *arg4 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetNumberOfPoints", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int &","GetNumberOfPoints", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetNumberOfPoints", 2, argv[0])); }
   arg2 = reinterpret_cast< int * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int &","GetNumberOfPoints", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetNumberOfPoints", 3, argv[1])); }
   arg3 = reinterpret_cast< int * >(argp3); res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "int &","GetNumberOfPoints", 4, argv[2] ));  } 
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetNumberOfPoints", 4, argv[2])); }
   arg4 = reinterpret_cast< int * >(argp4); ((OpenBabel::OBGridData const *)arg1)->GetNumberOfPoints(*arg2,*arg3,*arg4);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_number_of_points__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetNumberOfPoints", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  result = (int)((OpenBabel::OBGridData const *)arg1)->GetNumberOfPoints(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_number_of_points(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBGridData_get_number_of_points__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBGridData_get_number_of_points__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBGridData.get_number_of_points", 
  "    int OBGridData.get_number_of_points(int &nx, int &ny, int &nz)\n" "    int OBGridData.get_number_of_points()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_number_of_steps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; int *arg2 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetNumberOfSteps", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_int, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int [3]","GetNumberOfSteps", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< int * >(argp2); ((OpenBabel::OBGridData const *)arg1)->GetNumberOfSteps(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_values(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetValues", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); result = ((OpenBabel::OBGridData const *)arg1)->GetValues();
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_value__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; int arg2 ; int arg3 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetValue", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetValue", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","GetValue", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); result = (double)((OpenBabel::OBGridData const *)arg1)->GetValue(arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_value__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; OpenBabel::vector3 arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3","GetValue", 2, argv[0] ));  }   
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3","GetValue", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::vector3 * >(argp2)); }  } 
  result = (double)((OpenBabel::OBGridData const *)arg1)->GetValue(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_value(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBGridData_get_value__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBGridData_get_value__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBGridData.get_value",  "    double OBGridData.get_value(int i, int j, int k)\n"
  "    double OBGridData.get_value(OpenBabel::vector3 pos)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_unit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBGridData::Unit result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetUnit", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  result = (OpenBabel::OBGridData::Unit)((OpenBabel::OBGridData const *)arg1)->GetUnit();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_min_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetMinValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  result = (double)((OpenBabel::OBGridData const *)arg1)->GetMinValue();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_max_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetMaxValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  result = (double)((OpenBabel::OBGridData const *)arg1)->GetMaxValue();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_origin_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetOriginVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); result = ((OpenBabel::OBGridData const *)arg1)->GetOriginVector();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_origin_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; double *arg2 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetOriginVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [3]","GetOriginVector", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); ((OpenBabel::OBGridData const *)arg1)->GetOriginVector(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_origin_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBGridData_get_origin_vector__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBGridData_get_origin_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBGridData.get_origin_vector",  "    void OBGridData.get_origin_vector()\n"
  "    void OBGridData.get_origin_vector(double o[3])\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_max_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetMaxVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); result = ((OpenBabel::OBGridData const *)arg1)->GetMaxVector();
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_unrestricted(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetUnrestricted", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  result = (bool)((OpenBabel::OBGridData const *)arg1)->GetUnrestricted();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_get_num_symmetries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData const *","GetNumSymmetries", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  result = (int)((OpenBabel::OBGridData const *)arg1)->GetNumSymmetries(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_number_of_points(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; int arg2 ; int arg3 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetNumberOfPoints", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetNumberOfPoints", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","SetNumberOfPoints", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","SetNumberOfPoints", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->SetNumberOfPoints(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_limits__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ; OpenBabel::vector3 *arg5 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ;
  void *argp3 ; int res3 = 0 ; void *argp4 ; int res4 = 0 ; void *argp5 ; int res5 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetLimits", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetLimits", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetLimits", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetLimits", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetLimits", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetLimits", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetLimits", 4, argv[2])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetLimits", 5, argv[3] ));  }
   if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetLimits", 5, argv[3])); }
   arg5 = reinterpret_cast< OpenBabel::vector3 * >(argp5);
  (arg1)->SetLimits((OpenBabel::vector3 const &)*arg2,(OpenBabel::vector3 const &)*arg3,(OpenBabel::vector3 const &)*arg4,(OpenBabel::vector3 const &)*arg5);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_limits__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; double *arg2 ; double *arg3 ; double *arg4 ; double *arg5 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetLimits", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const [3]","SetLimits", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double const [3]","SetLimits", 3, argv[1] ));  }  
  arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double const [3]","SetLimits", 4, argv[2] ));  }  
  arg4 = reinterpret_cast< double * >(argp4); res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "double const [3]","SetLimits", 5, argv[3] ));  }  
  arg5 = reinterpret_cast< double * >(argp5);
  (arg1)->SetLimits((double const (*))arg2,(double const (*))arg3,(double const (*))arg4,(double const (*))arg5); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_limits(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 6) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 5) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBGridData_set_limits__SWIG_0(nargs, args, self);}  check_1: if (argc == 5) {
    return _wrap_OBGridData_set_limits__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBGridData.set_limits", 
  "    void OBGridData.set_limits(OpenBabel::vector3 const &origin, OpenBabel::vector3 const &x, OpenBabel::vector3 const &y, OpenBabel::vector3 const &z)\n"
  "    void OBGridData.set_limits(double const origin[3], double const x[3], double const y[3], double const z[3])\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; int arg2 ; int arg3 ; int arg4 ; double arg5 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; double val5 ;
  int ecode5 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetValue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetValue", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","SetValue", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","SetValue", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); ecode5 = SWIG_AsVal_double(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","SetValue", 5, argv[3] )); }  
  arg5 = static_cast< double >(val5); result = (bool)(arg1)->SetValue(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_values(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; std::vector< double,std::allocator< double > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetValues", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); {
    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > > const &","SetValues", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double,std::allocator< double > > const &","SetValues", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetValues((std::vector< double,std::allocator< double > > const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_unit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; OpenBabel::OBGridData::Unit arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetUnit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::OBGridData::Unit","SetUnit", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::OBGridData::Unit >(val2); (arg1)->SetUnit(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_unrestricted(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetUnrestricted", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SetUnrestricted", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->SetUnrestricted(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBGridData_set_num_symmetries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBGridData *arg1 = (OpenBabel::OBGridData *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBGridData *","SetNumSymmetries", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBGridData * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetNumSymmetries", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetNumSymmetries(arg2); return Qnil; fail: return Qnil; }
swig_class SwigClassCharPtrLess;

SWIGINTERN VALUE _wrap_CharPtrLess___call__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::CharPtrLess *arg1 = (OpenBabel::CharPtrLess *) 0 ; char *arg2 = (char *) 0 ; char *arg3 = (char *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__CharPtrLess, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::CharPtrLess const *","operator ()", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::CharPtrLess * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","operator ()", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","operator ()", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3);
  result = (bool)((OpenBabel::CharPtrLess const *)arg1)->operator ()((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_CharPtrLess_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_CharPtrLess_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__CharPtrLess);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_CharPtrLess(int argc, VALUE *argv, VALUE self) { OpenBabel::CharPtrLess *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::CharPtrLess *)new OpenBabel::CharPtrLess(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_CharPtrLess(OpenBabel::CharPtrLess *arg1) {
    delete arg1;
}

swig_class SwigClassOBPlugin;

SWIGINTERN void
free_OpenBabel_OBPlugin(OpenBabel::OBPlugin *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBPlugin_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPlugin *arg1 = (OpenBabel::OBPlugin *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPlugin *","Description", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPlugin * >(argp1); result = (char *)(arg1)->Description();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_display__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPlugin *arg1 = (OpenBabel::OBPlugin *) 0 ; std::string *arg2 = 0 ; char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ;
  int alloc3 = 0 ; int res4 ; char *buf4 = 0 ; int alloc4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPlugin *","Display", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPlugin * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Display", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Display", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Display", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","Display", 4, argv[2] )); } 
  arg4 = reinterpret_cast< char * >(buf4); result = (bool)(arg1)->Display(*arg2,(char const *)arg3,(char const *)arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return vresult; fail: if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_display__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPlugin *arg1 = (OpenBabel::OBPlugin *) 0 ; std::string *arg2 = 0 ; char *arg3 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPlugin *","Display", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPlugin * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Display", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Display", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Display", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (bool)(arg1)->Display(*arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_display(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    return _wrap_OBPlugin_display__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBPlugin_display__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "OBPlugin.display", 
  "    bool OBPlugin.display(std::string &txt, char const *param, char const *ID)\n"
  "    bool OBPlugin.display(std::string &txt, char const *param)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_make_instance(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPlugin *arg1 = (OpenBabel::OBPlugin *) 0 ; std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; OpenBabel::OBPlugin *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPlugin *","MakeInstance", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPlugin * >(argp1); {
    std::vector<std::string,std::allocator< std::string > > *ptr = (std::vector<std::string,std::allocator< std::string > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::string,std::allocator< std::string > > const &","MakeInstance", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string,std::allocator< std::string > > const &","MakeInstance", 2, argv[0])); }
     arg2 = ptr; } 
  result = (OpenBabel::OBPlugin *)(arg1)->MakeInstance((std::vector< std::string,std::allocator< std::string > > const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_get_plugin(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ; int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  OpenBabel::OBPlugin *result = 0 ; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::GetPlugin", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::GetPlugin", 2, argv[1] )); }
   arg2 = reinterpret_cast< char * >(buf2);
  result = (OpenBabel::OBPlugin *)OpenBabel::OBPlugin::GetPlugin((char const *)arg1,(char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_get_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPlugin *arg1 = (OpenBabel::OBPlugin *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPlugin const *","GetID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPlugin * >(argp1); result = (char *)((OpenBabel::OBPlugin const *)arg1)->GetID();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list_as_vector(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ; std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ; int res1 ; char *buf1 = 0 ;
  int alloc1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::ListAsVector", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::ListAsVector", 2, argv[1] )); }
   arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::string,std::allocator< std::string > > &","OpenBabel::OBPlugin::ListAsVector", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string,std::allocator< std::string > > &","OpenBabel::OBPlugin::ListAsVector", 3, argv[2])); }
   arg3 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp3);
  result = (bool)OpenBabel::OBPlugin::ListAsVector((char const *)arg1,(char const *)arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list__SWIG_0(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ; std::ostream *arg3 = (std::ostream *) 0 ; int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::List", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::List", 2, argv[1] )); }
   arg2 = reinterpret_cast< char * >(buf2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::ostream *","OpenBabel::OBPlugin::List", 3, argv[2] ));  }
   arg3 = reinterpret_cast< std::ostream * >(argp3); OpenBabel::OBPlugin::List((char const *)arg1,(char const *)arg2,arg3);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list__SWIG_1(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ; int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::List", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::List", 2, argv[1] )); }
   arg2 = reinterpret_cast< char * >(buf2); OpenBabel::OBPlugin::List((char const *)arg1,(char const *)arg2);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list__SWIG_2(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::List", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); OpenBabel::OBPlugin::List((char const *)arg1);
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs;
  if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) {
    return _wrap_OBPlugin_list__SWIG_2(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBPlugin_list__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBPlugin_list__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBPlugin.list", 
  "    void OBPlugin.list(char const *PluginID, char const *param, std::ostream *os)\n"
  "    void OBPlugin.list(char const *PluginID, char const *param)\n" "    void OBPlugin.list(char const *PluginID)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list_as_string__SWIG_0(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ; int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  std::string result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::ListAsString", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::ListAsString", 2, argv[1] )); }
   arg2 = reinterpret_cast< char * >(buf2); result = OpenBabel::OBPlugin::ListAsString((char const *)arg1,(char const *)arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list_as_string__SWIG_1(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::ListAsString", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = OpenBabel::OBPlugin::ListAsString((char const *)arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult;
  fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_list_as_string(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs; if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) {
    return _wrap_OBPlugin_list_as_string__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBPlugin_list_as_string__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBPlugin.list_as_string", 
  "    std::string OBPlugin.list_as_string(char const *PluginID, char const *param)\n"
  "    std::string OBPlugin.list_as_string(char const *PluginID)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_first_line(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::FirstLine", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = OpenBabel::OBPlugin::FirstLine((char const *)arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult;
  fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_begin(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ; char *buf1 = 0 ;
  int alloc1 = 0 ; OpenBabel::OBPlugin::PluginIterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::Begin", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = OpenBabel::OBPlugin::Begin((char const *)arg1);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBPlugin::PluginIterator(static_cast< const OpenBabel::OBPlugin::PluginIterator& >(result))), SWIGTYPE_p_OpenBabel__OBPlugin__PluginMapType__const_iterator, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_end(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ; char *buf1 = 0 ;
  int alloc1 = 0 ; OpenBabel::OBPlugin::PluginIterator result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBPlugin::End", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = OpenBabel::OBPlugin::End((char const *)arg1);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBPlugin::PluginIterator(static_cast< const OpenBabel::OBPlugin::PluginIterator& >(result))), SWIGTYPE_p_OpenBabel__OBPlugin__PluginMapType__const_iterator, SWIG_POINTER_OWN |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBPlugin_get_map(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBPlugin *arg1 = (OpenBabel::OBPlugin *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBPlugin::PluginMapType *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBPlugin, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBPlugin const *","GetMap", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBPlugin * >(argp1);
  result = (OpenBabel::OBPlugin::PluginMapType *) &((OpenBabel::OBPlugin const *)arg1)->GetMap();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
swig_class SwigClassOBError;

SWIGINTERN VALUE _wrap_new_OBError__SWIG_0(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string *arg3 = 0 ; std::string *arg4 = 0 ; std::string *arg5 = 0 ; OpenBabel::obMessageLevel arg6 ;
  int res1 = SWIG_OLDOBJ ; int res2 = SWIG_OLDOBJ ; int res3 = SWIG_OLDOBJ ; int res4 = SWIG_OLDOBJ ; int res5 = SWIG_OLDOBJ ;
  int val6 ; int ecode6 = 0 ; OpenBabel::OBError *result = 0 ; if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 1, argv[0])); }
     arg1 = ptr; }  { std::string *ptr = (std::string *)0; res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 2, argv[1])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[2], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 3, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 3, argv[2])); }
     arg3 = ptr; }  { std::string *ptr = (std::string *)0; res4 = SWIG_AsPtr_std_string(argv[3], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 4, argv[3] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 4, argv[3])); }
     arg4 = ptr; }  { std::string *ptr = (std::string *)0; res5 = SWIG_AsPtr_std_string(argv[4], &ptr); if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 5, argv[4] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 5, argv[4])); }
     arg5 = ptr; }  ecode6 = SWIG_AsVal_int(argv[5], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "OpenBabel::obMessageLevel","OpenBabel::OBError", 6, argv[5] )); }
    arg6 = static_cast< OpenBabel::obMessageLevel >(val6);
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,arg6);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; if (SWIG_IsNewObj(res4)) delete arg4; if (SWIG_IsNewObj(res5)) delete arg5; return self;
  fail: if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2; if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4; if (SWIG_IsNewObj(res5)) delete arg5; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBError__SWIG_1(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string *arg3 = 0 ; std::string *arg4 = 0 ; std::string *arg5 = 0 ; int res1 = SWIG_OLDOBJ ; int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ; int res4 = SWIG_OLDOBJ ; int res5 = SWIG_OLDOBJ ; OpenBabel::OBError *result = 0 ;
  if ((argc < 5) || (argc > 5)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;}  {
    std::string *ptr = (std::string *)0; res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 1, argv[0])); }
     arg1 = ptr; }  { std::string *ptr = (std::string *)0; res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 2, argv[1])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[2], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 3, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 3, argv[2])); }
     arg3 = ptr; }  { std::string *ptr = (std::string *)0; res4 = SWIG_AsPtr_std_string(argv[3], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 4, argv[3] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 4, argv[3])); }
     arg4 = ptr; }  { std::string *ptr = (std::string *)0; res5 = SWIG_AsPtr_std_string(argv[4], &ptr); if (!SWIG_IsOK(res5)) {
      SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 5, argv[4] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 5, argv[4])); }
     arg5 = ptr; } 
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; if (SWIG_IsNewObj(res4)) delete arg4; if (SWIG_IsNewObj(res5)) delete arg5; return self;
  fail: if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2; if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4; if (SWIG_IsNewObj(res5)) delete arg5; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBError__SWIG_2(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string *arg3 = 0 ; std::string *arg4 = 0 ; int res1 = SWIG_OLDOBJ ; int res2 = SWIG_OLDOBJ ; int res3 = SWIG_OLDOBJ ;
  int res4 = SWIG_OLDOBJ ; OpenBabel::OBError *result = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 1, argv[0])); }
     arg1 = ptr; }  { std::string *ptr = (std::string *)0; res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 2, argv[1])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[2], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 3, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 3, argv[2])); }
     arg3 = ptr; }  { std::string *ptr = (std::string *)0; res4 = SWIG_AsPtr_std_string(argv[3], &ptr); if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 4, argv[3] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 4, argv[3])); }
     arg4 = ptr; } 
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; if (SWIG_IsNewObj(res4)) delete arg4; return self; fail:
  if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2; if (SWIG_IsNewObj(res3)) delete arg3;
  if (SWIG_IsNewObj(res4)) delete arg4; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBError__SWIG_3(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  std::string *arg3 = 0 ; int res1 = SWIG_OLDOBJ ; int res2 = SWIG_OLDOBJ ; int res3 = SWIG_OLDOBJ ;
  OpenBabel::OBError *result = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 1, argv[0])); }
     arg1 = ptr; }  { std::string *ptr = (std::string *)0; res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 2, argv[1])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[2], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 3, argv[2] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 3, argv[2])); }
     arg3 = ptr; } 
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2; if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBError__SWIG_4(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; std::string *arg2 = 0 ;
  int res1 = SWIG_OLDOBJ ; int res2 = SWIG_OLDOBJ ; OpenBabel::OBError *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 1, argv[0])); }
     arg1 = ptr; }  { std::string *ptr = (std::string *)0; res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 2, argv[1])); }
     arg2 = ptr; } 
  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1,(std::string const &)*arg2);
  DATA_PTR(self) = result; if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2; return self; fail:
  if (SWIG_IsNewObj(res1)) delete arg1; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBError__SWIG_5(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; int res1 = SWIG_OLDOBJ ;
  OpenBabel::OBError *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBError", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBError", 1, argv[0])); }
     arg1 = ptr; }  result = (OpenBabel::OBError *)new OpenBabel::OBError((std::string const &)*arg1); DATA_PTR(self) = result;
  if (SWIG_IsNewObj(res1)) delete arg1; return self; fail: if (SWIG_IsNewObj(res1)) delete arg1; return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBError_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBError_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBError);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBError__SWIG_6(int argc, VALUE *argv, VALUE self) { OpenBabel::OBError *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBError *)new OpenBabel::OBError(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBError(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6]; int ii; argc = nargs;
  if (argc > 6) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBError__SWIG_6(nargs, args, self);}  if (argc == 1) { return _wrap_new_OBError__SWIG_5(nargs, args, self);}
   if (argc == 2) { return _wrap_new_OBError__SWIG_4(nargs, args, self);}  if (argc == 3) {
    return _wrap_new_OBError__SWIG_3(nargs, args, self);}  if (argc == 4) { return _wrap_new_OBError__SWIG_2(nargs, args, self);}
   if (argc == 5) { return _wrap_new_OBError__SWIG_1(nargs, args, self);}  if (argc == 6) {
    return _wrap_new_OBError__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 6, "OBError.new", 
  "    OBError.new(std::string const &method, std::string const &errorMsg, std::string const &explanation, std::string const &possibleCause, std::string const &suggestedRemedy, OpenBabel::obMessageLevel const)\n"
  "    OBError.new(std::string const &method, std::string const &errorMsg, std::string const &explanation, std::string const &possibleCause, std::string const &suggestedRemedy)\n"
  "    OBError.new(std::string const &method, std::string const &errorMsg, std::string const &explanation, std::string const &possibleCause)\n"
  "    OBError.new(std::string const &method, std::string const &errorMsg, std::string const &explanation)\n"
  "    OBError.new(std::string const &method, std::string const &errorMsg)\n" "    OBError.new(std::string const &method)\n"
  "    OBError.new()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBError_message(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","message", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1); result = ((OpenBabel::OBError const *)arg1)->message();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBError_get_method(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","GetMethod", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1); result = ((OpenBabel::OBError const *)arg1)->GetMethod();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBError_get_error(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","GetError", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1); result = ((OpenBabel::OBError const *)arg1)->GetError();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBError_get_explanation(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","GetExplanation", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1); result = ((OpenBabel::OBError const *)arg1)->GetExplanation();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBError_get_possible_cause(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","GetPossibleCause", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1); result = ((OpenBabel::OBError const *)arg1)->GetPossibleCause();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBError_get_suggested_remedy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","GetSuggestedRemedy", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1); result = ((OpenBabel::OBError const *)arg1)->GetSuggestedRemedy();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBError_get_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::obMessageLevel result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","GetLevel", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  result = (OpenBabel::obMessageLevel)((OpenBabel::OBError const *)arg1)->GetLevel();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }

/*
  Document-method: OpenBabel::OBError.==

  call-seq:
    ==(?) -> bool

Equality comparison operator.
*/
SWIGINTERN VALUE _wrap_OBError___eq__(int argc, VALUE *argv, VALUE self) { OpenBabel::OBError *arg1 = (OpenBabel::OBError *) 0 ;
  OpenBabel::OBError *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBError, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBError const *","operator ==", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBError * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBError,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBError const &","operator ==", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBError const &","operator ==", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBError * >(argp2);
  result = (bool)((OpenBabel::OBError const *)arg1)->operator ==((OpenBabel::OBError const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBError(OpenBabel::OBError *arg1) {
    delete arg1;
}

swig_class SwigClassOBMessageHandler;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMessageHandler_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMessageHandler_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMessageHandler);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMessageHandler(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMessageHandler *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMessageHandler *)new OpenBabel::OBMessageHandler(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMessageHandler(OpenBabel::OBMessageHandler *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; OpenBabel::OBError arg2 ;
  OpenBabel::errorQualifier arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","ThrowError", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBError,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBError","ThrowError", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBError","ThrowError", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::OBError * >(argp2)); }  }  ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::errorQualifier","ThrowError", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::errorQualifier >(val3); (arg1)->ThrowError(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; OpenBabel::OBError arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","ThrowError", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBError,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBError","ThrowError", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBError","ThrowError", 2, argv[0])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::OBError * >(argp2)); }  }  (arg1)->ThrowError(arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ;
  OpenBabel::obMessageLevel arg4 ; OpenBabel::errorQualifier arg5 ; void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ;
  int res3 = SWIG_OLDOBJ ; int val4 ; int ecode4 = 0 ; int val5 ; int ecode5 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","ThrowError", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","ThrowError", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ThrowError", 2, argv[0])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","ThrowError", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ThrowError", 3, argv[1])); }
     arg3 = ptr; }  ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "OpenBabel::obMessageLevel","ThrowError", 4, argv[2] )); }
    arg4 = static_cast< OpenBabel::obMessageLevel >(val4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "OpenBabel::errorQualifier","ThrowError", 5, argv[3] )); }
    arg5 = static_cast< OpenBabel::errorQualifier >(val5);
  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3,arg4,arg5); if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail: if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ;
  OpenBabel::obMessageLevel arg4 ; void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; int res3 = SWIG_OLDOBJ ; int val4 ;
  int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","ThrowError", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","ThrowError", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ThrowError", 2, argv[0])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","ThrowError", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ThrowError", 3, argv[1])); }
     arg3 = ptr; }  ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "OpenBabel::obMessageLevel","ThrowError", 4, argv[2] )); }
    arg4 = static_cast< OpenBabel::obMessageLevel >(val4);
  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3,arg4); if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail: if (SWIG_IsNewObj(res2)) delete arg2;
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; std::string *arg2 = 0 ; std::string *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; int res3 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","ThrowError", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","ThrowError", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ThrowError", 2, argv[0])); }
     arg2 = ptr; }  { std::string *ptr = (std::string *)0; res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","ThrowError", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","ThrowError", 3, argv[1])); }
     arg3 = ptr; }  (arg1)->ThrowError((std::string const &)*arg2,(std::string const &)*arg3);
  if (SWIG_IsNewObj(res2)) delete arg2; if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_throw_error(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 6) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBMessageHandler_throw_error__SWIG_1(nargs, args, self);}  if (argc == 3) { int _v = 0; {
      void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBError, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; { { int res = SWIG_AsVal_int(argv[2], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBMessageHandler_throw_error__SWIG_0(nargs, args, self);}  check_2: if (argc == 3) {
    return _wrap_OBMessageHandler_throw_error__SWIG_4(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBMessageHandler_throw_error__SWIG_3(nargs, args, self);}  if (argc == 5) {
    return _wrap_OBMessageHandler_throw_error__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBMessageHandler.throw_error", 
  "    void OBMessageHandler.throw_error(OpenBabel::OBError err, OpenBabel::errorQualifier qqualifier)\n"
  "    void OBMessageHandler.throw_error(OpenBabel::OBError err)\n"
  "    void OBMessageHandler.throw_error(std::string const &method, std::string const &errorMsg, OpenBabel::obMessageLevel level, OpenBabel::errorQualifier qualifier)\n"
  "    void OBMessageHandler.throw_error(std::string const &method, std::string const &errorMsg, OpenBabel::obMessageLevel level)\n"
  "    void OBMessageHandler.throw_error(std::string const &method, std::string const &errorMsg)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_messages_of_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; OpenBabel::obMessageLevel arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; std::vector< std::string,std::allocator< std::string > > result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetMessagesOfLevel", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::obMessageLevel","GetMessagesOfLevel", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::obMessageLevel >(val2); result = (arg1)->GetMessagesOfLevel(arg2);
  vresult = swig::from(static_cast< std::vector<std::string,std::allocator< std::string > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_start_logging(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","StartLogging", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); (arg1)->StartLogging(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_stop_logging(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","StopLogging", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); (arg1)->StopLogging(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_set_max_log_entries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","SetMaxLogEntries", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetMaxLogEntries", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->SetMaxLogEntries(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_max_log_entries(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetMaxLogEntries", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (unsigned int)(arg1)->GetMaxLogEntries();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_clear_log(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","ClearLog", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); (arg1)->ClearLog(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_set_output_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; OpenBabel::obMessageLevel arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","SetOutputLevel", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::obMessageLevel","SetOutputLevel", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::obMessageLevel >(val2); (arg1)->SetOutputLevel(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_output_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::obMessageLevel result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetOutputLevel", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  result = (OpenBabel::obMessageLevel)(arg1)->GetOutputLevel(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_set_output_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; std::ostream *arg2 = (std::ostream *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","SetOutputStream", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","SetOutputStream", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::ostream * >(argp2); (arg1)->SetOutputStream(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_output_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::ostream *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetOutputStream", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (std::ostream *)(arg1)->GetOutputStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_start_error_wrap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","StartErrorWrap", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (bool)(arg1)->StartErrorWrap();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_stop_error_wrap(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","StopErrorWrap", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (bool)(arg1)->StopErrorWrap();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_error_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetErrorMessageCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (unsigned int)(arg1)->GetErrorMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_warning_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetWarningMessageCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (unsigned int)(arg1)->GetWarningMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_info_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetInfoMessageCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (unsigned int)(arg1)->GetInfoMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_audit_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetAuditMessageCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (unsigned int)(arg1)->GetAuditMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_debug_message_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetDebugMessageCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (unsigned int)(arg1)->GetDebugMessageCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMessageHandler_get_message_summary(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMessageHandler *arg1 = (OpenBabel::OBMessageHandler *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMessageHandler, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMessageHandler *","GetMessageSummary", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMessageHandler * >(argp1); result = (arg1)->GetMessageSummary();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_obErrorLog_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::obErrorLog), SWIGTYPE_p_OpenBabel__OBMessageHandler,  0 ); return _val; }
SWIGINTERN VALUE _wrap_obErrorLog_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBMessageHandler,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::obErrorLog""' of type '""OpenBabel::OBMessageHandler""'"); }
     if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::obErrorLog""' of type '""OpenBabel::OBMessageHandler""'"); }
     else { OpenBabel::obErrorLog = *(reinterpret_cast< OpenBabel::OBMessageHandler * >(argp)); }  }  return _val; fail:
  return Qnil; }
swig_class SwigClassObLogBuf;

SWIGINTERN void
free_OpenBabel_obLogBuf(OpenBabel::obLogBuf *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_ObLogBuf_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_ObLogBuf_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__obLogBuf);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_ObLogBuf(int argc, VALUE *argv, VALUE self) { OpenBabel::obLogBuf *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::obLogBuf *)new OpenBabel::obLogBuf(); DATA_PTR(self) = result; return self; fail: return Qnil; }
swig_class SwigClassOBFormat;

SWIGINTERN VALUE _wrap_OBFormat_default(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFormat **result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFormat **) &OpenBabel::OBFormat::Default();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_OpenBabel__OBFormat, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_find_type(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBFormat::FindType", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = (OpenBabel::OBFormat *)OpenBabel::OBFormat::FindType((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_type_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","TypeID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (char *)(arg1)->TypeID();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_read_molecule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","ReadMolecule", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","ReadMolecule", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","ReadMolecule", 3, argv[1] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3); result = (bool)(arg1)->ReadMolecule(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_read_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","ReadChemObject", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","ReadChemObject", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2); result = (bool)(arg1)->ReadChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_write_molecule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","WriteMolecule", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","WriteMolecule", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","WriteMolecule", 3, argv[1] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3); result = (bool)(arg1)->WriteMolecule(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_write_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","WriteChemObject", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","WriteChemObject", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2); result = (bool)(arg1)->WriteChemObject(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_target_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","TargetClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (char *)(arg1)->TargetClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::type_info *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","GetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (std::type_info *) &(arg1)->GetType();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__type_info, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_specification_url(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","SpecificationURL", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (char *)(arg1)->SpecificationURL();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_get_mimetype(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","GetMIMEType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (char *)(arg1)->GetMIMEType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","Flags", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (unsigned int)(arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_skip_objects(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; int arg2 ;
  OpenBabel::OBConversion *arg3 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","SkipObjects", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SkipObjects", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SkipObjects", 3, argv[1] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBConversion * >(argp3); result = (int)(arg1)->SkipObjects(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_make_new_instance(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBFormat *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","MakeNewInstance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); result = (OpenBabel::OBFormat *)(arg1)->MakeNewInstance();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_register_format__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; char *arg2 = (char *) 0 ; char *arg3 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","RegisterFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","RegisterFormat", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","RegisterFormat", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (int)(arg1)->RegisterFormat((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_register_format__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","RegisterFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","RegisterFormat", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (int)(arg1)->RegisterFormat((char const *)arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_register_format(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBFormat_register_format__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBFormat_register_format__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBFormat.register_format", 
  "    int OBFormat.register_format(char const *ID, char const *MIME)\n" "    int OBFormat.register_format(char const *ID)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_display__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; std::string *arg2 = 0 ; char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ;
  int alloc3 = 0 ; int res4 ; char *buf4 = 0 ; int alloc4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","Display", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Display", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Display", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Display", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","Display", 4, argv[2] )); } 
  arg4 = reinterpret_cast< char * >(buf4); result = (bool)(arg1)->Display(*arg2,(char const *)arg3,(char const *)arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return vresult; fail: if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_display__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFormat *arg1 = (OpenBabel::OBFormat *) 0 ; std::string *arg2 = 0 ; char *arg3 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","Display", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFormat * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Display", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Display", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Display", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (bool)(arg1)->Display(*arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_display(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    return _wrap_OBFormat_display__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBFormat_display__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "OBFormat.display", 
  "    bool OBFormat.display(std::string &txt, char const *param, char const *ID)\n"
  "    bool OBFormat.display(std::string &txt, char const *param)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBFormat_format_from_mime(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBFormat::FormatFromMIME", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBFormat::FormatFromMIME((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFormat(OpenBabel::OBFormat *arg1) {
    delete arg1;
}

swig_class SwigClassOBConversion;

SWIGINTERN VALUE _wrap_new_OBConversion__SWIG_0(int argc, VALUE *argv, VALUE self) { std::istream *arg1 = (std::istream *) 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBConversion *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream *","OpenBabel::OBConversion", 1, argv[0] ));  }
   arg1 = reinterpret_cast< std::istream * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","OpenBabel::OBConversion", 2, argv[1] ));  }
   arg2 = reinterpret_cast< std::ostream * >(argp2); result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(arg1,arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBConversion__SWIG_1(int argc, VALUE *argv, VALUE self) { std::istream *arg1 = (std::istream *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBConversion *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::istream *","OpenBabel::OBConversion", 1, argv[0] ));  }
   arg1 = reinterpret_cast< std::istream * >(argp1); result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBConversion__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBConversion *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBConversion_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBConversion_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBConversion);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBConversion__SWIG_3(int argc, VALUE *argv, VALUE self) { OpenBabel::OBConversion *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBConversion *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBConversion,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const &","OpenBabel::OBConversion", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBConversion const &","OpenBabel::OBConversion", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBConversion *)new OpenBabel::OBConversion((OpenBabel::OBConversion const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBConversion(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBConversion__SWIG_2(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, 0); _v = SWIG_CheckState(res);}  if (!_v) goto check_2;
    return _wrap_new_OBConversion__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBConversion__SWIG_3(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_OBConversion__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "OBConversion.new", 
  "    OBConversion.new(std::istream *is, std::ostream *os)\n" "    OBConversion.new(std::istream *is)\n"
  "    OBConversion.new()\n" "    OBConversion.new(OpenBabel::OBConversion const &o)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBConversion(OpenBabel::OBConversion *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBConversion_register_format__SWIG_0(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ; char *arg3 = (char *) 0 ; int res1 ; char *buf1 = 0 ; int alloc1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBConversion::RegisterFormat", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","OpenBabel::OBConversion::RegisterFormat", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[2], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBConversion::RegisterFormat", 3, argv[2] )); }
   arg3 = reinterpret_cast< char * >(buf3);
  result = (int)OpenBabel::OBConversion::RegisterFormat((char const *)arg1,arg2,(char const *)arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_register_format__SWIG_1(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ; int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBConversion::RegisterFormat", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","OpenBabel::OBConversion::RegisterFormat", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  result = (int)OpenBabel::OBConversion::RegisterFormat((char const *)arg1,arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_register_format(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs; if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 2) {
    return _wrap_OBConversion_register_format__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_register_format__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBConversion.register_format", 
  "    int OBConversion.register_format(char const *ID, OpenBabel::OBFormat *pFormat, char const *MIME)\n"
  "    int OBConversion.register_format(char const *ID, OpenBabel::OBFormat *pFormat)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_find_format(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBConversion::FindFormat", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FindFormat((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_format_from_ext(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBConversion::FormatFromExt", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FormatFromExt((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_format_from_mime(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBConversion::FormatFromMIME", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::FormatFromMIME((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_next_format(int argc, VALUE *argv, VALUE self) { OpenBabel::Formatpos *arg1 = 0 ;
  char **arg2 = 0 ; OpenBabel::OBFormat **arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ;
  int alloc2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBPlugin__PluginMapType__const_iterator,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::Formatpos &","OpenBabel::OBConversion::GetNextFormat", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::Formatpos &","OpenBabel::OBConversion::GetNextFormat", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::Formatpos * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *&","OpenBabel::OBConversion::GetNextFormat", 2, argv[1] )); }
   arg2 = &buf2; res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_p_OpenBabel__OBFormat,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *&","OpenBabel::OBConversion::GetNextFormat", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBFormat *&","OpenBabel::OBConversion::GetNextFormat", 3, argv[2])); }
   arg3 = reinterpret_cast< OpenBabel::OBFormat ** >(argp3);
  result = (bool)OpenBabel::OBConversion::GetNextFormat(*arg1,(char const *&)*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_description(int argc, VALUE *argv, VALUE self) { char *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (char *)OpenBabel::OBConversion::Description(); vresult = SWIG_FromCharPtr((const char *)result); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_in_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::istream *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetInStream", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (std::istream *)((OpenBabel::OBConversion const *)arg1)->GetInStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__istream, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_out_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::ostream *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetOutStream", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (std::ostream *)((OpenBabel::OBConversion const *)arg1)->GetOutStream();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__ostream, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; std::istream *arg2 = (std::istream *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetInStream", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream *","SetInStream", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::istream * >(argp2); (arg1)->SetInStream(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_out_stream(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; std::ostream *arg2 = (std::ostream *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOutStream", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","SetOutStream", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::ostream * >(argp2); (arg1)->SetOutStream(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_and_out_formats__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ; char *arg3 = (char *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetInAndOutFormats", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetInAndOutFormats", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","SetInAndOutFormats", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (bool)(arg1)->SetInAndOutFormats((char const *)arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_and_out_formats__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  OpenBabel::OBFormat *arg3 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetInAndOutFormats", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","SetInAndOutFormats", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","SetInAndOutFormats", 3, argv[1] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBFormat * >(argp3); result = (bool)(arg1)->SetInAndOutFormats(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_and_out_formats(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBConversion_set_in_and_out_formats__SWIG_1(nargs, args, self);}  check_1:
  if (argc == 3) { return _wrap_OBConversion_set_in_and_out_formats__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.set_in_and_out_formats", 
  "    bool OBConversion.set_in_and_out_formats(char const *inID, char const *outID)\n"
  "    bool OBConversion.set_in_and_out_formats(OpenBabel::OBFormat *pIn, OpenBabel::OBFormat *pOut)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_format__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetInFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetInFormat", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->SetInFormat((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_format__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetInFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","SetInFormat", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2); result = (bool)(arg1)->SetInFormat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_in_format(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBConversion_set_in_format__SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBConversion_set_in_format__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBConversion.set_in_format",  "    bool OBConversion.set_in_format(char const *inID)\n"
  "    bool OBConversion.set_in_format(OpenBabel::OBFormat *pIn)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_out_format__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOutFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetOutFormat", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->SetOutFormat((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_out_format__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOutFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","SetOutFormat", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2); result = (bool)(arg1)->SetOutFormat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_out_format(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBFormat, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBConversion_set_out_format__SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBConversion_set_out_format__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBConversion.set_out_format", 
  "    bool OBConversion.set_out_format(char const *outID)\n"
  "    bool OBConversion.set_out_format(OpenBabel::OBFormat *pOut)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_in_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetInFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBFormat *)((OpenBabel::OBConversion const *)arg1)->GetInFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_out_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBFormat *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetOutFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBFormat *)((OpenBabel::OBConversion const *)arg1)->GetOutFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_in_filename(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetInFilename", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = ((OpenBabel::OBConversion const *)arg1)->GetInFilename();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_in_pos(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::streampos result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetInPos", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = ((OpenBabel::OBConversion const *)arg1)->GetInPos();
  vresult = SWIG_NewPointerObj((new std::streampos(static_cast< const std::streampos& >(result))), SWIGTYPE_p_std__streampos, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_in_len(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; size_t result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetInLen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = ((OpenBabel::OBConversion const *)arg1)->GetInLen();
  vresult = SWIG_From_size_t(static_cast< size_t >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_title(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetTitle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (char *)((OpenBabel::OBConversion const *)arg1)->GetTitle(); vresult = SWIG_FromCharPtr((const char *)result);
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_aux_conv(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBConversion *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetAuxConv", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (OpenBabel::OBConversion *)((OpenBabel::OBConversion const *)arg1)->GetAuxConv();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_aux_conv(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetAuxConv", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetAuxConv", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2); (arg1)->SetAuxConv(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_is_option__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  int val3 ; int ecode3 = 0 ; char *result = 0 ; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","IsOption", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","IsOption", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","IsOption", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  result = (char *)(arg1)->IsOption((char const *)arg2,arg3); vresult = SWIG_FromCharPtr((const char *)result);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_is_option__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; char *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","IsOption", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","IsOption", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (char *)(arg1)->IsOption((char const *)arg2);
  vresult = SWIG_FromCharPtr((const char *)result); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_is_option(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_is_option__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_is_option__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.is_option", 
  "    char const * OBConversion.is_option(char const *opt, OpenBabel::OBConversion::Option_type opttyp)\n"
  "    char const * OBConversion.is_option(char const *opt)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_options(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBConversion::Option_type arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","GetOptions", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","GetOptions", 2, argv[0] )); }
    arg2 = static_cast< OpenBabel::OBConversion::Option_type >(val2);
  result = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *)(arg1)->GetOptions(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_add_option__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ; char *arg4 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; int val3 ; int ecode3 = 0 ; int res4 ; char *buf4 = 0 ; int alloc4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","AddOption", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","AddOption", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","AddOption", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","AddOption", 4, argv[2] )); } 
  arg4 = reinterpret_cast< char * >(buf4); (arg1)->AddOption((char const *)arg2,arg3,(char const *)arg4);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_add_option__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","AddOption", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","AddOption", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","AddOption", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3); (arg1)->AddOption((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_add_option__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","AddOption", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","AddOption", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->AddOption((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_add_option(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_add_option__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_add_option__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBConversion_add_option__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBConversion.add_option", 
  "    void OBConversion.add_option(char const *opt, OpenBabel::OBConversion::Option_type opttyp, char const *txt)\n"
  "    void OBConversion.add_option(char const *opt, OpenBabel::OBConversion::Option_type opttyp)\n"
  "    void OBConversion.add_option(char const *opt)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_remove_option(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  int val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","RemoveOption", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","RemoveOption", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","RemoveOption", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3);
  result = (bool)(arg1)->RemoveOption((char const *)arg2,arg3); vresult = SWIG_From_bool(static_cast< bool >(result));
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_options(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; char *arg2 = (char *) 0 ;
  OpenBabel::OBConversion::Option_type arg3 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ;
  int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOptions", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetOptions", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","SetOptions", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3); (arg1)->SetOptions((char const *)arg2,arg3);
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_register_option_param__SWIG_0(int argc, VALUE *argv, VALUE self) { std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ; int arg3 ; OpenBabel::OBConversion::Option_type arg4 ;
  void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenBabel::OBConversion::RegisterOptionParam", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; } 
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","OpenBabel::OBConversion::RegisterOptionParam", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBConversion::RegisterOptionParam", 3, argv[2] )); }
    arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","OpenBabel::OBConversion::RegisterOptionParam", 4, argv[3] )); }
    arg4 = static_cast< OpenBabel::OBConversion::Option_type >(val4);
  OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_register_option_param__SWIG_1(int argc, VALUE *argv, VALUE self) { std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ; int arg3 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ;
  int ecode3 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;}  {
    std::string *ptr = (std::string *)0; int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenBabel::OBConversion::RegisterOptionParam", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; } 
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","OpenBabel::OBConversion::RegisterOptionParam", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBConversion::RegisterOptionParam", 3, argv[2] )); }
    arg3 = static_cast< int >(val3); OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_register_option_param__SWIG_2(int argc, VALUE *argv, VALUE self) { std::string arg1 ;
  OpenBabel::OBFormat *arg2 = (OpenBabel::OBFormat *) 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenBabel::OBConversion::RegisterOptionParam", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; } 
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","OpenBabel::OBConversion::RegisterOptionParam", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBFormat * >(argp2); OpenBabel::OBConversion::RegisterOptionParam(arg1,arg2);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_register_option_param(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs; if (argc > 4) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 2) {
    return _wrap_OBConversion_register_option_param__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_register_option_param__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBConversion_register_option_param__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.register_option_param", 
  "    void OBConversion.register_option_param(std::string name, OpenBabel::OBFormat *pFormat, int numberParams, OpenBabel::OBConversion::Option_type typ)\n"
  "    void OBConversion.register_option_param(std::string name, OpenBabel::OBFormat *pFormat, int numberParams)\n"
  "    void OBConversion.register_option_param(std::string name, OpenBabel::OBFormat *pFormat)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_option_params(int argc, VALUE *argv, VALUE self) { std::string arg1 ;
  OpenBabel::OBConversion::Option_type arg2 ; int val2 ; int ecode2 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  {
    std::string *ptr = (std::string *)0; int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenBabel::OBConversion::GetOptionParams", 1, argv[0] ));  }
     arg1 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  ecode2 = SWIG_AsVal_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","OpenBabel::OBConversion::GetOptionParams", 2, argv[1] )); }
    arg2 = static_cast< OpenBabel::OBConversion::Option_type >(val2);
  result = (int)OpenBabel::OBConversion::GetOptionParams(arg1,arg2); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_copy_options__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBConversion::Option_type arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","CopyOptions", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","CopyOptions", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "OpenBabel::OBConversion::Option_type","CopyOptions", 3, argv[1] )); }
    arg3 = static_cast< OpenBabel::OBConversion::Option_type >(val3); (arg1)->CopyOptions(arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_copy_options__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  OpenBabel::OBConversion *arg2 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","CopyOptions", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","CopyOptions", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBConversion * >(argp2); (arg1)->CopyOptions(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_copy_options(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_copy_options__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_copy_options__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.copy_options", 
  "    void OBConversion.copy_options(OpenBabel::OBConversion *pSourceConv, OpenBabel::OBConversion::Option_type typ)\n"
  "    void OBConversion.copy_options(OpenBabel::OBConversion *pSourceConv)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_supported_input_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","GetSupportedInputFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (arg1)->GetSupportedInputFormat();
  vresult = swig::from(static_cast< std::vector<std::string,std::allocator< std::string > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_supported_output_format(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","GetSupportedOutputFormat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (arg1)->GetSupportedOutputFormat();
  vresult = swig::from(static_cast< std::vector<std::string,std::allocator< std::string > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_convert__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; std::istream *arg2 = (std::istream *) 0 ;
  std::ostream *arg3 = (std::ostream *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","Convert", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream *","Convert", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::istream * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::ostream *","Convert", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< std::ostream * >(argp3); result = (int)(arg1)->Convert(arg2,arg3);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_convert__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","Convert", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (int)(arg1)->Convert();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_convert(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBConversion_convert__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_convert__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.convert", 
  "    int OBConversion.convert(std::istream *is, std::ostream *os)\n" "    int OBConversion.convert()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_full_convert(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ; std::string *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","FullConvert", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::string,std::allocator< std::string > > &","FullConvert", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string,std::allocator< std::string > > &","FullConvert", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string &","FullConvert", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","FullConvert", 3, argv[1])); }
   arg3 = reinterpret_cast< std::string * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t,  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "std::vector< std::string,std::allocator< std::string > > &","FullConvert", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::string,std::allocator< std::string > > &","FullConvert", 4, argv[2])); }
   arg4 = reinterpret_cast< std::vector< std::string,std::allocator< std::string > > * >(argp4);
  result = (int)(arg1)->FullConvert(*arg2,*arg3,*arg4); vresult = SWIG_From_int(static_cast< int >(result)); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_add_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","AddChemObject", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","AddChemObject", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (int)(arg1)->AddChemObject(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_chem_object(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","GetChemObject", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (OpenBabel::OBBase *)(arg1)->GetChemObject();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_is_last(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","IsLast", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (bool)(arg1)->IsLast();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_is_first_input(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","IsFirstInput", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (bool)(arg1)->IsFirstInput();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_first_input__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetFirstInput", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SetFirstInput", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->SetFirstInput(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_first_input__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetFirstInput", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); (arg1)->SetFirstInput(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_first_input(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBConversion_set_first_input__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBConversion_set_first_input__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBConversion.set_first_input",  "    void OBConversion.set_first_input(bool b)\n"
  "    void OBConversion.set_first_input()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_output_index(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion const *","GetOutputIndex", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  result = (int)((OpenBabel::OBConversion const *)arg1)->GetOutputIndex(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_output_index(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOutputIndex", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetOutputIndex", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetOutputIndex(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_more_files_to_come(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetMoreFilesToCome", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); (arg1)->SetMoreFilesToCome(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_one_object_only__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOneObjectOnly", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SetOneObjectOnly", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->SetOneObjectOnly(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_one_object_only__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetOneObjectOnly", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); (arg1)->SetOneObjectOnly(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_one_object_only(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBConversion_set_one_object_only__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBConversion_set_one_object_only__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBConversion.set_one_object_only", 
  "    void OBConversion.set_one_object_only(bool b)\n" "    void OBConversion.set_one_object_only()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_set_last(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","SetLast", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SetLast", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->SetLast(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_is_last_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","IsLastFile", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); result = (bool)(arg1)->IsLastFile();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_get_default_format(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFormat *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFormat *)OpenBabel::OBConversion::GetDefaultFormat();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::ostream *arg3 = (std::ostream *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","Write", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Write", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__ostream, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::ostream *","Write", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< std::ostream * >(argp3); result = (bool)(arg1)->Write(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","Write", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Write", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (bool)(arg1)->Write(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_write__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_write__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.write", 
  "    bool OBConversion.write(OpenBabel::OBBase *pOb, std::ostream *pout)\n"
  "    bool OBConversion.write(OpenBabel::OBBase *pOb)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write_string__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  bool arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","WriteString", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","WriteString", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","WriteString", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); result = (arg1)->WriteString(arg2,arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write_string__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; std::string result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","WriteString", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","WriteString", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (arg1)->WriteString(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write_string(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_write_string__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_write_string__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.write_string", 
  "    std::string OBConversion.write_string(OpenBabel::OBBase *pOb, bool trimWhitespace)\n"
  "    std::string OBConversion.write_string(OpenBabel::OBBase *pOb)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_write_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","WriteFile", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","WriteFile", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","WriteFile", 3, argv[1] ));  }
     arg3 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  result = (bool)(arg1)->WriteFile(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_close_out_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","CloseOutFile", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); (arg1)->CloseOutFile(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_read__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::istream *arg3 = (std::istream *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","Read", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Read", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::istream *","Read", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< std::istream * >(argp3); result = (bool)(arg1)->Read(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_read__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","Read", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Read", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (bool)(arg1)->Read(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_read(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_read__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_read__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.read", 
  "    bool OBConversion.read(OpenBabel::OBBase *pOb, std::istream *pin)\n"
  "    bool OBConversion.read(OpenBabel::OBBase *pOb)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_read_string(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","ReadString", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","ReadString", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","ReadString", 3, argv[1] ));  }
     arg3 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  result = (bool)(arg1)->ReadString(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_read_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","ReadFile", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","ReadFile", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","ReadFile", 3, argv[1] ));  }
     arg3 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  result = (bool)(arg1)->ReadFile(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_open_in_and_out_files(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; std::string arg2 ; std::string arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","OpenInAndOutFiles", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenInAndOutFiles", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OpenInAndOutFiles", 3, argv[1] ));  }
     arg3 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  result = (bool)(arg1)->OpenInAndOutFiles(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_report_number_converted__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; int arg2 ;
  OpenBabel::OBFormat *arg3 = (OpenBabel::OBFormat *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","ReportNumberConverted", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ReportNumberConverted", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBFormat, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBFormat *","ReportNumberConverted", 3, argv[1] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBFormat * >(argp3); (arg1)->ReportNumberConverted(arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_report_number_converted__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBConversion *arg1 = (OpenBabel::OBConversion *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBConversion, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBConversion *","ReportNumberConverted", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBConversion * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ReportNumberConverted", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->ReportNumberConverted(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBConversion_report_number_converted(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBConversion_report_number_converted__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBConversion_report_number_converted__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBConversion.report_number_converted", 
  "    void OBConversion.report_number_converted(int count, OpenBabel::OBFormat *pFormat)\n"
  "    void OBConversion.report_number_converted(int count)\n"); return Qnil; }
swig_class SwigClassOBResidue;

SWIGINTERN VALUE _wrap_new_OBResidue__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBResidue *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBResidue *)new OpenBabel::OBResidue(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBResidue_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBResidue_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidue);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBResidue__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBResidue *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::OBResidue *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidue,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const &","OpenBabel::OBResidue", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBResidue const &","OpenBabel::OBResidue", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (OpenBabel::OBResidue *)new OpenBabel::OBResidue((OpenBabel::OBResidue const &)*arg1); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBResidue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBResidue__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBResidue__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "OBResidue.new", 
  "    OBResidue.new()\n" "    OBResidue.new(OpenBabel::OBResidue const &)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBResidue(OpenBabel::OBResidue *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBResidue_add_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","AddAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->AddAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_insert_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","InsertAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","InsertAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->InsertAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_remove_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","RemoveAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","RemoveAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->RemoveAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetName", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetName", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetName", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetName((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_num__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetNum", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->SetNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_num__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","SetNum", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_num(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBResidue_set_num__SWIG_0(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBResidue_set_num__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBResidue.set_num",  "    void OBResidue.set_num(unsigned int const resnum)\n"
  "    void OBResidue.set_num(std::string const resnum)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; char arg2 ; void *argp1 = 0 ; int res1 = 0 ; char val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetChain", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_char(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","SetChain", 2, argv[0] )); }  
  arg2 = static_cast< char >(val2); (arg1)->SetChain(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetChainNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetChainNum", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->SetChainNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 = SWIG_OLDOBJ ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetAtomID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtomID", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); { std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","SetAtomID", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetAtomID", 3, argv[1])); }
     arg3 = ptr; }  (arg1)->SetAtomID(arg2,(std::string const &)*arg3); if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; fail:
  if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; bool arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetHetAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetHetAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","SetHetAtom", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); (arg1)->SetHetAtom(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_set_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetSerialNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetSerialNum", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SetSerialNum", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); (arg1)->SetSerialNum(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetName", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = ((OpenBabel::OBResidue const *)arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","GetNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = (unsigned int)(arg1)->GetNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_num_string(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","GetNumString", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = (arg1)->GetNumString();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetNumAtoms", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetNumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetChain", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = (char)((OpenBabel::OBResidue const *)arg1)->GetChain();
  vresult = SWIG_From_char(static_cast< char >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetChainNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetChainNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_res_key(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetResKey", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetResKey();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetAtoms", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = ((OpenBabel::OBResidue const *)arg1)->GetAtoms();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >(static_cast< const std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_bonds__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > > result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetBonds", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = ((OpenBabel::OBResidue const *)arg1)->GetBonds(arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >(static_cast< const std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_bonds__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = ((OpenBabel::OBResidue const *)arg1)->GetBonds();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >(static_cast< const std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_bonds(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidue_get_bonds__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidue_get_bonds__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBResidue.get_bonds", 
  "    std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > OBResidue.get_bonds(bool exterior)\n"
  "    std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > OBResidue.get_bonds()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; std::string result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetAtomID", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAtomID", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = ((OpenBabel::OBResidue const *)arg1)->GetAtomID(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetSerialNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetSerialNum", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (unsigned int)((OpenBabel::OBResidue const *)arg1)->GetSerialNum(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_amino_acid_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetAminoAcidProperty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAminoAcidProperty", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)((OpenBabel::OBResidue const *)arg1)->GetAminoAcidProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_atom_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; int arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetAtomProperty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAtomProperty", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetAtomProperty", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (bool)((OpenBabel::OBResidue const *)arg1)->GetAtomProperty(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_get_residue_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","GetResidueProperty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetResidueProperty", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)((OpenBabel::OBResidue const *)arg1)->GetResidueProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_is_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","IsHetAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHetAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)((OpenBabel::OBResidue const *)arg1)->IsHetAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_is_residue_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue const *","IsResidueType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsResidueType", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)((OpenBabel::OBResidue const *)arg1)->IsResidueType(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_begin_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","BeginAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = (arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_end_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","EndAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1); result = (arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_begin_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","BeginAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","BeginAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","BeginAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidue_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","NextAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","NextAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","NextAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_Residue_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(OpenBabel::Residue), SWIGTYPE_p_a_4__char,  0 ); return _val; }
SWIGINTERN VALUE _wrap_Residue_set(VALUE self, VALUE _val) { { char (*inp)[4] = 0;
    int res = SWIG_ConvertPtr(_val, SWIG_as_voidptrptr(&inp), SWIGTYPE_p_a_4__char,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'"); }
     else if (inp) { size_t ii = 0; for (; ii < (size_t)100; ++ii) { if (inp[ii]) { size_t jj = 0;
          for (; jj < (size_t)4; ++jj) OpenBabel::Residue[ii][jj] = inp[ii][jj]; }  else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'"); }
         }  }  else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::Residue""' of type '""char [100][4]""'"); }
     }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ElemDesc_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(OpenBabel::ElemDesc), SWIGTYPE_p_a_4__char,  0 ); return _val; }
SWIGINTERN VALUE _wrap_ElemDesc_set(VALUE self, VALUE _val) { { char (*inp)[4] = 0;
    int res = SWIG_ConvertPtr(_val, SWIG_as_voidptrptr(&inp), SWIGTYPE_p_a_4__char,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'"); }
     else if (inp) { size_t ii = 0; for (; ii < (size_t)1024; ++ii) { if (inp[ii]) { size_t jj = 0;
          for (; jj < (size_t)4; ++jj) OpenBabel::ElemDesc[ii][jj] = inp[ii][jj]; }  else {
          SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'"); }
         }  }  else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ElemDesc""' of type '""char [1024][4]""'"); }
     }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ResNo_get(VALUE self) { VALUE _val;
  _val = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(OpenBabel::ResNo)); return _val; }
SWIGINTERN VALUE _wrap_ResNo_set(VALUE self, VALUE _val) { { unsigned int val; int res = SWIG_AsVal_unsigned_SS_int(_val, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ResNo""' of type '""unsigned int""'"); } 
    OpenBabel::ResNo = static_cast< unsigned int >(val); }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ElemNo_get(VALUE self) { VALUE _val;
  _val = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(OpenBabel::ElemNo)); return _val; }
SWIGINTERN VALUE _wrap_ElemNo_set(VALUE self, VALUE _val) { { unsigned int val;
    int res = SWIG_AsVal_unsigned_SS_int(_val, &val); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ElemNo""' of type '""unsigned int""'"); } 
    OpenBabel::ElemNo = static_cast< unsigned int >(val); }  return _val; fail: return Qnil; }
swig_class SwigClassOBInternalCoord;

SWIGINTERN VALUE _wrap_OBInternalCoord__a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","_a", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->_a = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->_a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","_b", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->_b = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->_b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","_c", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->_c = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->_c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__dst_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_dst", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","_dst", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->_dst = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__dst_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_dst", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); result = (double) ((arg1)->_dst);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__ang_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_ang", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","_ang", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->_ang = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__ang_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_ang", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); result = (double) ((arg1)->_ang);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__tor_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_tor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","_tor", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->_tor = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBInternalCoord__tor_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBInternalCoord *arg1 = (OpenBabel::OBInternalCoord *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBInternalCoord *","_tor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBInternalCoord * >(argp1); result = (double) ((arg1)->_tor);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; double arg4 ; double arg5 ; double arg6 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double val4 ; int ecode4 = 0 ; double val5 ;
  int ecode5 = 0 ; double val6 ; int ecode6 = 0 ; OpenBabel::OBInternalCoord *result = 0 ; if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 3, argv[2] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); ecode4 = SWIG_AsVal_double(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","OpenBabel::OBInternalCoord", 4, argv[3] )); }
    arg4 = static_cast< double >(val4); ecode5 = SWIG_AsVal_double(argv[4], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","OpenBabel::OBInternalCoord", 5, argv[4] )); }
    arg5 = static_cast< double >(val5); ecode6 = SWIG_AsVal_double(argv[5], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "double","OpenBabel::OBInternalCoord", 6, argv[5] )); }
    arg6 = static_cast< double >(val6);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4,arg5,arg6); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; double arg4 ; double arg5 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double val4 ; int ecode4 = 0 ; double val5 ;
  int ecode5 = 0 ; OpenBabel::OBInternalCoord *result = 0 ; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 3, argv[2] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); ecode4 = SWIG_AsVal_double(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","OpenBabel::OBInternalCoord", 4, argv[3] )); }
    arg4 = static_cast< double >(val4); ecode5 = SWIG_AsVal_double(argv[4], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","OpenBabel::OBInternalCoord", 5, argv[4] )); }
    arg5 = static_cast< double >(val5);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4,arg5); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; double arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double val4 ; int ecode4 = 0 ; OpenBabel::OBInternalCoord *result = 0 ;
  if ((argc < 4) || (argc > 4)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 3, argv[2] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); ecode4 = SWIG_AsVal_double(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","OpenBabel::OBInternalCoord", 4, argv[3] )); }
    arg4 = static_cast< double >(val4);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3,arg4); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; OpenBabel::OBInternalCoord *result = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 3, argv[2] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2,arg3); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBInternalCoord *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1,arg2); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_5(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBInternalCoord *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBInternalCoord", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBInternalCoord_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBInternalCoord_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBInternalCoord);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord__SWIG_6(int argc, VALUE *argv, VALUE self) { OpenBabel::OBInternalCoord *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBInternalCoord *)new OpenBabel::OBInternalCoord(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBInternalCoord(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6]; int ii; argc = nargs;
  if (argc > 6) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBInternalCoord__SWIG_6(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBInternalCoord__SWIG_5(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_OBInternalCoord__SWIG_4(nargs, args, self);}  if (argc == 3) {
    return _wrap_new_OBInternalCoord__SWIG_3(nargs, args, self);}  if (argc == 4) {
    return _wrap_new_OBInternalCoord__SWIG_2(nargs, args, self);}  if (argc == 5) {
    return _wrap_new_OBInternalCoord__SWIG_1(nargs, args, self);}  if (argc == 6) {
    return _wrap_new_OBInternalCoord__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBInternalCoord.new", 
  "    OBInternalCoord.new(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b, OpenBabel::OBAtom *c, double dst, double ang, double tor)\n"
  "    OBInternalCoord.new(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b, OpenBabel::OBAtom *c, double dst, double ang)\n"
  "    OBInternalCoord.new(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b, OpenBabel::OBAtom *c, double dst)\n"
  "    OBInternalCoord.new(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b, OpenBabel::OBAtom *c)\n"
  "    OBInternalCoord.new(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b)\n" "    OBInternalCoord.new(OpenBabel::OBAtom *a)\n"
  "    OBInternalCoord.new()\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBInternalCoord(OpenBabel::OBInternalCoord *arg1) {
    delete arg1;
}

swig_class SwigClassOBAtom;

SWIGINTERN VALUE _wrap_OBAtom_Visit_set(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_Visit_get(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool) ((arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBAtom_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBAtom_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtom);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBAtom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBAtom *)new OpenBabel::OBAtom(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBAtom(OpenBabel::OBAtom *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBAtom_duplicate(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Duplicate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Duplicate", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->Duplicate(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_idx(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_hyb(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetHyb", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHyb", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetHyb(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtomicNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetAtomicNum", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetAtomicNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetIsotope", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetIsotope", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->SetIsotope(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetImplicitValence", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetImplicitValence(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IncrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->IncrementImplicitValence(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DecrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->DecrementImplicitValence(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetFormalCharge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetFormalCharge", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetFormalCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; short arg2 ; void *argp1 = 0 ; int res1 = 0 ; short val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_short(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","SetSpinMultiplicity", 2, argv[0] )); }  
  arg2 = static_cast< short >(val2); (arg1)->SetSpinMultiplicity(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetType((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetType", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetType", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetType((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBAtom_set_type__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBAtom_set_type__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBAtom.set_type", 
  "    void OBAtom.set_type(char const *type)\n" "    void OBAtom.set_type(std::string const &type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetPartialCharge", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetPartialCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); (arg1)->SetVector((OpenBabel::vector3 const &)*arg2); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; double arg2 ; double arg3 ; double arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetVector", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","SetVector", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (arg1)->SetVector(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; double **arg2 = (double **) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetCoordPtr", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double **","SetCoordPtr", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double ** >(argp2); (arg1)->SetCoordPtr(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetVector(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtom_set_vector__SWIG_2(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtom_set_vector__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBAtom_set_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBAtom.set_vector",  "    void OBAtom.set_vector(OpenBabel::vector3 const &v)\n"
  "    void OBAtom.set_vector(double const x, double const y, double const z)\n" "    void OBAtom.set_vector()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (arg1)->SetResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetParent", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAromatic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","UnsetAromatic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetClockwiseStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAntiClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetAntiClockwiseStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetPositiveStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetNegativeStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","UnsetStereo", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->UnsetStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetInRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetChiral", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->SetChiral(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","ClearCoordPtr", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->ClearCoordPtr(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (int)((OpenBabel::OBAtom const *)arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned short result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned short)((OpenBabel::OBAtom const *)arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (int)((OpenBabel::OBAtom const *)arg1)->GetSpinMultiplicity(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetAtomicMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetExactMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_idx(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetCoordinateIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_cidx(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetCIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_hyb(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetHyb", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetHvyValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetHeteroValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_type(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (char *)(arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_x(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetX", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_y(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetY", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_z(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetZ", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_x(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","x", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_y(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","y", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_z(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","z", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)((OpenBabel::OBAtom const *)arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetCoordinate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double *)(arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (OpenBabel::vector3 *) &(arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::vector3 *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","GetVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::vector3 *) &((OpenBabel::OBAtom const *)arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtom_get_vector__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBAtom_get_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBAtom.get_vector",  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"
  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)(arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_residue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBResidue *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (OpenBabel::OBResidue *)(arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_residue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetResidue", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (OpenBabel::OBResidue *)(arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_residue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtom_get_residue__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtom_get_residue__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_residue",  "    OpenBabel::OBResidue * OBAtom.get_residue()\n"
  "    OpenBabel::OBResidue * OBAtom.get_residue(bool perception)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMol *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetParent", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::vector3 *arg2 = 0 ; double arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNewBondVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","GetNewBondVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); result = (bool)(arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBBond *)(arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNextAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (OpenBabel::OBAtom *)(arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","BeginBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_end_bonds(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","EndBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","BeginBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_next_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","NextBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","BeginNbrAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","NextNbrAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetDistance", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetDistance", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetDistance", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetDistance", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (double)(arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_distance(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBAtom_get_distance__SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBAtom_get_distance__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_distance",  "    double OBAtom.get_distance(int index)\n"
  "    double OBAtom.get_distance(OpenBabel::OBAtom *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAngle", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetAngle", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (double)(arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); result = (double)(arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_get_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 3) {
    int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBAtom_get_angle__SWIG_1(nargs, args, self);}  check_1: if (argc == 3) {
    return _wrap_OBAtom_get_angle__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "OBAtom.get_angle", 
  "    double OBAtom.get_angle(int b, int c)\n" "    double OBAtom.get_angle(OpenBabel::OBAtom *b, OpenBabel::OBAtom *c)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","NewResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->NewResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","AddResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (arg1)->AddResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DeleteResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->DeleteResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_add_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","AddBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); (arg1)->AddBond(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","InsertBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","InsertBond", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3); (arg1)->InsertBond(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DeleteBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DeleteBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","ClearBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->ClearBond(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HtoMethyl", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetHybAndGeom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHybAndGeom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","ForceNoH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->ForceNoH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasNoHForced", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_force_impl_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","ForceImplH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); (arg1)->ForceImplH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_impl_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasImplHForced", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasImplHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","CountFreeOxygens", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","ImplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ExplicitHydrogenCount", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtom_explicit_hydrogen_count__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtom_explicit_hydrogen_count__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.explicit_hydrogen_count", 
  "    unsigned int OBAtom.explicit_hydrogen_count(bool ExcludeIsotopes)\n"
  "    unsigned int OBAtom.explicit_hydrogen_count()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","MemberOfRingCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","MemberOfRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","CountRingBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SmallestBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)(arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AverageBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (double)(arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_bosum(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","BOSum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_kbosum(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","KBOSum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (unsigned int)((OpenBabel::OBAtom const *)arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHydrogen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_carbon(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsCarbon", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsNitrogen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_oxygen(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOxygen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_sulfur(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsSulfur", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsPhosphorus", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)((OpenBabel::OBAtom const *)arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","IsInRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)((OpenBabel::OBAtom const *)arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom const *","IsInRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsInRingSize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)((OpenBabel::OBAtom const *)arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHeteroatom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsNotCorH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsConnected", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsConnected", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneThree", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneThree", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneFour", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneFour", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsCarboxylOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsPhosphateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsSulfateOxygen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsNitroOxygen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsAmideNitrogen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsPolarHydrogen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsNonPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsAromaticNOxide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_chiral(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsChiral", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_axial(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsAxial", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsClockwise", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsAntiClockwise", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasChiralitySpecified", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasChiralVolume", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHbondAcceptor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHbondDonor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHbondDonorH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","HasAlphaBetaUnsat", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (bool)(arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtom_has_alpha_beta_unsat__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtom_has_alpha_beta_unsat__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.has_alpha_beta_unsat", 
  "    bool OBAtom.has_alpha_beta_unsat(bool includePandS)\n" "    bool OBAtom.has_alpha_beta_unsat()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasBondOfOrder", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasBondOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","CountBondsOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","CountBondsOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (int)(arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasNonSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasSingleBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasDoubleBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","HasAromaticBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); result = (bool)(arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtom_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","MatchesSMARTS", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","MatchesSMARTS", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
swig_class SwigClassOBBond;

SWIGINTERN VALUE _wrap_OBBond_Visit_set(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_Visit_get(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool) ((arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBBond_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBBond_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBBond);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBBond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBBond *)new OpenBabel::OBBond(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBBond(OpenBabel::OBBond *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBBond_set_idx(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_bo(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetBO", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetBO", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetBO(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetBondOrder", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetBondOrder", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetBondOrder(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_begin(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetBegin", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetBegin", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->SetBegin(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_end(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetEnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetEnd", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->SetEnd(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetParent", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_length__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; double arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetLength", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetLength", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetLength", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); (arg1)->SetLength(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_length__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetLength", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetLength", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetLength(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_length(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBBond_set_length__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBBond_set_length__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBBond.set_length", 
  "    void OBBond.set_length(OpenBabel::OBAtom *fixed, double length)\n" "    void OBBond.set_length(double length)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  int arg2 ; OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; int arg5 ;
  int arg6 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; int val5 ; int ecode5 = 0 ; int val6 ; int ecode6 = 0 ; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","Set", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Set", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Set", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Set", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","Set", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); ecode6 = SWIG_AsVal_int(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","Set", 6, argv[4] )); }  
  arg6 = static_cast< int >(val6); (arg1)->Set(arg2,arg3,arg4,arg5,arg6); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetKSingle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetKSingle(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetKDouble", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetKDouble(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetKTriple", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetKTriple(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetAromatic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_hash(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetHash(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_wedge(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetWedge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetWedge(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_up(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetUp(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_down(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetDown(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetInRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_set_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","SetClosure", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->SetClosure(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_unset_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","UnsetHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->UnsetHash(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_unset_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","UnsetWedge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->UnsetWedge(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_unset_up(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","UnsetUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->UnsetUp(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_unset_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","UnsetDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->UnsetDown(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","UnsetAromatic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_unset_kekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","UnsetKekule", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); (arg1)->UnsetKekule(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_idx(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_bo(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetBO", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetBondOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_flags(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetFlags", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_begin_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetBeginAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_end_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetEndAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (unsigned int)((OpenBabel::OBBond const *)arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_begin_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","GetBeginAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (OpenBabel::OBAtom *)(arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_begin_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetBeginAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBBond const *)arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_begin_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBBond_get_begin_atom__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBBond_get_begin_atom__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBBond.get_begin_atom",  "    OpenBabel::OBAtom const * OBBond.get_begin_atom()\n"
  "    OpenBabel::OBAtom const * OBBond.get_begin_atom()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_end_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","GetEndAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (OpenBabel::OBAtom *)(arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_end_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetEndAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBBond const *)arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_end_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBBond_get_end_atom__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBBond_get_end_atom__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBBond.get_end_atom",  "    OpenBabel::OBAtom const * OBBond.get_end_atom()\n"
  "    OpenBabel::OBAtom const * OBBond.get_end_atom()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","GetNbrAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNbrAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBAtom *)(arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMol *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","GetParent", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_equib_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetEquibLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (double)((OpenBabel::OBBond const *)arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","GetLength", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (double)((OpenBabel::OBBond const *)arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_get_nbr_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","GetNbrAtomIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNbrAtomIdx", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (unsigned int)(arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)((OpenBabel::OBBond const *)arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond const *","IsInRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)((OpenBabel::OBBond const *)arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_rotor(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsRotor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_amide(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsAmide", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_primary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsPrimaryAmide", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_secondary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsSecondaryAmide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_ester(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsEster", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_carbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsCarbonyl", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_single(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsSingle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_double(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsDouble", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_triple(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsTriple", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsKSingle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsKDouble", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsKTriple", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsClosure", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_up(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_down(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_wedge(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsWedge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_hash(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBBond_is_double_bond_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBond *arg1 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsDoubleBondGeometry", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBond * >(argp1); result = (bool)(arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBMol;

SWIGINTERN VALUE _wrap_new_OBMol__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMol *)new OpenBabel::OBMol(); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMol_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMol_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMol);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMol__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::OBMol *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const &","OpenBabel::OBMol", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol const &","OpenBabel::OBMol", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMol *)new OpenBabel::OBMol((OpenBabel::OBMol const &)*arg1); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMol(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMol__SWIG_0(nargs, args, self);}  if (argc == 1) { return _wrap_new_OBMol__SWIG_1(nargs, args, self);} 
  fail: Ruby_Format_OverloadedError( argc, 1, "OBMol.new",  "    OBMol.new()\n" "    OBMol.new(OpenBabel::OBMol const &)\n");
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMol(OpenBabel::OBMol *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMol_reserve_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","ReserveAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ReserveAtoms", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->ReserveAtoms(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_create_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","CreateAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (OpenBabel::OBAtom *)(arg1)->CreateAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_create_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","CreateBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (OpenBabel::OBBond *)(arg1)->CreateBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_create_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBResidue *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","CreateResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (OpenBabel::OBResidue *)(arg1)->CreateResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_destroy_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DestroyAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DestroyAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (arg1)->DestroyAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_destroy_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DestroyBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DestroyBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); (arg1)->DestroyBond(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_destroy_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DestroyResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","DestroyResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (arg1)->DestroyResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAtom,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom &","AddAtom", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAtom &","AddAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->AddAtom(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_insert_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","InsertAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBAtom,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom &","InsertAtom", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAtom &","InsertAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->InsertAtom(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ; int arg6 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; int val5 ; int ecode5 = 0 ;
  int val6 ; int ecode6 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddBond", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","AddBond", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","AddBond", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","AddBond", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); ecode6 = SWIG_AsVal_int(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","AddBond", 6, argv[4] )); }  
  arg6 = static_cast< int >(val6); result = (bool)(arg1)->AddBond(arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; int val5 ; int ecode5 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddBond", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","AddBond", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","AddBond", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","AddBond", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); result = (bool)(arg1)->AddBond(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_bond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; int arg3 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddBond", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","AddBond", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","AddBond", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); result = (bool)(arg1)->AddBond(arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_bond__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBBond *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBond,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond &","AddBond", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBond &","AddBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(arg1)->AddBond(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_bond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[7]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 7) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_OBMol_add_bond__SWIG_3(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBMol_add_bond__SWIG_2(nargs, args, self);}  if (argc == 5) {
    return _wrap_OBMol_add_bond__SWIG_1(nargs, args, self);}  if (argc == 6) {
    return _wrap_OBMol_add_bond__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 7, "OBMol.add_bond", 
  "    bool OBMol.add_bond(int beginIdx, int endIdx, int order, int flags, int insertpos)\n"
  "    bool OBMol.add_bond(int beginIdx, int endIdx, int order, int flags)\n"
  "    bool OBMol.add_bond(int beginIdx, int endIdx, int order)\n" "    bool OBMol.add_bond(OpenBabel::OBBond &)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_residue(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidue *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBResidue,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue &","AddResidue", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBResidue &","AddResidue", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); result = (bool)(arg1)->AddResidue(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_new_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NewAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (OpenBabel::OBAtom *)(arg1)->NewAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_new_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NewBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (OpenBabel::OBBond *)(arg1)->NewBond();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_new_residue(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NewResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (OpenBabel::OBResidue *)(arg1)->NewResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; bool arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DeleteAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","DeleteAtom", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); result = (bool)(arg1)->DeleteAtom(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DeleteAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->DeleteAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBMol_delete_atom__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_delete_atom__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBMol.delete_atom", 
  "    bool OBMol.delete_atom(OpenBabel::OBAtom *, bool destroyAtom)\n" "    bool OBMol.delete_atom(OpenBabel::OBAtom *)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; bool arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DeleteBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","DeleteBond", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); result = (bool)(arg1)->DeleteBond(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DeleteBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_bond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBMol_delete_bond__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_delete_bond__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBMol.delete_bond", 
  "    bool OBMol.delete_bond(OpenBabel::OBBond *, bool destroyBond)\n" "    bool OBMol.delete_bond(OpenBabel::OBBond *)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_residue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ; bool arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","DeleteResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","DeleteResidue", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); result = (bool)(arg1)->DeleteResidue(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_residue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","DeleteResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); result = (bool)(arg1)->DeleteResidue(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_residue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBMol_delete_residue__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_delete_residue__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBMol.delete_residue", 
  "    bool OBMol.delete_residue(OpenBabel::OBResidue *, bool destroyResidue)\n"
  "    bool OBMol.delete_residue(OpenBabel::OBResidue *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_modify(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginModify", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->BeginModify(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_end_modify__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","EndModify", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","EndModify", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->EndModify(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_end_modify__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","EndModify", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->EndModify(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_end_modify(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBMol_end_modify__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_end_modify__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBMol.end_modify", 
  "    void OBMol.end_modify(bool nukePerceivedData)\n" "    void OBMol.end_modify()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_mod(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetMod", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (int)(arg1)->GetMod();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_increment_mod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","IncrementMod", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->IncrementMod(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_decrement_mod(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DecrementMod", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->DecrementMod(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_flags(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetFlags", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (int)(arg1)->GetFlags();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_title__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  char *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetTitle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetTitle", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (char *)((OpenBabel::OBMol const *)arg1)->GetTitle(arg2);
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_title__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetTitle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (char *)((OpenBabel::OBMol const *)arg1)->GetTitle();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_title(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBMol_get_title__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_get_title__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBMol.get_title", 
  "    char const * OBMol.get_title(bool replaceNewlines)\n" "    char const * OBMol.get_title()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_num_atoms(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","NumAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_num_bonds(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","NumBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_num_hvy_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NumHvyAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (unsigned int)(arg1)->NumHvyAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_num_residues(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","NumResidues", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (unsigned int)((OpenBabel::OBMol const *)arg1)->NumResidues();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_num_rotors(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NumRotors", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (unsigned int)(arg1)->NumRotors();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAtom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (OpenBabel::OBAtom *)((OpenBabel::OBMol const *)arg1)->GetAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_first_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtom *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetFirstAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMol const *)arg1)->GetFirstAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetBond", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (OpenBabel::OBBond *)((OpenBabel::OBMol const *)arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetBond", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetBond", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (OpenBabel::OBBond *)((OpenBabel::OBMol const *)arg1)->GetBond(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_bond__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  result = (OpenBabel::OBBond *)((OpenBabel::OBMol const *)arg1)->GetBond(arg2,arg3);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_bond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_OBMol_get_bond__SWIG_0(nargs, args, self);}  if (argc == 3) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBMol_get_bond__SWIG_2(nargs, args, self);}  check_2:
  if (argc == 3) { return _wrap_OBMol_get_bond__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBMol.get_bond",  "    OpenBabel::OBBond * OBMol.get_bond(int idx)\n"
  "    OpenBabel::OBBond * OBMol.get_bond(int a, int b)\n"
  "    OpenBabel::OBBond * OBMol.get_bond(OpenBabel::OBAtom *bgn, OpenBabel::OBAtom *end)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_residue(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; OpenBabel::OBResidue *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetResidue", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (OpenBabel::OBResidue *)((OpenBabel::OBMol const *)arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetInternalCoord", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->GetInternalCoord();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >(static_cast< const std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ; int val5 ; int ecode5 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetTorsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetTorsion", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetTorsion", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","GetTorsion", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","GetTorsion", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); result = (double)(arg1)->GetTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetTorsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetTorsion", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetTorsion", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetTorsion", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetTorsion", 5, argv[3] ));  } 
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5); result = (double)(arg1)->GetTorsion(arg2,arg3,arg4,arg5);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_torsion(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 6) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 5) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[4], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBMol_get_torsion__SWIG_1(nargs, args, self);}  check_1: if (argc == 5) {
    return _wrap_OBMol_get_torsion__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBMol.get_torsion",  "    double OBMol.get_torsion(int, int, int, int)\n"
  "    double OBMol.get_torsion(OpenBabel::OBAtom *a, OpenBabel::OBAtom *b, OpenBabel::OBAtom *c, OpenBabel::OBAtom *d)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_angle(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4); result = (double)(arg1)->GetAngle(arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_formula(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::string result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetFormula", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->GetFormula();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_spaced_formula__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; char *arg3 = (char *) 0 ; bool arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; bool val4 ; int ecode4 = 0 ;
  std::string result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetSpacedFormula", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetSpacedFormula", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","GetSpacedFormula", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); ecode4 = SWIG_AsVal_bool(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","GetSpacedFormula", 4, argv[2] )); }  
  arg4 = static_cast< bool >(val4); result = (arg1)->GetSpacedFormula(arg2,(char const *)arg3,arg4);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult;
  fail: if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_spaced_formula__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; char *arg3 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; std::string result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetSpacedFormula", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetSpacedFormula", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","GetSpacedFormula", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (arg1)->GetSpacedFormula(arg2,(char const *)arg3);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult;
  fail: if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_spaced_formula__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetSpacedFormula", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetSpacedFormula", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->GetSpacedFormula(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_spaced_formula__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetSpacedFormula", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->GetSpacedFormula();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_spaced_formula(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_get_spaced_formula__SWIG_3(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_get_spaced_formula__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_get_spaced_formula__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBMol_get_spaced_formula__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBMol.get_spaced_formula", 
  "    std::string OBMol.get_spaced_formula(int ones, char const *sp, bool implicitH)\n"
  "    std::string OBMol.get_spaced_formula(int ones, char const *sp)\n" "    std::string OBMol.get_spaced_formula(int ones)\n"
  "    std::string OBMol.get_spaced_formula()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_energy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetEnergy", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (double)((OpenBabel::OBMol const *)arg1)->GetEnergy();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_mol_wt__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetMolWt", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetMolWt", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->GetMolWt(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_mol_wt__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetMolWt", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (double)(arg1)->GetMolWt();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_mol_wt(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBMol_get_mol_wt__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_get_mol_wt__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBMol.get_mol_wt", 
  "    double OBMol.get_mol_wt(bool implicitH)\n" "    double OBMol.get_mol_wt()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_exact_mass__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetExactMass", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetExactMass", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->GetExactMass(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_exact_mass__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetExactMass", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (double)(arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_exact_mass(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_get_exact_mass__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_get_exact_mass__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMol.get_exact_mass",  "    double OBMol.get_exact_mass(bool implicitH)\n"
  "    double OBMol.get_exact_mass()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_total_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetTotalCharge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (int)(arg1)->GetTotalCharge();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_total_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetTotalSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (unsigned int)(arg1)->GetTotalSpinMultiplicity();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned short result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol const *","GetDimension", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (unsigned short)((OpenBabel::OBMol const *)arg1)->GetDimension();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetCoordinates", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (double *)(arg1)->GetCoordinates();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_sssr(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetSSSR", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *) &(arg1)->GetSSSR();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_automatic_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AutomaticFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->AutomaticFormalCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_automatic_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AutomaticPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->AutomaticPartialCharge();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_title__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetTitle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetTitle", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetTitle((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_title__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetTitle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","SetTitle", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","SetTitle", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); (arg1)->SetTitle(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_title(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBMol_set_title__SWIG_1(nargs, args, self);}  check_1:
  if (argc == 2) { return _wrap_OBMol_set_title__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMol.set_title",  "    void OBMol.set_title(char const *title)\n"
  "    void OBMol.set_title(std::string &title)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_formula(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetFormula", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","SetFormula", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->SetFormula(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_energy(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetEnergy", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetEnergy", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetEnergy(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_dimension(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; unsigned short arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned short val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetDimension", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned short","SetDimension", 2, argv[0] )); }  
  arg2 = static_cast< unsigned short >(val2); (arg1)->SetDimension(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_total_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetTotalCharge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetTotalCharge", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetTotalCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_total_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetTotalSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetTotalSpinMultiplicity", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); (arg1)->SetTotalSpinMultiplicity(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > > arg2 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetInternalCoord", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t,  0 );
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >","SetInternalCoord", 2, argv[0] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >","SetInternalCoord", 2, argv[0])); }
     else {
      arg2 = *(reinterpret_cast< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > * >(argp2)); }
     }  (arg1)->SetInternalCoord(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_automatic_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetAutomaticFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SetAutomaticFormalCharge", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->SetAutomaticFormalCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_automatic_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetAutomaticPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","SetAutomaticPartialCharge", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->SetAutomaticPartialCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_aromatic_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetAromaticPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetAromaticPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_sssrperceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetSSSRPerceived", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetSSSRPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_ring_atoms_and_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetRingAtomsAndBondsPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetRingAtomsAndBondsPerceived(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_atom_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetAtomTypesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetAtomTypesPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_ring_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetRingTypesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetRingTypesPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_chains_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetChainsPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetChainsPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_chirality_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetChiralityPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetChiralityPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_partial_charges_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetPartialChargesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetPartialChargesPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_hybridization_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetHybridizationPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetHybridizationPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_implicit_valence_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetImplicitValencePerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetImplicitValencePerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_kekule_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetKekulePerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetKekulePerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_closure_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetClosureBondsPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetClosureBondsPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_hydrogens_added(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetHydrogensAdded", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetHydrogensAdded(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_corrected_for_ph(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetCorrectedForPH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetCorrectedForPH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_aromatic_corrected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetAromaticCorrected", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetAromaticCorrected(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_spin_multiplicity_assigned(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetSpinMultiplicityAssigned", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->SetSpinMultiplicityAssigned(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_flags(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetFlags", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetFlags", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetFlags(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_aromatic_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetAromaticPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->UnsetAromaticPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_sssrperceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetSSSRPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->UnsetSSSRPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_ring_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetRingTypesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->UnsetRingTypesPerceived(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_partial_charges_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetPartialChargesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->UnsetPartialChargesPerceived(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_implicit_valence_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetImplicitValencePerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->UnsetImplicitValencePerceived(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_hydrogens_added(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetHydrogensAdded", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->UnsetHydrogensAdded(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_unset_flag(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","UnsetFlag", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","UnsetFlag", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->UnsetFlag(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_class_description(int argc, VALUE *argv, VALUE self) { char *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (char *)OpenBabel::OBMol::ClassDescription(); vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_renumber_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","RenumberAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &","RenumberAtoms", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &","RenumberAtoms", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > * >(argp2);
  (arg1)->RenumberAtoms(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetCoordinates", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","SetCoordinates", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); (arg1)->SetCoordinates(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_to_inertial_frame__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","ToInertialFrame", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ToInertialFrame", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","ToInertialFrame", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< double * >(argp3); (arg1)->ToInertialFrame(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_to_inertial_frame__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","ToInertialFrame", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->ToInertialFrame(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_to_inertial_frame(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_to_inertial_frame__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_to_inertial_frame__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBMol.to_inertial_frame",  "    void OBMol.to_inertial_frame(int conf, double *rmat)\n"
  "    void OBMol.to_inertial_frame()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_translate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Translate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","Translate", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","Translate", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); (arg1)->Translate((OpenBabel::vector3 const &)*arg2); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_translate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::vector3 *arg2 = 0 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Translate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","Translate", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","Translate", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","Translate", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); (arg1)->Translate((OpenBabel::vector3 const &)*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_translate(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_OBMol_translate__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_translate__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "OBMol.translate", 
  "    void OBMol.translate(OpenBabel::vector3 const &v)\n"
  "    void OBMol.translate(OpenBabel::vector3 const &v, int conf)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_rotate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double (*arg2)[3] ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Rotate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const [3][3]","Rotate", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double (*)[3] >(argp2); (arg1)->Rotate((double const (*)[3])arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_rotate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double *arg2 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Rotate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const [9]","Rotate", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); (arg1)->Rotate((double const (*))arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_rotate__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double *arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Rotate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const [9]","Rotate", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","Rotate", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); (arg1)->Rotate((double const (*))arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_rotate(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_a_3__double, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBMol_rotate__SWIG_0(nargs, args, self);}  check_1:
  if (argc == 2) { return _wrap_OBMol_rotate__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_rotate__SWIG_2(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "OBMol.rotate", 
  "    void OBMol.rotate(double const u[3][3])\n" "    void OBMol.rotate(double const m[9])\n"
  "    void OBMol.rotate(double const m[9], int nconf)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_center__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Center", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->Center(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_kekulize(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Kekulize", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->Kekulize();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_perceive_kekule_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","PerceiveKekuleBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->PerceiveKekuleBonds();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_new_perceive_kekule_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NewPerceiveKekuleBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->NewPerceiveKekuleBonds(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_hydrogens__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->DeleteHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_hydrogens__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DeleteHydrogens", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->DeleteHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_hydrogens(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_delete_hydrogens__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_delete_hydrogens__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMol.delete_hydrogens",  "    bool OBMol.delete_hydrogens()\n"
  "    bool OBMol.delete_hydrogens(OpenBabel::OBAtom *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_non_polar_hydrogens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteNonPolarHydrogens", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->DeleteNonPolarHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteHydrogen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","DeleteHydrogen", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->DeleteHydrogen(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_hydrogens__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; bool arg3 ; double arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  bool val2 ; int ecode2 = 0 ; bool val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","AddHydrogens", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","AddHydrogens", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","AddHydrogens", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); result = (bool)(arg1)->AddHydrogens(arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_hydrogens__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; bool arg3 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; bool val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","AddHydrogens", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","AddHydrogens", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); result = (bool)(arg1)->AddHydrogens(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_hydrogens__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","AddHydrogens", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (bool)(arg1)->AddHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_hydrogens__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->AddHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_hydrogens__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddHydrogens", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddHydrogens", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->AddHydrogens(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_hydrogens(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_add_hydrogens__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBMol_add_hydrogens__SWIG_4(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBMol_add_hydrogens__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMol_add_hydrogens__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBMol_add_hydrogens__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBMol.add_hydrogens", 
  "    bool OBMol.add_hydrogens(bool polaronly, bool correctForPH, double pH)\n"
  "    bool OBMol.add_hydrogens(bool polaronly, bool correctForPH)\n" "    bool OBMol.add_hydrogens(bool polaronly)\n"
  "    bool OBMol.add_hydrogens()\n" "    bool OBMol.add_hydrogens(OpenBabel::OBAtom *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_polar_hydrogens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddPolarHydrogens", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->AddPolarHydrogens();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_strip_salts(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","StripSalts", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","StripSalts", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->StripSalts(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_separate__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Separate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Separate", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->Separate(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_separate__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Separate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->Separate();
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_separate(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBMol_separate__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_separate__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBMol.separate", 
  "    std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > OBMol.separate(int StartIndex)\n"
  "    std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > OBMol.separate()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_next_fragment(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBMolAtomDFSIter *arg2 = 0 ; OpenBabel::OBMol *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetNextFragment", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMolAtomDFSIter,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomDFSIter &","GetNextFragment", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolAtomDFSIter &","GetNextFragment", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMolAtomDFSIter * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","GetNextFragment", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","GetNextFragment", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::OBMol * >(argp3); result = (bool)(arg1)->GetNextFragment(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_convert_dative_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","ConvertDativeBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->ConvertDativeBonds();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_correct_for_ph__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","CorrectForPH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","CorrectForPH", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); result = (bool)(arg1)->CorrectForPH(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_correct_for_ph__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","CorrectForPH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->CorrectForPH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_correct_for_ph(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_correct_for_ph__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_correct_for_ph__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMol.correct_for_ph",  "    bool OBMol.correct_for_ph(double pH)\n"
  "    bool OBMol.correct_for_ph()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_assign_spin_multiplicity__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ; int ecode2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AssignSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","AssignSpinMultiplicity", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (bool)(arg1)->AssignSpinMultiplicity(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_assign_spin_multiplicity__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AssignSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->AssignSpinMultiplicity();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_assign_spin_multiplicity(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMol_assign_spin_multiplicity__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_assign_spin_multiplicity__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMol.assign_spin_multiplicity", 
  "    bool OBMol.assign_spin_multiplicity(bool NoImplicitH)\n" "    bool OBMol.assign_spin_multiplicity()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_center__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  OpenBabel::vector3 result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Center", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Center", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->Center(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_center(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBMol_center__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_center__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBMol.center", 
  "    OpenBabel::vector3 OBMol.center()\n" "    OpenBabel::vector3 OBMol.center(int nconf)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_torsion(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg5 = (OpenBabel::OBAtom *) 0 ; double arg6 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; double val6 ; int ecode6 = 0 ; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetTorsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetTorsion", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetTorsion", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetTorsion", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetTorsion", 5, argv[3] ));  } 
  arg5 = reinterpret_cast< OpenBabel::OBAtom * >(argp5); ecode6 = SWIG_AsVal_double(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "double","SetTorsion", 6, argv[4] )); }  
  arg6 = static_cast< double >(val6); (arg1)->SetTorsion(arg2,arg3,arg4,arg5,arg6); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_sssr(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindSSSR", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->FindSSSR(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_ring_atoms_and_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindRingAtomsAndBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->FindRingAtomsAndBonds(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_chiral_centers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindChiralCenters", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->FindChiralCenters(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_children__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::vector< int,std::allocator< int > > *arg2 = 0 ; int arg3 ; int arg4 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindChildren", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > &","FindChildren", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > &","FindChildren", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","FindChildren", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","FindChildren", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->FindChildren(*arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_children__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > *arg2 = 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindChildren", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &","FindChildren", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &","FindChildren", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","FindChildren", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","FindChildren", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4); (arg1)->FindChildren(*arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_children(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 4) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { { int res = SWIG_AsVal_int(argv[2], NULL);
        _v = SWIG_CheckState(res); } }  if (!_v) goto check_1; { { int res = SWIG_AsVal_int(argv[3], NULL);
        _v = SWIG_CheckState(res); } }  if (!_v) goto check_1; return _wrap_OBMol_find_children__SWIG_0(nargs, args, self);} 
  check_1: if (argc == 4) { return _wrap_OBMol_find_children__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBMol.find_children", 
  "    void OBMol.find_children(std::vector< int,std::allocator< int > > &children, int bgnIdx, int endIdx)\n"
  "    void OBMol.find_children(std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &children, OpenBabel::OBAtom *bgn, OpenBabel::OBAtom *end)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_largest_fragment(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBBitVec *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindLargestFragment", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","FindLargestFragment", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","FindLargestFragment", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2); (arg1)->FindLargestFragment(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_contig_frag_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","ContigFragList", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &","ContigFragList", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &","ContigFragList", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > * >(argp2);
  (arg1)->ContigFragList(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_align(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg4 = 0 ; OpenBabel::vector3 *arg5 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ;
  if ((argc < 4) || (argc > 4)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Align", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Align", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Align", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","Align", 4, argv[2] ));  } 
  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","Align", 4, argv[2])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  res5 = SWIG_ConvertPtr(argv[3], &argp5, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","Align", 5, argv[3] ));  } 
  if (!argp5) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","Align", 5, argv[3])); }
   arg5 = reinterpret_cast< OpenBabel::vector3 * >(argp5); (arg1)->Align(arg2,arg3,*arg4,*arg5); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_connect_the_dots(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","ConnectTheDots", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->ConnectTheDots(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_perceive_bond_orders(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","PerceiveBondOrders", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->PerceiveBondOrders(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_angles(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindAngles", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->FindAngles(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_find_torsions(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","FindTorsions", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); (arg1)->FindTorsions(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_gtdvector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::vector< int,std::allocator< int > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetGTDVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > &","GetGTDVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > &","GetGTDVector", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp2); result = (bool)(arg1)->GetGTDVector(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_givector(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetGIVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetGIVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetGIVector", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2); (arg1)->GetGIVector(*arg2);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_gidvector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetGIDVector", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetGIDVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetGIDVector", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2); (arg1)->GetGIDVector(*arg2);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_2d(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Has2D", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->Has2D();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_3d(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Has3D", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->Has3D();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_non_zero_coords(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasNonZeroCoords", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasNonZeroCoords();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_aromatic_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasAromaticPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasAromaticPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_sssrperceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasSSSRPerceived", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasSSSRPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_ring_atoms_and_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasRingAtomsAndBondsPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasRingAtomsAndBondsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_atom_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasAtomTypesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasAtomTypesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_ring_types_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasRingTypesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasRingTypesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_chirality_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasChiralityPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasChiralityPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_partial_charges_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasPartialChargesPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasPartialChargesPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_hybridization_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasHybridizationPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasHybridizationPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_implicit_valence_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasImplicitValencePerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasImplicitValencePerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_kekule_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasKekulePerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasKekulePerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_closure_bonds_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasClosureBondsPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasClosureBondsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_chains_perceived(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasChainsPerceived", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasChainsPerceived();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_hydrogens_added(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasHydrogensAdded", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasHydrogensAdded();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_aromatic_corrected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasAromaticCorrected", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasAromaticCorrected();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_is_corrected_for_ph(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","IsCorrectedForPH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->IsCorrectedForPH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_has_spin_multiplicity_assigned(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","HasSpinMultiplicityAssigned", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->HasSpinMultiplicityAssigned();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_is_chiral(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","IsChiral", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_empty(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","Empty", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (bool)(arg1)->Empty();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_num_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NumConformers", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (int)(arg1)->NumConformers();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::vector< double *,std::allocator< double * > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetConformers", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_double_p_std__allocatorT_double_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double *,std::allocator< double * > > &","SetConformers", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double *,std::allocator< double * > > &","SetConformers", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< double *,std::allocator< double * > > * >(argp2); (arg1)->SetConformers(*arg2);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_add_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","AddConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","AddConformer", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); (arg1)->AddConformer(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetConformer", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetConformer(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_copy_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; double *arg2 = (double *) 0 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","CopyConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","CopyConformer", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","CopyConformer", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); (arg1)->CopyConformer(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_delete_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","DeleteConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","DeleteConformer", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->DeleteConformer(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  double *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConformer", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double *)(arg1)->GetConformer(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_set_energies(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< double,std::allocator< double > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetEnergies", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > > &","SetEnergies", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double,std::allocator< double > > &","SetEnergies", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< double,std::allocator< double > > * >(argp2); (arg1)->SetEnergies(*arg2); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_energies(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< double,std::allocator< double > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetEnergies", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->GetEnergies();
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_energy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetEnergy", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetEnergy", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(arg1)->GetEnergy(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_energy(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBMol_get_energy__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMol_get_energy__SWIG_1(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 3, "OBMol.get_energy", 
  "    double OBMol.get_energy()\n" "    double OBMol.get_energy(int ci)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::vector< double *,std::allocator< double * > >::iterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double *,std::allocator< double * > >::iterator &","BeginConformer", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double *,std::allocator< double * > >::iterator &","BeginConformer", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< double *,std::allocator< double * > >::iterator * >(argp2);
  result = (double *)(arg1)->BeginConformer(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_next_conformer(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; std::vector< double *,std::allocator< double * > >::iterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NextConformer", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double *,std::allocator< double * > >::iterator &","NextConformer", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double *,std::allocator< double * > >::iterator &","NextConformer", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< double *,std::allocator< double * > >::iterator * >(argp2);
  result = (double *)(arg1)->NextConformer(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_get_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double *,std::allocator< double * > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","GetConformers", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (std::vector< double *,std::allocator< double * > > *) &(arg1)->GetConformers();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_double_p_std__allocatorT_double_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_atoms(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_end_atoms(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","EndAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_bonds(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_end_bonds(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","EndBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_residues(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBResidue *,std::allocator< OpenBabel::OBResidue * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginResidues", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->BeginResidues();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIterator(static_cast< const OpenBabel::OBResidueIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_end_residues(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBResidue *,std::allocator< OpenBabel::OBResidue * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","EndResidues", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1); result = (arg1)->EndResidues();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIterator(static_cast< const OpenBabel::OBResidueIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtomIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtomIterator &","BeginAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAtomIterator &","BeginAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBAtomIterator * >(argp2); result = (OpenBabel::OBAtom *)(arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_next_atom(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBAtomIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NextAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtomIterator &","NextAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAtomIterator &","NextAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBAtomIterator * >(argp2); result = (OpenBabel::OBAtom *)(arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_next_bond(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NextBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; OpenBabel::OBResidueIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIterator &","BeginResidue", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBResidueIterator &","BeginResidue", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBResidueIterator * >(argp2);
  result = (OpenBabel::OBResidue *)(arg1)->BeginResidue(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_next_residue(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  OpenBabel::OBResidueIterator *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NextResidue", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIterator &","NextResidue", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBResidueIterator &","NextResidue", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBResidueIterator * >(argp2);
  result = (OpenBabel::OBResidue *)(arg1)->NextResidue(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_begin_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBInternalCoord *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","BeginInternalCoord", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator &","BeginInternalCoord", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator &","BeginInternalCoord", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator * >(argp2);
  result = (OpenBabel::OBInternalCoord *)(arg1)->BeginInternalCoord(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMol_next_internal_coord(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ;
  std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBInternalCoord *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","NextInternalCoord", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator &","NextInternalCoord", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator &","NextInternalCoord", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator * >(argp2);
  result = (OpenBabel::OBInternalCoord *)(arg1)->NextInternalCoord(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBInternalCoord, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_throw_error__SWIG_0(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char *","OpenBabel::ThrowError", 1, argv[0] )); } 
  arg1 = reinterpret_cast< char * >(buf1); OpenBabel::ThrowError(arg1); if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil;
  fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_throw_error__SWIG_1(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string &","OpenBabel::ThrowError", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::ThrowError", 1, argv[0])); }
   arg1 = reinterpret_cast< std::string * >(argp1); OpenBabel::ThrowError(*arg1); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_throw_error(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) { int _v = 0; {
      void *vptr = 0; int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__string, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_throw_error__SWIG_1(nargs, args, self);}  check_1: if (argc == 1) {
    return _wrap_throw_error__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 1, "throw_error", 
  "    void throw_error(char *str)\n" "    void throw_error(std::string &str)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_cartesian_to_internal(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > *arg1 = 0 ;
  OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > &","OpenBabel::CartesianToInternal", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > &","OpenBabel::CartesianToInternal", 1, argv[0])); }
  
  arg1 = reinterpret_cast< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","OpenBabel::CartesianToInternal", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","OpenBabel::CartesianToInternal", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); OpenBabel::CartesianToInternal(*arg1,*arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_internal_to_cartesian(int argc, VALUE *argv, VALUE self) {
  std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > *arg1 = 0 ;
  OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > &","OpenBabel::InternalToCartesian", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > &","OpenBabel::InternalToCartesian", 1, argv[0])); }
  
  arg1 = reinterpret_cast< std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","OpenBabel::InternalToCartesian", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","OpenBabel::InternalToCartesian", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); OpenBabel::InternalToCartesian(*arg1,*arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_extension(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ; char *arg2 = (char *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; std::string result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string &","OpenBabel::NewExtension", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::NewExtension", 1, argv[0])); }
   arg1 = reinterpret_cast< std::string * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[1], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","OpenBabel::NewExtension", 2, argv[1] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = OpenBabel::NewExtension(*arg1,arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult;
  fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_etab_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::etab), SWIGTYPE_p_OpenBabel__OBElementTable,  0 ); return _val; }
SWIGINTERN VALUE _wrap_etab_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBElementTable,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::etab""' of type '""OpenBabel::OBElementTable""'"); } 
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::etab""' of type '""OpenBabel::OBElementTable""'"); }
     else { OpenBabel::etab = *(reinterpret_cast< OpenBabel::OBElementTable * >(argp)); }  }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ttab_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::ttab), SWIGTYPE_p_OpenBabel__OBTypeTable,  0 ); return _val; }
SWIGINTERN VALUE _wrap_ttab_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBTypeTable,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::ttab""' of type '""OpenBabel::OBTypeTable""'"); } 
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::ttab""' of type '""OpenBabel::OBTypeTable""'"); }
     else { OpenBabel::ttab = *(reinterpret_cast< OpenBabel::OBTypeTable * >(argp)); }  }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_isotab_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::isotab), SWIGTYPE_p_OpenBabel__OBIsotopeTable,  0 ); return _val; }
SWIGINTERN VALUE _wrap_isotab_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBIsotopeTable,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::isotab""' of type '""OpenBabel::OBIsotopeTable""'"); } 
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::isotab""' of type '""OpenBabel::OBIsotopeTable""'"); }
     else { OpenBabel::isotab = *(reinterpret_cast< OpenBabel::OBIsotopeTable * >(argp)); }  }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_aromtyper_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::aromtyper), SWIGTYPE_p_OpenBabel__OBAromaticTyper,  0 ); return _val; }
SWIGINTERN VALUE _wrap_aromtyper_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBAromaticTyper,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::aromtyper""' of type '""OpenBabel::OBAromaticTyper""'"); }
     if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::aromtyper""' of type '""OpenBabel::OBAromaticTyper""'"); }
     else { OpenBabel::aromtyper = *(reinterpret_cast< OpenBabel::OBAromaticTyper * >(argp)); }  }  return _val; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_atomtyper_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::atomtyper), SWIGTYPE_p_OpenBabel__OBAtomTyper,  0 ); return _val; }
SWIGINTERN VALUE _wrap_atomtyper_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBAtomTyper,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::atomtyper""' of type '""OpenBabel::OBAtomTyper""'"); } 
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::atomtyper""' of type '""OpenBabel::OBAtomTyper""'"); }
     else { OpenBabel::atomtyper = *(reinterpret_cast< OpenBabel::OBAtomTyper * >(argp)); }  }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_chainsparser_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::chainsparser), SWIGTYPE_p_OpenBabel__OBChainsParser,  0 ); return _val; }
SWIGINTERN VALUE _wrap_chainsparser_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBChainsParser,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::chainsparser""' of type '""OpenBabel::OBChainsParser""'"); }
     if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::chainsparser""' of type '""OpenBabel::OBChainsParser""'"); }
     else { OpenBabel::chainsparser = *(reinterpret_cast< OpenBabel::OBChainsParser * >(argp)); }  }  return _val; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_resdat_get(VALUE self) { VALUE _val;
  _val = SWIG_NewPointerObj(SWIG_as_voidptr(&OpenBabel::resdat), SWIGTYPE_p_OpenBabel__OBResidueData,  0 ); return _val; }
SWIGINTERN VALUE _wrap_resdat_set(VALUE self, VALUE _val) { { void *argp = 0;
    int res = SWIG_ConvertPtr(_val, &argp, SWIGTYPE_p_OpenBabel__OBResidueData,  0 ); if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""OpenBabel::resdat""' of type '""OpenBabel::OBResidueData""'"); } 
    if (!argp) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""OpenBabel::resdat""' of type '""OpenBabel::OBResidueData""'"); }
     else { OpenBabel::resdat = *(reinterpret_cast< OpenBabel::OBResidueData * >(argp)); }  }  return _val; fail: return Qnil; }
SWIGINTERN VALUE _wrap_get_rmat(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ; double *arg2 = (double *) 0 ;
  double *arg3 = (double *) 0 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; int val4 ; int ecode4 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::get_rmat", 1, argv[0] ));  } 
  arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::get_rmat", 2, argv[1] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::get_rmat", 3, argv[2] ));  } 
  arg3 = reinterpret_cast< double * >(argp3); ecode4 = SWIG_AsVal_int(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","OpenBabel::get_rmat", 4, argv[3] )); }  
  arg4 = static_cast< int >(val4); OpenBabel::get_rmat(arg1,arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_ob_make_rmat(int argc, VALUE *argv, VALUE self) { double (*arg1)[3] ; double *arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_a_3__double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double [3][3]","OpenBabel::ob_make_rmat", 1, argv[0] ));  }
    arg1 = reinterpret_cast< double (*)[3] >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [9]","OpenBabel::ob_make_rmat", 2, argv[1] ));  }
    arg2 = reinterpret_cast< double * >(argp2); OpenBabel::ob_make_rmat((double (*)[3])arg1,arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_qtrfit(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ; double *arg2 = (double *) 0 ;
  int arg3 ; double (*arg4)[3] ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ;
  void *argp4 = 0 ; int res4 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::qtrfit", 1, argv[0] ));  } 
  arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::qtrfit", 2, argv[1] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::qtrfit", 3, argv[2] )); }  
  arg3 = static_cast< int >(val3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_a_3__double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double [3][3]","OpenBabel::qtrfit", 4, argv[3] ));  }  
  arg4 = reinterpret_cast< double (*)[3] >(argp4); OpenBabel::qtrfit(arg1,arg2,arg3,(double (*)[3])arg4); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_superimpose(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ;
  int ecode3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::superimpose", 1, argv[0] ));  } 
  arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::superimpose", 2, argv[1] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::superimpose", 3, argv[2] )); }  
  arg3 = static_cast< int >(val3); result = (double)OpenBabel::superimpose(arg1,arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBRing;

SWIGINTERN VALUE _wrap_OBRing__path_set(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  std::vector< int,std::allocator< int > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","_path", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > const &","_path", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > const &","_path", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_path = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBRing__path_get(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","_path", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (std::vector< int,std::allocator< int > > *) & ((arg1)->_path);
  vresult = swig::from(static_cast< std::vector<int,std::allocator< int > > >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing__pathset_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; OpenBabel::OBBitVec *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","_pathset", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec const &","_pathset", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec const &","_pathset", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2); if (arg1) (arg1)->_pathset = *arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing__pathset_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBBitVec *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","_pathset", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (OpenBabel::OBBitVec *) & ((arg1)->_pathset);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBitVec, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBRing__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBRing__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< int,std::allocator< int > > *arg1 = 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  OpenBabel::OBRing *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > &","OpenBabel::OBRing", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > &","OpenBabel::OBRing", 1, argv[0])); }
   arg1 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp1); ecode2 = SWIG_AsVal_int(argv[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","OpenBabel::OBRing", 2, argv[1] )); }  
  arg2 = static_cast< int >(val2); result = (OpenBabel::OBRing *)new OpenBabel::OBRing(*arg1,arg2); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBRing__SWIG_2(int argc, VALUE *argv, VALUE self) {
  std::vector< int,std::allocator< int > > *arg1 = 0 ; OpenBabel::OBBitVec arg2 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 ;
  int res2 = 0 ; OpenBabel::OBRing *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > &","OpenBabel::OBRing", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > &","OpenBabel::OBRing", 1, argv[0])); }
   arg1 = reinterpret_cast< std::vector< int,std::allocator< int > > * >(argp1); {
    res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec","OpenBabel::OBRing", 2, argv[1] ));  }
       if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec","OpenBabel::OBRing", 2, argv[1])); }
     else { arg2 = *(reinterpret_cast< OpenBabel::OBBitVec * >(argp2)); }  } 
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing(*arg1,arg2); DATA_PTR(self) = result; return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBRing_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBRing_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRing);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBRing__SWIG_3(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *arg1 = 0 ; void *argp1 ;
  int res1 = 0 ; OpenBabel::OBRing *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBRing,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing const &","OpenBabel::OBRing", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBRing const &","OpenBabel::OBRing", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  result = (OpenBabel::OBRing *)new OpenBabel::OBRing((OpenBabel::OBRing const &)*arg1); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBRing(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBRing__SWIG_0(nargs, args, self);}  if (argc == 1) { return _wrap_new_OBRing__SWIG_3(nargs, args, self);} 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_3; return _wrap_new_OBRing__SWIG_2(nargs, args, self);}  check_3:
  if (argc == 2) { return _wrap_new_OBRing__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBRing.new",  "    OBRing.new()\n"
  "    OBRing.new(std::vector< int,std::allocator< int > > &path, int size)\n"
  "    OBRing.new(std::vector< int,std::allocator< int > > &path, OpenBabel::OBBitVec set)\n"
  "    OBRing.new(OpenBabel::OBRing const &src)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_size(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing const *","Size", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (int)((OpenBabel::OBRing const *)arg1)->Size();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_path_size(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing const *","PathSize", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (int)((OpenBabel::OBRing const *)arg1)->PathSize();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","IsAromatic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (bool)(arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int res2 ;
  char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","SetType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->SetType(arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","SetType", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","SetType", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); (arg1)->SetType(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_set_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBRing_set_type__SWIG_1(nargs, args, self);}  check_1:
  if (argc == 2) { return _wrap_OBRing_set_type__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBRing.set_type",  "    void OBRing.set_type(char *type)\n"
  "    void OBRing.set_type(std::string &type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_get_type(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","GetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (char *)(arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_get_root_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","GetRootAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (unsigned int)(arg1)->GetRootAtom();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_is_member__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","IsMember", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsMember", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_is_member__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","IsMember", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsMember", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_is_member(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBRing_is_member__SWIG_0(nargs, args, self);}  check_1:
  if (argc == 2) { return _wrap_OBRing_is_member__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBRing.is_member",  "    bool OBRing.is_member(OpenBabel::OBAtom *a)\n"
  "    bool OBRing.is_member(OpenBabel::OBBond *b)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","IsInRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsInRing", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->IsInRing(arg2); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","SetParent", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMol *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","GetParent", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1); result = (OpenBabel::OBMol *)(arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBRing_find_center_and_normal(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ;
  OpenBabel::vector3 *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing *","findCenterAndNormal", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","findCenterAndNormal", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","findCenterAndNormal", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","findCenterAndNormal", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","findCenterAndNormal", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","findCenterAndNormal", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","findCenterAndNormal", 4, argv[2])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4); result = (bool)(arg1)->findCenterAndNormal(*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBRing(OpenBabel::OBRing *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_compare_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRing *arg1 = (OpenBabel::OBRing *) 0 ; OpenBabel::OBRing *arg2 = (OpenBabel::OBRing *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRing const *","OpenBabel::CompareRingSize", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRing * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBRing const *","OpenBabel::CompareRingSize", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBRing * >(argp2);
  result = (bool)OpenBabel::CompareRingSize((OpenBabel::OBRing const *)arg1,(OpenBabel::OBRing const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBRingSearch;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBRingSearch_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBRingSearch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRingSearch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBRingSearch(int argc, VALUE *argv, VALUE self) { OpenBabel::OBRingSearch *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBRingSearch *)new OpenBabel::OBRingSearch(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBRingSearch(OpenBabel::OBRingSearch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBRingSearch_sort_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","SortRings", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1); (arg1)->SortRings(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingSearch_remove_redundant(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","RemoveRedundant", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","RemoveRedundant", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->RemoveRedundant(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingSearch_add_ring_from_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","AddRingFromClosure", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","AddRingFromClosure", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","AddRingFromClosure", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","AddRingFromClosure", 3, argv[1] ));  }
   arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3); (arg1)->AddRingFromClosure(*arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBRingSearch_save_unique_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; std::deque< int > *arg2 = 0 ; std::deque< int > *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","SaveUniqueRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__dequeT_int_t,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::deque< int > &","SaveUniqueRing", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::deque< int > &","SaveUniqueRing", 2, argv[0])); }
   arg2 = reinterpret_cast< std::deque< int > * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__dequeT_int_t,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::deque< int > &","SaveUniqueRing", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::deque< int > &","SaveUniqueRing", 3, argv[1])); }
   arg3 = reinterpret_cast< std::deque< int > * >(argp3); result = (bool)(arg1)->SaveUniqueRing(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingSearch_write_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","WriteRings", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1); (arg1)->WriteRings(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingSearch_begin_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","BeginRings", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1); result = (arg1)->BeginRings();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRingSearch_end_rings(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRingSearch *arg1 = (OpenBabel::OBRingSearch *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRingSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRingSearch *","EndRings", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRingSearch * >(argp1); result = (arg1)->EndRings();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBRTree;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBRTree_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBRTree_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBRTree);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBRTree(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBRTree *arg2 = (OpenBabel::OBRTree *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBRTree *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBRTree", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBRTree *","OpenBabel::OBRTree", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBRTree * >(argp2); result = (OpenBabel::OBRTree *)new OpenBabel::OBRTree(arg1,arg2);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBRTree(OpenBabel::OBRTree *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBRTree_get_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRTree *arg1 = (OpenBabel::OBRTree *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRTree *","GetAtomIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRTree * >(argp1); result = (int)(arg1)->GetAtomIdx();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBRTree_path_to_root(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBRTree *arg1 = (OpenBabel::OBRTree *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBRTree, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBRTree *","PathToRoot", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBRTree * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &","PathToRoot", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > &","PathToRoot", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > * >(argp2);
  (arg1)->PathToRoot(*arg2); return Qnil; fail: return Qnil; }
swig_class SwigClassOBSmartsPattern;

SWIGINTERN VALUE _wrap_new_OBSmartsPattern__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSmartsPattern *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBSmartsPattern *)new OpenBabel::OBSmartsPattern(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBSmartsPattern(OpenBabel::OBSmartsPattern *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBSmartsPattern_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBSmartsPattern_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSmartsPattern);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBSmartsPattern__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBSmartsPattern *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBSmartsPattern *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBSmartsPattern,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const &","OpenBabel::OBSmartsPattern", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBSmartsPattern const &","OpenBabel::OBSmartsPattern", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (OpenBabel::OBSmartsPattern *)new OpenBabel::OBSmartsPattern((OpenBabel::OBSmartsPattern const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBSmartsPattern(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBSmartsPattern__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_new_OBSmartsPattern__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBSmartsPattern.new",  "    OBSmartsPattern.new()\n"
  "    OBSmartsPattern.new(OpenBabel::OBSmartsPattern const &cp)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_init__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","Init", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","Init", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(arg1)->Init((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_init__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","Init", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","Init", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","Init", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(arg1)->Init((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_init(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBSmartsPattern_init__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBSmartsPattern_init__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBSmartsPattern.init",  "    bool OBSmartsPattern.init(char const *pattern)\n"
  "    bool OBSmartsPattern.init(std::string const &pattern)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_smarts__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::string *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","GetSMARTS", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (std::string *) &((OpenBabel::OBSmartsPattern const *)arg1)->GetSMARTS();
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_smarts__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::string *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","GetSMARTS", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); result = (std::string *) &(arg1)->GetSMARTS();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__string, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_smarts(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBSmartsPattern_get_smarts__SWIG_1(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBSmartsPattern_get_smarts__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBSmartsPattern.get_smarts",  "    std::string & OBSmartsPattern.get_smarts()\n"
  "    std::string & OBSmartsPattern.get_smarts()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_empty(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","Empty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (bool)((OpenBabel::OBSmartsPattern const *)arg1)->Empty(); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_is_valid(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","IsValid", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (bool)((OpenBabel::OBSmartsPattern const *)arg1)->IsValid(); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","NumAtoms", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_num_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","NumBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; int *arg2 = 0 ; int *arg3 = 0 ; int *arg4 = 0 ;
  int arg5 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ;
  void *argp4 = 0 ; int res4 = 0 ; int val5 ; int ecode5 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","GetBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_int,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "int &","GetBond", 2, argv[0] ));  }  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetBond", 2, argv[0])); } 
  arg2 = reinterpret_cast< int * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_int,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "int &","GetBond", 3, argv[1] ));  }  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetBond", 3, argv[1])); } 
  arg3 = reinterpret_cast< int * >(argp3); res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_int,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "int &","GetBond", 4, argv[2] ));  }  if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "int &","GetBond", 4, argv[2])); } 
  arg4 = reinterpret_cast< int * >(argp4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","GetBond", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); (arg1)->GetBond(*arg2,*arg3,*arg4,arg5); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAtomicNum", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)(arg1)->GetAtomicNum(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","GetCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetCharge", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)(arg1)->GetCharge(arg2); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_vector_binding(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","GetVectorBinding", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetVectorBinding", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)((OpenBabel::OBSmartsPattern const *)arg1)->GetVectorBinding(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; OpenBabel::OBMol *arg2 = 0 ; bool arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","Match", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","Match", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","Match", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","Match", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); result = (bool)(arg1)->Match(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","Match", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","Match", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","Match", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->Match(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_match(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBSmartsPattern_match__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBSmartsPattern_match__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBSmartsPattern.match", 
  "    bool OBSmartsPattern.match(OpenBabel::OBMol &mol, bool single)\n"
  "    bool OBSmartsPattern.match(OpenBabel::OBMol &mol)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_restricted_match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; OpenBabel::OBMol *arg2 = 0 ;
  std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > *arg3 = 0 ; bool arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool val4 ; int ecode4 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","RestrictedMatch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > &","RestrictedMatch", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > &","RestrictedMatch", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > * >(argp3);
  ecode4 = SWIG_AsVal_bool(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","RestrictedMatch", 4, argv[2] )); }  
  arg4 = static_cast< bool >(val4); result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_restricted_match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; OpenBabel::OBMol *arg2 = 0 ;
  std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","RestrictedMatch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > &","RestrictedMatch", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > &","RestrictedMatch", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > * >(argp3);
  result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3); vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_restricted_match__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ; bool arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; bool val4 ; int ecode4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","RestrictedMatch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","RestrictedMatch", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","RestrictedMatch", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3); ecode4 = SWIG_AsVal_bool(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","RestrictedMatch", 4, argv[2] )); }  
  arg4 = static_cast< bool >(val4); result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_restricted_match__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","RestrictedMatch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","RestrictedMatch", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","RestrictedMatch", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","RestrictedMatch", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3); result = (bool)(arg1)->RestrictedMatch(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_restricted_match(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1;
    return _wrap_OBSmartsPattern_restricted_match__SWIG_1(nargs, args, self);}  check_1: if (argc == 3) {
    return _wrap_OBSmartsPattern_restricted_match__SWIG_3(nargs, args, self);}  if (argc == 4) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBBitVec, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_3; return _wrap_OBSmartsPattern_restricted_match__SWIG_2(nargs, args, self);}  check_3: if (argc == 4) {
    return _wrap_OBSmartsPattern_restricted_match__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBSmartsPattern.restricted_match", 
  "    bool OBSmartsPattern.restricted_match(OpenBabel::OBMol &mol, std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > &pairs, bool single)\n"
  "    bool OBSmartsPattern.restricted_match(OpenBabel::OBMol &mol, std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > &pairs)\n"
  "    bool OBSmartsPattern.restricted_match(OpenBabel::OBMol &mol, OpenBabel::OBBitVec &bv, bool single)\n"
  "    bool OBSmartsPattern.restricted_match(OpenBabel::OBMol &mol, OpenBabel::OBBitVec &bv)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_num_matches(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern const *","NumMatches", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (unsigned int)((OpenBabel::OBSmartsPattern const *)arg1)->NumMatches();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_map_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","GetMapList", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *) &(arg1)->GetMapList();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_begin_mlist(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","BeginMList", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); result = (arg1)->BeginMList();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_end_mlist(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","EndMList", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1); result = (arg1)->EndMList();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >::iterator & >(result),
  self), swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_get_umap_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","GetUMapList", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  result = (std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *) &(arg1)->GetUMapList();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSmartsPattern_write_map_list(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSmartsPattern *arg1 = (OpenBabel::OBSmartsPattern *) 0 ; std::ostream *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSmartsPattern, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSmartsPattern *","WriteMapList", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBSmartsPattern * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__ostream,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream &","WriteMapList", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::ostream &","WriteMapList", 2, argv[0])); }
   arg2 = reinterpret_cast< std::ostream * >(argp2); (arg1)->WriteMapList(*arg2); return Qnil; fail: return Qnil; }
swig_class SwigClassOBSSMatch;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBSSMatch_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBSSMatch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBSSMatch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBSSMatch(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMol *arg1 = 0 ;
  OpenBabel::Pattern *arg2 = (OpenBabel::Pattern *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  OpenBabel::OBSSMatch *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","OpenBabel::OBSSMatch", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","OpenBabel::OBSSMatch", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_OpenBabel__Pattern, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::Pattern *","OpenBabel::OBSSMatch", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::Pattern * >(argp2);
  result = (OpenBabel::OBSSMatch *)new OpenBabel::OBSSMatch(*arg1,arg2); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBSSMatch(OpenBabel::OBSSMatch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBSSMatch_match__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSSMatch *arg1 = (OpenBabel::OBSSMatch *) 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *arg2 = 0 ;
  int arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSSMatch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSSMatch *","Match", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSSMatch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &","Match", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &","Match", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > * >(argp2);
  ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","Match", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); (arg1)->Match(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSSMatch_match__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBSSMatch *arg1 = (OpenBabel::OBSSMatch *) 0 ;
  std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBSSMatch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBSSMatch *","Match", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBSSMatch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &","Match", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &","Match", 2, argv[0])); }
  
  arg2 = reinterpret_cast< std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > * >(argp2);
  (arg1)->Match(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBSSMatch_match(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_OBSSMatch_match__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBSSMatch_match__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 4, "OBSSMatch.match", 
  "    void OBSSMatch.match(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &v, int bidx)\n"
  "    void OBSSMatch.match(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > &v)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_smarts_lex_replace(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ;
  std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string &","OpenBabel::SmartsLexReplace", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::SmartsLexReplace", 1, argv[0])); }
   arg1 = reinterpret_cast< std::string * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > > &","OpenBabel::SmartsLexReplace", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > > &","OpenBabel::SmartsLexReplace", 2, argv[1])); }
  
  arg2 = reinterpret_cast< std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > > * >(argp2);
  OpenBabel::SmartsLexReplace(*arg1,*arg2); return Qnil; fail: return Qnil; }
swig_class SwigClassOBFingerprint;

SWIGINTERN VALUE _wrap_OBFingerprint_default(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFingerprint **result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFingerprint **) &OpenBabel::OBFingerprint::Default();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_OpenBabel__OBFingerprint, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_find_type(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFingerprint *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBFingerprint::FindType", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindType((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_type_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","TypeID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1); result = (char *)(arg1)->TypeID();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFingerprint(OpenBabel::OBFingerprint *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBFingerprint_set_bit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ; unsigned int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","SetBit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","SetBit", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","SetBit", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SetBit", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); (arg1)->SetBit(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_get_bit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ; unsigned int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; unsigned int val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","GetBit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1); {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","GetBit", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","GetBit", 2, argv[0])); }
     arg2 = ptr; }  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","GetBit", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3);
  result = (bool)(arg1)->GetBit((std::vector< unsigned int,std::allocator< unsigned int > > const &)*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_fold(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ; unsigned int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","Fold", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","Fold", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","Fold", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","Fold", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); (arg1)->Fold(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_get_fingerprint__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg3 = 0 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; int val4 ; int ecode4 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","GetFingerprint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetFingerprint", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetFingerprint", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetFingerprint", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp3);
  ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","GetFingerprint", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); result = (bool)(arg1)->GetFingerprint(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_get_fingerprint__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","GetFingerprint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetFingerprint", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetFingerprint", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","GetFingerprint", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp3);
  result = (bool)(arg1)->GetFingerprint(arg2,*arg3); vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_get_fingerprint(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_OBFingerprint_get_fingerprint__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBFingerprint_get_fingerprint__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBFingerprint.get_fingerprint", 
  "    bool OBFingerprint.get_fingerprint(OpenBabel::OBBase *pOb, std::vector< unsigned int,std::allocator< unsigned int > > &fp, int nbits)\n"
  "    bool OBFingerprint.get_fingerprint(OpenBabel::OBBase *pOb, std::vector< unsigned int,std::allocator< unsigned int > > &fp)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFingerprint *arg1 = (OpenBabel::OBFingerprint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFingerprint *","Flags", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFingerprint * >(argp1); result = (unsigned int)(arg1)->Flags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_tanimoto__SWIG_0(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int,std::allocator< unsigned int > > *arg1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ; int res1 = SWIG_OLDOBJ ; int res2 = SWIG_OLDOBJ ;
  double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","OpenBabel::OBFingerprint::Tanimoto", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","OpenBabel::OBFingerprint::Tanimoto", 1, argv[0])); }
     arg1 = ptr; }  {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res2 = swig::asptr(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","OpenBabel::OBFingerprint::Tanimoto", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","OpenBabel::OBFingerprint::Tanimoto", 2, argv[1])); }
     arg2 = ptr; } 
  result = (double)OpenBabel::OBFingerprint::Tanimoto((std::vector< unsigned int,std::allocator< unsigned int > > const &)*arg1,(std::vector< unsigned int,std::allocator< unsigned int > > const &)*arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res1)) delete arg1;
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_tanimoto__SWIG_1(int argc, VALUE *argv, VALUE self) {
  std::vector< unsigned int,std::allocator< unsigned int > > *arg1 = 0 ; unsigned int *arg2 = (unsigned int *) 0 ;
  int res1 = SWIG_OLDOBJ ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res1 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","OpenBabel::OBFingerprint::Tanimoto", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","OpenBabel::OBFingerprint::Tanimoto", 1, argv[0])); }
     arg1 = ptr; }  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_unsigned_int, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "unsigned int const *","OpenBabel::OBFingerprint::Tanimoto", 2, argv[1] ));  }
   arg2 = reinterpret_cast< unsigned int * >(argp2);
  result = (double)OpenBabel::OBFingerprint::Tanimoto((std::vector< unsigned int,std::allocator< unsigned int > > const &)*arg1,(unsigned int const *)arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); if (SWIG_IsNewObj(res1)) delete arg1; return vresult; fail:
  if (SWIG_IsNewObj(res1)) delete arg1; return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_tanimoto(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs; if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 2) { int _v = 0;
    { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_unsigned_int, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBFingerprint_tanimoto__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBFingerprint_tanimoto__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBFingerprint.tanimoto", 
  "    double OBFingerprint.tanimoto(std::vector< unsigned int,std::allocator< unsigned int > > const &vec1, std::vector< unsigned int,std::allocator< unsigned int > > const &vec2)\n"
  "    double OBFingerprint.tanimoto(std::vector< unsigned int,std::allocator< unsigned int > > const &vec1, unsigned int const *p2)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_getbitsperint(int argc, VALUE *argv, VALUE self) { unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (unsigned int)OpenBabel::OBFingerprint::Getbitsperint();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFingerprint_find_fingerprint(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBFingerprint *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBFingerprint::FindFingerprint", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBFingerprint *)OpenBabel::OBFingerprint::FindFingerprint((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
swig_class SwigClassFptIndexHeader;

SWIGINTERN VALUE _wrap_FptIndexHeader_headerlength_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","headerlength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","headerlength", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); if (arg1) (arg1)->headerlength = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_headerlength_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","headerlength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); result = (unsigned int) ((arg1)->headerlength);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_nEntries_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","nEntries", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","nEntries", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); if (arg1) (arg1)->nEntries = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_nEntries_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","nEntries", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); result = (unsigned int) ((arg1)->nEntries);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_words_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","words", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","words", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); if (arg1) (arg1)->words = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_words_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","words", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); result = (unsigned int) ((arg1)->words);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_fpid_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; char *arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  char temp2[16] ; int res2 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","fpid", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); res2 = SWIG_AsCharArray(argv[0], temp2, 16);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [16]","fpid", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(temp2); if (arg2) memcpy(arg1->fpid,arg2,16*sizeof(char));
  else memset(arg1->fpid,0,16*sizeof(char)); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_fpid_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","fpid", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); result = (char *)(char *) ((arg1)->fpid); { size_t size = 16;
    while (size && (result[size - 1] == '\0')) --size; vresult = SWIG_FromCharPtrAndSize(result, size); }  return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_datafilename_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; char *arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  char temp2[256] ; int res2 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","datafilename", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); res2 = SWIG_AsCharArray(argv[0], temp2, 256);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char [256]","datafilename", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(temp2); if (arg2) memcpy(arg1->datafilename,arg2,256*sizeof(char));
  else memset(arg1->datafilename,0,256*sizeof(char)); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndexHeader_datafilename_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndexHeader *arg1 = (OpenBabel::FptIndexHeader *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader *","datafilename", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp1); result = (char *)(char *) ((arg1)->datafilename); {
    size_t size = 256; while (size && (result[size - 1] == '\0')) --size; vresult = SWIG_FromCharPtrAndSize(result, size); } 
  return vresult; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_FptIndexHeader_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_FptIndexHeader_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FptIndexHeader);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_FptIndexHeader(int argc, VALUE *argv, VALUE self) { OpenBabel::FptIndexHeader *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::FptIndexHeader *)new OpenBabel::FptIndexHeader(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_FptIndexHeader(OpenBabel::FptIndexHeader *arg1) {
    delete arg1;
}

swig_class SwigClassFptIndex;

SWIGINTERN VALUE _wrap_FptIndex_header_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; OpenBabel::FptIndexHeader *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","header", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__FptIndexHeader,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::FptIndexHeader const &","header", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::FptIndexHeader const &","header", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::FptIndexHeader * >(argp2); if (arg1) (arg1)->header = *arg2; return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_header_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::FptIndexHeader *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","header", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1); result = (OpenBabel::FptIndexHeader *) & ((arg1)->header);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_fptdata_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","fptdata", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1); {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","fptdata", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","fptdata", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->fptdata = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_fptdata_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","fptdata", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *) & ((arg1)->fptdata);
  vresult = swig::from(static_cast< std::vector<unsigned int,std::allocator< unsigned int > > >(*result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_seekdata_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; std::vector< unsigned int,std::allocator< unsigned int > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","seekdata", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1); {
    std::vector<unsigned int,std::allocator< unsigned int > > *ptr = (std::vector<unsigned int,std::allocator< unsigned int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > const &","seekdata", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > const &","seekdata", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->seekdata = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_seekdata_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","seekdata", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  result = (std::vector< unsigned int,std::allocator< unsigned int > > *) & ((arg1)->seekdata);
  vresult = swig::from(static_cast< std::vector<unsigned int,std::allocator< unsigned int > > >(*result)); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_read(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; std::istream *arg2 = (std::istream *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","Read", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream *","Read", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::istream * >(argp2); result = (bool)(arg1)->Read(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FptIndex_check_fp(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","CheckFP", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1); result = (OpenBabel::OBFingerprint *)(arg1)->CheckFP();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); return vresult; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_FptIndex_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_FptIndex_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FptIndex);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_FptIndex(int argc, VALUE *argv, VALUE self) { OpenBabel::FptIndex *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::FptIndex *)new OpenBabel::FptIndex(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_FptIndex(OpenBabel::FptIndex *arg1) {
    delete arg1;
}

swig_class SwigClassFastSearch;

SWIGINTERN VALUE _wrap_FastSearch_read_index_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","ReadIndexFile", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","ReadIndexFile", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  result = (arg1)->ReadIndexFile(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_read_index(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; std::istream *arg2 = (std::istream *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","ReadIndex", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__istream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream *","ReadIndex", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::istream * >(argp2); result = (arg1)->ReadIndex(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_FastSearch(OpenBabel::FastSearch *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_FastSearch_find(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg3 = 0 ; unsigned int arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; unsigned int val4 ; int ecode4 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","Find", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Find", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","Find", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","Find", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","Find", 4, argv[2] )); }  
  arg4 = static_cast< unsigned int >(val4); result = (bool)(arg1)->Find(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_find_match(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > *arg3 = 0 ; unsigned int arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; unsigned int val4 ; int ecode4 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","FindMatch", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","FindMatch", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::vector< unsigned int,std::allocator< unsigned int > > &","FindMatch", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< unsigned int,std::allocator< unsigned int > > &","FindMatch", 3, argv[1])); }
   arg3 = reinterpret_cast< std::vector< unsigned int,std::allocator< unsigned int > > * >(argp3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "unsigned int","FindMatch", 4, argv[2] )); }  
  arg4 = static_cast< unsigned int >(val4); result = (bool)(arg1)->FindMatch(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_find_similar__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap< double,unsigned int > *arg3 = 0 ; double arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double val4 ; int ecode4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","FindSimilar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","FindSimilar", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapT_double_unsigned_int_t,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::multimap< double,unsigned int > &","FindSimilar", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::multimap< double,unsigned int > &","FindSimilar", 3, argv[1])); }
   arg3 = reinterpret_cast< std::multimap< double,unsigned int > * >(argp3); ecode4 = SWIG_AsVal_double(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","FindSimilar", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); result = (bool)(arg1)->FindSimilar(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_find_similar__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap< double,unsigned int > *arg3 = 0 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; int val4 ; int ecode4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","FindSimilar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","FindSimilar", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapT_double_unsigned_int_t,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::multimap< double,unsigned int > &","FindSimilar", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::multimap< double,unsigned int > &","FindSimilar", 3, argv[1])); }
   arg3 = reinterpret_cast< std::multimap< double,unsigned int > * >(argp3); ecode4 = SWIG_AsVal_int(argv[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","FindSimilar", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); result = (bool)(arg1)->FindSimilar(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_find_similar__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::multimap< double,unsigned int > *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch *","FindSimilar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","FindSimilar", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__multimapT_double_unsigned_int_t,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::multimap< double,unsigned int > &","FindSimilar", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::multimap< double,unsigned int > &","FindSimilar", 3, argv[1])); }
   arg3 = reinterpret_cast< std::multimap< double,unsigned int > * >(argp3); result = (bool)(arg1)->FindSimilar(arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_find_similar(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_FastSearch_find_similar__SWIG_2(nargs, args, self);}  if (argc == 4) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[3], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_FastSearch_find_similar__SWIG_1(nargs, args, self);}  check_2: if (argc == 4) {
    return _wrap_FastSearch_find_similar__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "FastSearch.find_similar", 
  "    bool FastSearch.find_similar(OpenBabel::OBBase *pOb, std::multimap< double,unsigned int > &SeekposMap, double MinTani)\n"
  "    bool FastSearch.find_similar(OpenBabel::OBBase *pOb, std::multimap< double,unsigned int > &SeekposMap, int nCandidates)\n"
  "    bool FastSearch.find_similar(OpenBabel::OBBase *pOb, std::multimap< double,unsigned int > &SeekposMap)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_get_fingerprint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBFingerprint *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch const *","GetFingerprint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  result = (OpenBabel::OBFingerprint *)((OpenBabel::FastSearch const *)arg1)->GetFingerprint();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFingerprint, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_FastSearch_get_index_header(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearch *arg1 = (OpenBabel::FastSearch *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::FptIndexHeader *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearch, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearch const *","GetIndexHeader", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::FastSearch * >(argp1);
  result = (OpenBabel::FptIndexHeader *) &((OpenBabel::FastSearch const *)arg1)->GetIndexHeader();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__FptIndexHeader, 0 |  0 ); return vresult; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_FastSearch_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_FastSearch_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FastSearch);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_FastSearch(int argc, VALUE *argv, VALUE self) { OpenBabel::FastSearch *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::FastSearch *)new OpenBabel::FastSearch(); DATA_PTR(self) = result; return self; fail: return Qnil; }
swig_class SwigClassFastSearchIndexer;

SWIGINTERN VALUE _wrap_new_FastSearchIndexer__SWIG_0(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ; std::string *arg3 = 0 ; int arg4 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; int val4 ; int ecode4 = 0 ;
  OpenBabel::FastSearchIndexer *result = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string &","OpenBabel::FastSearchIndexer", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::FastSearchIndexer", 1, argv[0])); }
   arg1 = reinterpret_cast< std::string * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","OpenBabel::FastSearchIndexer", 2, argv[1] ));  }
   arg2 = reinterpret_cast< std::ostream * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string &","OpenBabel::FastSearchIndexer", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::FastSearchIndexer", 3, argv[2])); }
   arg3 = reinterpret_cast< std::string * >(argp3); ecode4 = SWIG_AsVal_int(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","OpenBabel::FastSearchIndexer", 4, argv[3] )); }
    arg4 = static_cast< int >(val4);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(*arg1,arg2,*arg3,arg4); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_FastSearchIndexer__SWIG_1(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ;
  std::ostream *arg2 = (std::ostream *) 0 ; std::string *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; OpenBabel::FastSearchIndexer *result = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string &","OpenBabel::FastSearchIndexer", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::FastSearchIndexer", 1, argv[0])); }
   arg1 = reinterpret_cast< std::string * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","OpenBabel::FastSearchIndexer", 2, argv[1] ));  }
   arg2 = reinterpret_cast< std::ostream * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string &","OpenBabel::FastSearchIndexer", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","OpenBabel::FastSearchIndexer", 3, argv[2])); }
   arg3 = reinterpret_cast< std::string * >(argp3);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(*arg1,arg2,*arg3); DATA_PTR(self) = result;
  return self; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_FastSearchIndexer_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_FastSearchIndexer_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__FastSearchIndexer);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_FastSearchIndexer__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FptIndex *arg1 = (OpenBabel::FptIndex *) 0 ; std::ostream *arg2 = (std::ostream *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::FastSearchIndexer *result = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__FptIndex, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FptIndex *","OpenBabel::FastSearchIndexer", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::FptIndex * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","OpenBabel::FastSearchIndexer", 2, argv[1] ));  }
   arg2 = reinterpret_cast< std::ostream * >(argp2);
  result = (OpenBabel::FastSearchIndexer *)new OpenBabel::FastSearchIndexer(arg1,arg2); DATA_PTR(self) = result; return self;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_FastSearchIndexer(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs; if (argc > 4) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 2) {
    return _wrap_new_FastSearchIndexer__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_new_FastSearchIndexer__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_new_FastSearchIndexer__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "FastSearchIndexer.new", 
  "    FastSearchIndexer.new(std::string &datafilename, std::ostream *os, std::string &fpid, int FptBits)\n"
  "    FastSearchIndexer.new(std::string &datafilename, std::ostream *os, std::string &fpid)\n"
  "    FastSearchIndexer.new(OpenBabel::FptIndex *pindex, std::ostream *os)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_FastSearchIndexer(OpenBabel::FastSearchIndexer *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_FastSearchIndexer_add(int argc, VALUE *argv, VALUE self) {
  OpenBabel::FastSearchIndexer *arg1 = (OpenBabel::FastSearchIndexer *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::streampos arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 ; int res3 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__FastSearchIndexer, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::FastSearchIndexer *","Add", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::FastSearchIndexer * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Add", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); {
    res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__streampos,  0 ); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::streampos","Add", 3, argv[1] ));  }   
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::streampos","Add", 3, argv[1])); }
     else { arg3 = *(reinterpret_cast< std::streampos * >(argp3)); }  }  result = (bool)(arg1)->Add(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
swig_class SwigClassOBDescriptor;

SWIGINTERN VALUE _wrap_OBDescriptor_default(int argc, VALUE *argv, VALUE self) { OpenBabel::OBDescriptor **result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBDescriptor **) &OpenBabel::OBDescriptor::Default();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_OpenBabel__OBDescriptor, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBDescriptor__SWIG_0(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; bool arg2 ;
  int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; bool val2 ; int ecode2 = 0 ; OpenBabel::OBDescriptor *result = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBDescriptor", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); ecode2 = SWIG_AsVal_bool(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","OpenBabel::OBDescriptor", 2, argv[1] )); }  
  arg2 = static_cast< bool >(val2); result = (OpenBabel::OBDescriptor *)new OpenBabel::OBDescriptor((char const *)arg1,arg2);
  DATA_PTR(self) = result; if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return self; fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBDescriptor_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBDescriptor_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBDescriptor);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBDescriptor__SWIG_1(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBDescriptor *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBDescriptor", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = (OpenBabel::OBDescriptor *)new OpenBabel::OBDescriptor((char const *)arg1);
  DATA_PTR(self) = result; if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return self; fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_new_OBDescriptor(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii; argc = nargs;
  if (argc > 2) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) {
    return _wrap_new_OBDescriptor__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_new_OBDescriptor__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 2, "OBDescriptor.new", 
  "    OBDescriptor.new(char const *ID, bool IsDefault)\n" "    OBDescriptor.new(char const *ID)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_find_type(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBDescriptor *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBDescriptor::FindType", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBDescriptor *)OpenBabel::OBDescriptor::FindType((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_type_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","TypeID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1); result = (char *)(arg1)->TypeID();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_predict(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","Predict", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Predict", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (double)(arg1)->Predict(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_predict_and_save(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","PredictAndSave", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","PredictAndSave", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (double)(arg1)->PredictAndSave(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_get_string_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::string *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ;
  double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","GetStringValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","GetStringValue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__string,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string &","GetStringValue", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","GetStringValue", 3, argv[1])); }
   arg3 = reinterpret_cast< std::string * >(argp3); result = (double)(arg1)->GetStringValue(arg2,*arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_compare(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ;
  std::istream *arg3 = 0 ; bool arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; bool val4 ; int ecode4 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","Compare", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Compare", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::istream &","Compare", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","Compare", 3, argv[1])); }
   arg3 = reinterpret_cast< std::istream * >(argp3); ecode4 = SWIG_AsVal_bool(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "bool","Compare", 4, argv[2] )); }  
  arg4 = static_cast< bool >(val4); result = (bool)(arg1)->Compare(arg2,*arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_display__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; std::string *arg2 = 0 ; char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ;
  int alloc3 = 0 ; int res4 ; char *buf4 = 0 ; int alloc4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","Display", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Display", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Display", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Display", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","Display", 4, argv[2] )); } 
  arg4 = reinterpret_cast< char * >(buf4); result = (bool)(arg1)->Display(*arg2,(char const *)arg3,(char const *)arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return vresult; fail: if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_display__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBDescriptor *arg1 = (OpenBabel::OBDescriptor *) 0 ; std::string *arg2 = 0 ; char *arg3 = (char *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 ; char *buf3 = 0 ; int alloc3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBDescriptor, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBDescriptor *","Display", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBDescriptor * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","Display", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","Display", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); res3 = SWIG_AsCharPtrAndSize(argv[1], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "char const *","Display", 3, argv[1] )); } 
  arg3 = reinterpret_cast< char * >(buf3); result = (bool)(arg1)->Display(*arg2,(char const *)arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return vresult; fail:
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3; return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_display(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { return _wrap_OBDescriptor_display__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBDescriptor_display__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBDescriptor.display", 
  "    bool OBDescriptor.display(std::string &txt, char const *param, char const *ID)\n"
  "    bool OBDescriptor.display(std::string &txt, char const *param)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_filter_compare(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::istream *arg2 = 0 ; bool arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","OpenBabel::OBDescriptor::FilterCompare", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::istream &","OpenBabel::OBDescriptor::FilterCompare", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::istream &","OpenBabel::OBDescriptor::FilterCompare", 2, argv[1])); }
   arg2 = reinterpret_cast< std::istream * >(argp2); ecode3 = SWIG_AsVal_bool(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","OpenBabel::OBDescriptor::FilterCompare", 3, argv[2] )); }
    arg3 = static_cast< bool >(val3); result = (bool)OpenBabel::OBDescriptor::FilterCompare(arg1,*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_add_properties(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","OpenBabel::OBDescriptor::AddProperties", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBDescriptor::AddProperties", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBDescriptor::AddProperties", 2, argv[1])); }
     arg2 = ptr; }  OpenBabel::OBDescriptor::AddProperties(arg1,(std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_delete_properties(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","OpenBabel::OBDescriptor::DeleteProperties", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBDescriptor::DeleteProperties", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBDescriptor::DeleteProperties", 2, argv[1])); }
     arg2 = ptr; }  OpenBabel::OBDescriptor::DeleteProperties(arg1,(std::string const &)*arg2);
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBDescriptor_get_values(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; std::string result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","OpenBabel::OBDescriptor::GetValues", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBDescriptor::GetValues", 2, argv[1] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBDescriptor::GetValues", 2, argv[1])); }
     arg2 = ptr; }  result = OpenBabel::OBDescriptor::GetValues(arg1,(std::string const &)*arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult;
  fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN void
free_OpenBabel_OBDescriptor(OpenBabel::OBDescriptor *arg1) {
    delete arg1;
}

swig_class SwigClassLineSearchType;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_LineSearchType_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_LineSearchType_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__LineSearchType);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_LineSearchType(int argc, VALUE *argv, VALUE self) { OpenBabel::LineSearchType *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::LineSearchType *)new OpenBabel::LineSearchType(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_LineSearchType(OpenBabel::LineSearchType *arg1) {
    delete arg1;
}

swig_class SwigClassOBFFParameter;

SWIGINTERN VALUE _wrap_OBFFParameter_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","a", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->a = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (int) ((arg1)->a);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","b", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->b = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (int) ((arg1)->b);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","c", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->c = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (int) ((arg1)->c);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","d", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->d = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (int) ((arg1)->d);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","_a", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","_a", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_a = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (std::string *) & ((arg1)->_a);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","_b", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","_b", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_b = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (std::string *) & ((arg1)->_b);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","_c", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","_c", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_c = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (std::string *) & ((arg1)->_c);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","_d", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","_d", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_d = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); result = (std::string *) & ((arg1)->_d);
  vresult = SWIG_From_std_string(static_cast< std::string >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__ipar_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; std::vector< int,std::allocator< int > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_ipar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > const &","_ipar", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > const &","_ipar", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_ipar = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__ipar_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_ipar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (std::vector< int,std::allocator< int > > *) & ((arg1)->_ipar);
  vresult = swig::from(static_cast< std::vector<int,std::allocator< int > > >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__dpar_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; std::vector< double,std::allocator< double > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_dpar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); {
    std::vector<double,std::allocator< double > > *ptr = (std::vector<double,std::allocator< double > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< double,std::allocator< double > > const &","_dpar", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< double,std::allocator< double > > const &","_dpar", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (arg1)->_dpar = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBFFParameter__dpar_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< double,std::allocator< double > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","_dpar", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->_dpar);
  vresult = swig::from(static_cast< std::vector<double,std::allocator< double > > >(*result)); return vresult; fail:
  return Qnil; }

/*
  Document-method: OpenBabel::OBFFParameter.clear

  call-seq:
    clear

Clear OBFFParameter contents.
*/
SWIGINTERN VALUE _wrap_OBFFParameter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFParameter *arg1 = (OpenBabel::OBFFParameter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFParameter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFParameter *","clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFParameter * >(argp1); (arg1)->clear(); return Qnil; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBFFParameter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBFFParameter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFParameter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBFFParameter(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFFParameter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFFParameter *)new OpenBabel::OBFFParameter(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFFParameter(OpenBabel::OBFFParameter *arg1) {
    delete arg1;
}

swig_class SwigClassOBFFCalculation2;

SWIGINTERN VALUE _wrap_OBFFCalculation2_energy_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","energy", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","energy", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->energy = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_energy_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","energy", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (double) ((arg1)->energy);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","a", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->a = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","b", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->b = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_idx_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","idx_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","idx_a", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); if (arg1) (arg1)->idx_a = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_idx_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","idx_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (int) ((arg1)->idx_a);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_idx_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","idx_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","idx_b", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); if (arg1) (arg1)->idx_b = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_idx_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","idx_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (int) ((arg1)->idx_b);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_pos_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","pos_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","pos_a", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); if (arg1) (arg1)->pos_a = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_pos_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","pos_a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (double *) ((arg1)->pos_a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_pos_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","pos_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","pos_b", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); if (arg1) (arg1)->pos_b = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_pos_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","pos_b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (double *) ((arg1)->pos_b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_force_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; double *arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","force_a", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [3]","force_a", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); { if (arg2) { size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->force_a[ii] = arg2[ii]; }  else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""force_a""' of type '""double [3]""'"); }  }
   return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_force_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","force_a", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (double *)(double *) ((arg1)->force_a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_force_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; double *arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","force_b", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [3]","force_b", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); { if (arg2) { size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->force_b[ii] = arg2[ii]; }  else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""force_b""' of type '""double [3]""'"); }  }
   return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation2_force_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","force_b", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); result = (double *)(double *) ((arg1)->force_b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFFCalculation2(OpenBabel::OBFFCalculation2 *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBFFCalculation2_setup_pointers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation2 *arg1 = (OpenBabel::OBFFCalculation2 *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation2, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation2 *","SetupPointers", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation2 * >(argp1); (arg1)->SetupPointers(); return Qnil; fail: return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBFFCalculation2_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBFFCalculation2_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFCalculation2);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBFFCalculation2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFFCalculation2 *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFFCalculation2 *)new OpenBabel::OBFFCalculation2(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
swig_class SwigClassOBFFCalculation3;

SWIGINTERN VALUE _wrap_OBFFCalculation3_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","c", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->c = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_idx_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","idx_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","idx_c", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); if (arg1) (arg1)->idx_c = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_idx_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","idx_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1); result = (int) ((arg1)->idx_c);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_pos_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","pos_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","pos_c", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); if (arg1) (arg1)->pos_c = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_pos_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","pos_c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1); result = (double *) ((arg1)->pos_c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_force_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; double *arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","force_c", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [3]","force_c", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); { if (arg2) { size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->force_c[ii] = arg2[ii]; }  else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""force_c""' of type '""double [3]""'"); }  }
   return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation3_force_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation3 *arg1 = (OpenBabel::OBFFCalculation3 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation3, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation3 *","force_c", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation3 * >(argp1); result = (double *)(double *) ((arg1)->force_c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFFCalculation3(OpenBabel::OBFFCalculation3 *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBFFCalculation3_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBFFCalculation3_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFCalculation3);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBFFCalculation3(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFFCalculation3 *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFFCalculation3 *)new OpenBabel::OBFFCalculation3(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
swig_class SwigClassOBFFCalculation4;

SWIGINTERN VALUE _wrap_OBFFCalculation4_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","d", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->d = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->d);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_idx_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","idx_d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","idx_d", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); if (arg1) (arg1)->idx_d = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_idx_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","idx_d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1); result = (int) ((arg1)->idx_d);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_pos_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","pos_d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","pos_d", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); if (arg1) (arg1)->pos_d = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_pos_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","pos_d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1); result = (double *) ((arg1)->pos_d);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_force_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; double *arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","force_d", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double [3]","force_d", 2, argv[0] ));  }  
  arg2 = reinterpret_cast< double * >(argp2); { if (arg2) { size_t ii = 0;
      for (; ii < (size_t)3; ++ii) arg1->force_d[ii] = arg2[ii]; }  else {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in variable '""force_d""' of type '""double [3]""'"); }  }
   return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFCalculation4_force_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFCalculation4 *arg1 = (OpenBabel::OBFFCalculation4 *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFCalculation4, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFCalculation4 *","force_d", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFCalculation4 * >(argp1); result = (double *)(double *) ((arg1)->force_d);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFFCalculation4(OpenBabel::OBFFCalculation4 *arg1) {
    delete arg1;
}

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBFFCalculation4_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBFFCalculation4_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFCalculation4);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBFFCalculation4(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFFCalculation4 *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFFCalculation4 *)new OpenBabel::OBFFCalculation4(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
swig_class SwigClassOBFFConstraint;

SWIGINTERN VALUE _wrap_OBFFConstraint_factor_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","factor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","factor", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->factor = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_factor_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","factor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (double) ((arg1)->factor);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_constraint_value_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","constraint_value", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","constraint_value", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->constraint_value = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_constraint_value_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","constraint_value", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (double) ((arg1)->constraint_value);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_rab0_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","rab0", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","rab0", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->rab0 = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_rab0_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","rab0", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (double) ((arg1)->rab0);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_rbc0_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","rbc0", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","rbc0", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); if (arg1) (arg1)->rbc0 = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_rbc0_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","rbc0", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (double) ((arg1)->rbc0);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_type_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","type", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","type", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); if (arg1) (arg1)->type = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_type_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","type", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (int) ((arg1)->type);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_ia_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","ia", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ia", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->ia = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_ia_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","ia", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (int) ((arg1)->ia);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_ib_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","ib", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ib", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->ib = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_ib_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","ib", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (int) ((arg1)->ib);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_ic_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","ic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ic", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->ic = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_ic_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","ic", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (int) ((arg1)->ic);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_id_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","id", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","id", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); if (arg1) (arg1)->id = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_id_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","id", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (int) ((arg1)->id);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_a_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","a", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->a = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_a_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","a", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->a);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_b_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","b", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->b = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_b_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","b", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->b);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_c_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","c", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->c = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_c_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","c", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->c);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_d_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, SWIG_POINTER_DISOWN |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","d", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); if (arg1) (arg1)->d = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_d_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","d", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::OBAtom *) ((arg1)->d);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_grada_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","grada", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","grada", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","grada", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); if (arg1) (arg1)->grada = *arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_grada_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","grada", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::vector3 *) & ((arg1)->grada);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_gradb_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","gradb", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","gradb", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","gradb", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); if (arg1) (arg1)->gradb = *arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_gradb_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","gradb", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::vector3 *) & ((arg1)->gradb);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_gradc_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","gradc", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","gradc", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","gradc", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); if (arg1) (arg1)->gradc = *arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_gradc_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","gradc", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::vector3 *) & ((arg1)->gradc);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_gradd_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","gradd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","gradd", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","gradd", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); if (arg1) (arg1)->gradd = *arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraint_gradd_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","gradd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); result = (OpenBabel::vector3 *) & ((arg1)->gradd);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBFFConstraint_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBFFConstraint_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFConstraint);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBFFConstraint(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFFConstraint *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFFConstraint *)new OpenBabel::OBFFConstraint(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFFConstraint(OpenBabel::OBFFConstraint *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBFFConstraint_get_gradient(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraint *arg1 = (OpenBabel::OBFFConstraint *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraint, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraint *","GetGradient", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraint * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetGradient", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->GetGradient(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
swig_class SwigClassOBFFConstraints;

#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBFFConstraints_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBFFConstraints_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBFFConstraints);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBFFConstraints(int argc, VALUE *argv, VALUE self) { OpenBabel::OBFFConstraints *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBFFConstraints *)new OpenBabel::OBFFConstraints(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBFFConstraints(OpenBabel::OBFFConstraints *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBFFConstraints_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); (arg1)->Clear(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_energy(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","GetConstraintEnergy", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); result = (double)(arg1)->GetConstraintEnergy();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_gradient(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","GetGradient", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetGradient", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->GetGradient(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_setup(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","Setup", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","Setup", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","Setup", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (arg1)->Setup(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_set_factor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","SetFactor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetFactor", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetFactor(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_ignore(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddIgnore", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddIgnore", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->AddIgnore(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_atom_constraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddAtomConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddAtomConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->AddAtomConstraint(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_atom_xconstraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddAtomXConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddAtomXConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->AddAtomXConstraint(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_atom_yconstraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddAtomYConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddAtomYConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->AddAtomYConstraint(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_atom_zconstraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddAtomZConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddAtomZConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->AddAtomZConstraint(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_distance_constraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; int arg3 ; double arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddDistanceConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddDistanceConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","AddDistanceConstraint", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","AddDistanceConstraint", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (arg1)->AddDistanceConstraint(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_angle_constraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; int arg3 ; int arg4 ; double arg5 ;
  void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  double val5 ; int ecode5 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddAngleConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddAngleConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","AddAngleConstraint", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","AddAngleConstraint", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); ecode5 = SWIG_AsVal_double(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","AddAngleConstraint", 5, argv[3] )); }  
  arg5 = static_cast< double >(val5); (arg1)->AddAngleConstraint(arg2,arg3,arg4,arg5); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_add_torsion_constraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; int arg3 ; int arg4 ; int arg5 ;
  double arg6 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ;
  int ecode4 = 0 ; int val5 ; int ecode5 = 0 ; double val6 ; int ecode6 = 0 ; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","AddTorsionConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","AddTorsionConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","AddTorsionConstraint", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","AddTorsionConstraint", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","AddTorsionConstraint", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); ecode6 = SWIG_AsVal_double(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "double","AddTorsionConstraint", 6, argv[4] )); }  
  arg6 = static_cast< double >(val6); (arg1)->AddTorsionConstraint(arg2,arg3,arg4,arg5,arg6); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_delete_constraint(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","DeleteConstraint", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","DeleteConstraint", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->DeleteConstraint(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_factor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","GetFactor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); result = (double)(arg1)->GetFactor();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","Size", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1);
  result = (int)((OpenBabel::OBFFConstraints const *)arg1)->Size(); vresult = SWIG_From_int(static_cast< int >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","GetConstraintType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConstraintType", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)((OpenBabel::OBFFConstraints const *)arg1)->GetConstraintType(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_value(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","GetConstraintValue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConstraintValue", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)((OpenBabel::OBFFConstraints const *)arg1)->GetConstraintValue(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_atom_a(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","GetConstraintAtomA", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConstraintAtomA", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)((OpenBabel::OBFFConstraints const *)arg1)->GetConstraintAtomA(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_atom_b(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","GetConstraintAtomB", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConstraintAtomB", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)((OpenBabel::OBFFConstraints const *)arg1)->GetConstraintAtomB(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_atom_c(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","GetConstraintAtomC", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConstraintAtomC", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)((OpenBabel::OBFFConstraints const *)arg1)->GetConstraintAtomC(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_constraint_atom_d(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints const *","GetConstraintAtomD", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetConstraintAtomD", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (int)((OpenBabel::OBFFConstraints const *)arg1)->GetConstraintAtomD(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_is_ignored(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","IsIgnored", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsIgnored", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->IsIgnored(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_is_fixed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","IsFixed", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsFixed", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->IsFixed(arg2); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_is_xfixed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","IsXFixed", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsXFixed", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->IsXFixed(arg2); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_is_yfixed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","IsYFixed", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsYFixed", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->IsYFixed(arg2); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_is_zfixed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","IsZFixed", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsZFixed", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->IsZFixed(arg2); vresult = SWIG_From_bool(static_cast< bool >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBFFConstraints_get_ignored_bit_vec(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBFFConstraints *arg1 = (OpenBabel::OBFFConstraints *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBitVec result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints *","GetIgnoredBitVec", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp1); result = (arg1)->GetIgnoredBitVec();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBitVec(static_cast< const OpenBabel::OBBitVec& >(result))), SWIGTYPE_p_OpenBabel__OBBitVec, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
swig_class SwigClassOBForceField;

SWIGINTERN VALUE _wrap_OBForceField_default(int argc, VALUE *argv, VALUE self) { OpenBabel::OBForceField **result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBForceField **) &OpenBabel::OBForceField::Default();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_OpenBabel__OBForceField, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_find_type(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ;
  char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBForceField *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBForceField::FindType", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindType((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_make_new_instance(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBForceField *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","MakeNewInstance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (OpenBabel::OBForceField *)(arg1)->MakeNewInstance();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBForceField(OpenBabel::OBForceField *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBForceField_type_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","TypeID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (char *)(arg1)->TypeID();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_find_force_field__SWIG_0(int argc, VALUE *argv, VALUE self) { std::string *arg1 = 0 ;
  int res1 = SWIG_OLDOBJ ; OpenBabel::OBForceField *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;}  { std::string *ptr = (std::string *)0;
    res1 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "std::string const &","OpenBabel::OBForceField::FindForceField", 1, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","OpenBabel::OBForceField::FindForceField", 1, argv[0])); }
     arg1 = ptr; }  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindForceField((std::string const &)*arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (SWIG_IsNewObj(res1)) delete arg1; return vresult; fail: if (SWIG_IsNewObj(res1)) delete arg1; return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_find_force_field__SWIG_1(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ;
  int res1 ; char *buf1 = 0 ; int alloc1 = 0 ; OpenBabel::OBForceField *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBForceField::FindForceField", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1);
  result = (OpenBabel::OBForceField *)OpenBabel::OBForceField::FindForceField((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_find_force_field(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii;
  argc = nargs; if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 1) { int _v = 0;
    { int res = SWIG_AsPtr_std_string(argv[0], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_1;
    return _wrap_OBForceField_find_force_field__SWIG_0(nargs, args, self);}  check_1: if (argc == 1) {
    return _wrap_OBForceField_find_force_field__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBForceField.find_force_field", 
  "    OpenBabel::OBForceField * OBForceField.find_force_field(std::string const &ID)\n"
  "    OpenBabel::OBForceField * OBForceField.find_force_field(char const *ID)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_parameter_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetParameterFile", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetParameterFile", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetParameterFile", 2, argv[0])); }
     arg2 = ptr; }  (arg1)->SetParameterFile((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil;
  fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_unit(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetUnit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (arg1)->GetUnit();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_has_analytical_gradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","HasAnalyticalGradients", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->HasAnalyticalGradients();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_setup__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","Setup", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","Setup", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","Setup", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->Setup(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_setup__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ;
  OpenBabel::OBFFConstraints *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","Setup", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","Setup", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","Setup", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBFFConstraints,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints &","Setup", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBFFConstraints &","Setup", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp3); result = (bool)(arg1)->Setup(*arg2,*arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_setup(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBForceField_setup__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_setup__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBForceField.setup",  "    bool OBForceField.setup(OpenBabel::OBMol &mol)\n"
  "    bool OBForceField.setup(OpenBabel::OBMol &mol, OpenBabel::OBFFConstraints &constraints)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_parse_param_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ParseParamFile", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->ParseParamFile();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_types(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetTypes", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->SetTypes();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_formal_charges(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetFormalCharges", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->SetFormalCharges();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_partial_charges(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetPartialCharges", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->SetPartialCharges();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_setup_calculations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetupCalculations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->SetupCalculations();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_setup_pointers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetupPointers", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->SetupPointers();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_is_setup_needed(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","IsSetupNeeded", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","IsSetupNeeded", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","IsSetupNeeded", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->IsSetupNeeded(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_atom_types(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetAtomTypes", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","GetAtomTypes", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","GetAtomTypes", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->GetAtomTypes(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_partial_charges(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetPartialCharges", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","GetPartialCharges", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","GetPartialCharges", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->GetPartialCharges(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetCoordinates", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","GetCoordinates", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","GetCoordinates", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->GetCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_update_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","UpdateCoordinates", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","UpdateCoordinates", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","UpdateCoordinates", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->UpdateCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetConformers", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","GetConformers", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","GetConformers", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->GetConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_update_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","UpdateConformers", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","UpdateConformers", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","UpdateConformers", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->UpdateConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_coordinates(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetCoordinates", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","SetCoordinates", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","SetCoordinates", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->SetCoordinates(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_conformers(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBMol *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetConformers", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBMol,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol &","SetConformers", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMol &","SetConformers", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); result = (bool)(arg1)->SetConformers(*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_grid(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; double arg2 ; double arg3 ; char *arg4 = (char *) 0 ;
  double arg5 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; int res4 ;
  char *buf4 = 0 ; int alloc4 = 0 ; double val5 ; int ecode5 = 0 ; OpenBabel::OBGridData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 4) || (argc > 4)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetGrid", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","GetGrid", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","GetGrid", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","GetGrid", 4, argv[2] )); } 
  arg4 = reinterpret_cast< char * >(buf4); ecode5 = SWIG_AsVal_double(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "double","GetGrid", 5, argv[3] )); }  
  arg5 = static_cast< double >(val5); result = (OpenBabel::OBGridData *)(arg1)->GetGrid(arg2,arg3,(char const *)arg4,arg5);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGridData, 0 |  0 );
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return vresult; fail: if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_add_intra_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBBitVec *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","AddIntraGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","AddIntraGroup", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","AddIntraGroup", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2); (arg1)->AddIntraGroup(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_add_inter_group(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBBitVec *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","AddInterGroup", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","AddInterGroup", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","AddInterGroup", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2); (arg1)->AddInterGroup(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_add_inter_groups(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBBitVec *arg2 = 0 ;
  OpenBabel::OBBitVec *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","AddInterGroups", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","AddInterGroups", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","AddInterGroups", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec &","AddInterGroups", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec &","AddInterGroups", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::OBBitVec * >(argp3); (arg1)->AddInterGroups(*arg2,*arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_clear_groups(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ClearGroups", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->ClearGroups(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_has_groups(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","HasGroups", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->HasGroups();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_enable_cut_off(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","EnableCutOff", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","EnableCutOff", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); (arg1)->EnableCutOff(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_is_cut_off_enabled(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","IsCutOffEnabled", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->IsCutOffEnabled();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_vdwcut_off(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetVDWCutOff", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetVDWCutOff", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetVDWCutOff(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_vdwcut_off(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetVDWCutOff", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->GetVDWCutOff();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_electrostatic_cut_off(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetElectrostaticCutOff", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetElectrostaticCutOff", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (arg1)->SetElectrostaticCutOff(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_electrostatic_cut_off(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetElectrostaticCutOff", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->GetElectrostaticCutOff();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_update_frequency(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetUpdateFrequency", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetUpdateFrequency", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetUpdateFrequency(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_update_frequency(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetUpdateFrequency", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (int)(arg1)->GetUpdateFrequency();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_update_pairs_simple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","UpdatePairsSimple", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->UpdatePairsSimple(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_num_pairs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetNumPairs", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (unsigned int)(arg1)->GetNumPairs();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_enable_all_pairs(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","EnableAllPairs", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->EnableAllPairs(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_energy__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","Energy", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Energy", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->Energy(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_energy__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","Energy", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->Energy();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_energy(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_energy__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_energy__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.energy",  "    double OBForceField.energy(bool)\n"
  "    double OBForceField.energy()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_bond__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Bond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_Bond", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_Bond(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_bond__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Bond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_Bond();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_bond(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_bond__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_bond__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_bond",  "    double OBForceField.e_bond(bool)\n"
  "    double OBForceField.e_bond()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Angle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_Angle", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_Angle(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Angle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_Angle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_angle__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_angle__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_angle",  "    double OBForceField.e_angle(bool)\n"
  "    double OBForceField.e_angle()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_str_bnd__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_StrBnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_StrBnd", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_StrBnd(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_str_bnd__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_StrBnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_StrBnd();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_str_bnd(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_str_bnd__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_str_bnd__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_str_bnd",  "    double OBForceField.e_str_bnd(bool)\n"
  "    double OBForceField.e_str_bnd()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_torsion__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Torsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_Torsion", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_Torsion(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_torsion__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Torsion", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_Torsion();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_torsion(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_torsion__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_torsion__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_torsion",  "    double OBForceField.e_torsion(bool)\n"
  "    double OBForceField.e_torsion()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_oop__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_OOP", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_OOP", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_OOP(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_oop__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_OOP", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_OOP();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_oop(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_oop__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_oop__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_oop",  "    double OBForceField.e_oop(bool)\n"
  "    double OBForceField.e_oop()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_vdw__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_VDW", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_VDW", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_VDW(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_vdw__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_VDW", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_VDW();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_vdw(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_vdw__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_vdw__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_vdw",  "    double OBForceField.e_vdw(bool)\n"
  "    double OBForceField.e_vdw()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_electrostatic__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Electrostatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","E_Electrostatic", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (double)(arg1)->E_Electrostatic(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_electrostatic__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","E_Electrostatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (double)(arg1)->E_Electrostatic();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_e_electrostatic(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_e_electrostatic__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_e_electrostatic__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.e_electrostatic",  "    double OBForceField.e_electrostatic(bool)\n"
  "    double OBForceField.e_electrostatic()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_print_types(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","PrintTypes", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->PrintTypes(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_print_formal_charges(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","PrintFormalCharges", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->PrintFormalCharges(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_print_partial_charges(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","PrintPartialCharges", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->PrintPartialCharges(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_print_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","PrintVelocities", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->PrintVelocities(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_log_file(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; std::ostream *arg2 = (std::ostream *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetLogFile", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__ostream, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::ostream *","SetLogFile", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< std::ostream * >(argp2); result = (bool)(arg1)->SetLogFile(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_log_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetLogLevel", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetLogLevel", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->SetLogLevel(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_log_level(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetLogLevel", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (int)(arg1)->GetLogLevel();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_obfflog__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","OBFFLog", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string","OBFFLog", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (arg1)->OBFFLog(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_obfflog__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","OBFFLog", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","OBFFLog", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (arg1)->OBFFLog((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_obfflog(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBForceField_obfflog__SWIG_0(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBForceField_obfflog__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.obfflog",  "    void OBForceField.obfflog(std::string msg)\n"
  "    void OBForceField.obfflog(char const *msg)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_distance_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","DistanceGeometry", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->DistanceGeometry(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SystematicRotorSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SystematicRotorSearch", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); (arg1)->SystematicRotorSearch(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SystematicRotorSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->SystematicRotorSearch(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_systematic_rotor_search__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_systematic_rotor_search__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.systematic_rotor_search", 
  "    void OBForceField.systematic_rotor_search(unsigned int geomSteps)\n"
  "    void OBForceField.systematic_rotor_search()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SystematicRotorSearchInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SystematicRotorSearchInitialize", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); result = (int)(arg1)->SystematicRotorSearchInitialize(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SystematicRotorSearchInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (int)(arg1)->SystematicRotorSearchInitialize();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search_initialize(int nargs, VALUE *args, VALUE self) { int argc;
  VALUE argv[3]; int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBForceField_systematic_rotor_search_initialize__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_systematic_rotor_search_initialize__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.systematic_rotor_search_initialize", 
  "    int OBForceField.systematic_rotor_search_initialize(unsigned int geomSteps)\n"
  "    int OBForceField.systematic_rotor_search_initialize()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search_next_conformer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SystematicRotorSearchNextConformer", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SystematicRotorSearchNextConformer", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); result = (bool)(arg1)->SystematicRotorSearchNextConformer(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search_next_conformer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SystematicRotorSearchNextConformer", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->SystematicRotorSearchNextConformer();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_systematic_rotor_search_next_conformer(int nargs, VALUE *args, VALUE self) { int argc;
  VALUE argv[3]; int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBForceField_systematic_rotor_search_next_conformer__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_systematic_rotor_search_next_conformer__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.systematic_rotor_search_next_conformer", 
  "    bool OBForceField.systematic_rotor_search_next_conformer(unsigned int geomSteps)\n"
  "    bool OBForceField.systematic_rotor_search_next_conformer()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; unsigned int arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; unsigned int val2 ; int ecode2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","RandomRotorSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearch", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearch", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); (arg1)->RandomRotorSearch(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","RandomRotorSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearch", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (arg1)->RandomRotorSearch(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBForceField_random_rotor_search__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_random_rotor_search__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBForceField.random_rotor_search", 
  "    void OBForceField.random_rotor_search(unsigned int conformers, unsigned int geomSteps)\n"
  "    void OBForceField.random_rotor_search(unsigned int conformers)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; unsigned int arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; unsigned int val2 ; int ecode2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","RandomRotorSearchInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearchInitialize", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearchInitialize", 3, argv[1] )); }
    arg3 = static_cast< unsigned int >(val3); (arg1)->RandomRotorSearchInitialize(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","RandomRotorSearchInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearchInitialize", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); (arg1)->RandomRotorSearchInitialize(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search_initialize(int nargs, VALUE *args, VALUE self) { int argc;
  VALUE argv[4]; int ii; argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_OBForceField_random_rotor_search_initialize__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_random_rotor_search_initialize__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBForceField.random_rotor_search_initialize", 
  "    void OBForceField.random_rotor_search_initialize(unsigned int conformers, unsigned int geomSteps)\n"
  "    void OBForceField.random_rotor_search_initialize(unsigned int conformers)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search_next_conformer__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","RandomRotorSearchNextConformer", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","RandomRotorSearchNextConformer", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); result = (bool)(arg1)->RandomRotorSearchNextConformer(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search_next_conformer__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","RandomRotorSearchNextConformer", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->RandomRotorSearchNextConformer();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_random_rotor_search_next_conformer(int nargs, VALUE *args, VALUE self) { int argc;
  VALUE argv[3]; int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBForceField_random_rotor_search_next_conformer__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_random_rotor_search_next_conformer__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.random_rotor_search_next_conformer", 
  "    bool OBForceField.random_rotor_search_next_conformer(unsigned int geomSteps)\n"
  "    bool OBForceField.random_rotor_search_next_conformer()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_weighted_rotor_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; unsigned int arg2 ; unsigned int arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; unsigned int val2 ; int ecode2 = 0 ; unsigned int val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","WeightedRotorSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","WeightedRotorSearch", 2, argv[0] )); }
    arg2 = static_cast< unsigned int >(val2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","WeightedRotorSearch", 3, argv[1] )); }
    arg3 = static_cast< unsigned int >(val3); (arg1)->WeightedRotorSearch(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_line_search_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetLineSearchType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetLineSearchType", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetLineSearchType(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_line_search_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetLineSearchType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (int)(arg1)->GetLineSearchType();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_line_search__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","LineSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","LineSearch", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","LineSearch", 3, argv[1] ));  } 
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","LineSearch", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3); result = (arg1)->LineSearch(arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_line_search__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","LineSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","LineSearch", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","LineSearch", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< double * >(argp3); result = (double)(arg1)->LineSearch(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_line_search(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__vector3, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBForceField_line_search__SWIG_0(nargs, args, self);}  check_1: if (argc == 3) {
    return _wrap_OBForceField_line_search__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBForceField.line_search", 
  "    double OBForceField.line_search(OpenBabel::OBAtom *atom, OpenBabel::vector3 &direction)\n"
  "    double OBForceField.line_search(double *currentCoords, double *direction)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_newton_2num_line_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","Newton2NumLineSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","Newton2NumLineSearch", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); result = (double)(arg1)->Newton2NumLineSearch(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_line_search_take_step(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ;
  double arg4 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double val4 ;
  int ecode4 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","LineSearchTakeStep", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","LineSearchTakeStep", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","LineSearchTakeStep", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< double * >(argp3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","LineSearchTakeStep", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (arg1)->LineSearchTakeStep(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; int arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescent", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SteepestDescent", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","SteepestDescent", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->SteepestDescent(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescent", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SteepestDescent", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); (arg1)->SteepestDescent(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescent", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SteepestDescent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBForceField_steepest_descent__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_steepest_descent__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBForceField_steepest_descent__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBForceField.steepest_descent", 
  "    void OBForceField.steepest_descent(int steps, double econv, int method)\n"
  "    void OBForceField.steepest_descent(int steps, double econv)\n" "    void OBForceField.steepest_descent(int steps)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; int arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescentInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescentInitialize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SteepestDescentInitialize", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","SteepestDescentInitialize", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->SteepestDescentInitialize(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescentInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescentInitialize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SteepestDescentInitialize", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); (arg1)->SteepestDescentInitialize(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_initialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescentInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescentInitialize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SteepestDescentInitialize(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_initialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescentInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->SteepestDescentInitialize(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_initialize(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBForceField_steepest_descent_initialize__SWIG_3(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_steepest_descent_initialize__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_steepest_descent_initialize__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBForceField_steepest_descent_initialize__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBForceField.steepest_descent_initialize", 
  "    void OBForceField.steepest_descent_initialize(int steps, double econv, int method)\n"
  "    void OBForceField.steepest_descent_initialize(int steps, double econv)\n"
  "    void OBForceField.steepest_descent_initialize(int steps)\n" "    void OBForceField.steepest_descent_initialize()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_steepest_descent_take_nsteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SteepestDescentTakeNSteps", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SteepestDescentTakeNSteps", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(arg1)->SteepestDescentTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; int arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradients", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradients", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","ConjugateGradients", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","ConjugateGradients", 4, argv[2] )); }  
  arg4 = static_cast< int >(val4); (arg1)->ConjugateGradients(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradients", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradients", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","ConjugateGradients", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); (arg1)->ConjugateGradients(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradients", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradients", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->ConjugateGradients(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBForceField_conjugate_gradients__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_conjugate_gradients__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBForceField_conjugate_gradients__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBForceField.conjugate_gradients", 
  "    void OBForceField.conjugate_gradients(int steps, double econv, int method)\n"
  "    void OBForceField.conjugate_gradients(int steps, double econv)\n"
  "    void OBForceField.conjugate_gradients(int steps)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_initialize__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; int arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; int val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradientsInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradientsInitialize", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","ConjugateGradientsInitialize", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_int(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","ConjugateGradientsInitialize", 4, argv[2] )); }
    arg4 = static_cast< int >(val4); (arg1)->ConjugateGradientsInitialize(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_initialize__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradientsInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradientsInitialize", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","ConjugateGradientsInitialize", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); (arg1)->ConjugateGradientsInitialize(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_initialize__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradientsInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradientsInitialize", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); (arg1)->ConjugateGradientsInitialize(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_initialize__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradientsInitialize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->ConjugateGradientsInitialize(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_initialize(int nargs, VALUE *args, VALUE self) { int argc;
  VALUE argv[5]; int ii; argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1]; }  if (argc == 1) {
    return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_3(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_2(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBForceField_conjugate_gradients_initialize__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBForceField.conjugate_gradients_initialize", 
  "    void OBForceField.conjugate_gradients_initialize(int steps, double econv, int method)\n"
  "    void OBForceField.conjugate_gradients_initialize(int steps, double econv)\n"
  "    void OBForceField.conjugate_gradients_initialize(int steps)\n"
  "    void OBForceField.conjugate_gradients_initialize()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_conjugate_gradients_take_nsteps(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ConjugateGradientsTakeNSteps", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ConjugateGradientsTakeNSteps", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); result = (bool)(arg1)->ConjugateGradientsTakeNSteps(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_generate_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GenerateVelocities", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->GenerateVelocities(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_correct_velocities(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","CorrectVelocities", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->CorrectVelocities(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_molecular_dynamics_take_nsteps__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; double arg4 ; int arg5 ;
  void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  int val5 ; int ecode5 = 0 ; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","MolecularDynamicsTakeNSteps", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","MolecularDynamicsTakeNSteps", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","MolecularDynamicsTakeNSteps", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","MolecularDynamicsTakeNSteps", 4, argv[2] )); }
    arg4 = static_cast< double >(val4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","MolecularDynamicsTakeNSteps", 5, argv[3] )); }
    arg5 = static_cast< int >(val5); (arg1)->MolecularDynamicsTakeNSteps(arg2,arg3,arg4,arg5); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_molecular_dynamics_take_nsteps__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; double arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","MolecularDynamicsTakeNSteps", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","MolecularDynamicsTakeNSteps", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","MolecularDynamicsTakeNSteps", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","MolecularDynamicsTakeNSteps", 4, argv[2] )); }
    arg4 = static_cast< double >(val4); (arg1)->MolecularDynamicsTakeNSteps(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_molecular_dynamics_take_nsteps__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; double arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","MolecularDynamicsTakeNSteps", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","MolecularDynamicsTakeNSteps", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","MolecularDynamicsTakeNSteps", 3, argv[1] )); }
    arg3 = static_cast< double >(val3); (arg1)->MolecularDynamicsTakeNSteps(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_molecular_dynamics_take_nsteps(int nargs, VALUE *args, VALUE self) { int argc;
  VALUE argv[6]; int ii; argc = nargs + 1; argv[0] = self; if (argc > 6) SWIG_fail; for (ii = 1; (ii < argc); ++ii) {
    argv[ii] = args[ii-1]; }  if (argc == 3) {
    return _wrap_OBForceField_molecular_dynamics_take_nsteps__SWIG_2(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBForceField_molecular_dynamics_take_nsteps__SWIG_1(nargs, args, self);}  if (argc == 5) {
    return _wrap_OBForceField_molecular_dynamics_take_nsteps__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBForceField.molecular_dynamics_take_nsteps", 
  "    void OBForceField.molecular_dynamics_take_nsteps(int n, double T, double timestep, int method)\n"
  "    void OBForceField.molecular_dynamics_take_nsteps(int n, double T, double timestep)\n"
  "    void OBForceField.molecular_dynamics_take_nsteps(int n, double T)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_get_constraints(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBFFConstraints *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","GetConstraints", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  result = (OpenBabel::OBFFConstraints *) &(arg1)->GetConstraints();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBFFConstraints, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_constraints(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBFFConstraints *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetConstraints", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBFFConstraints,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBFFConstraints &","SetConstraints", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBFFConstraints &","SetConstraints", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBFFConstraints * >(argp2); (arg1)->SetConstraints(*arg2); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_fix_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetFixAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetFixAtom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetFixAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_unset_fix_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","UnsetFixAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->UnsetFixAtom(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_set_ignore_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","SetIgnoreAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIgnoreAtom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->SetIgnoreAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_unset_ignore_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","UnsetIgnoreAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); (arg1)->UnsetIgnoreAtom(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_ignore_calculation__SWIG_0(int argc, VALUE *argv, VALUE self) { int arg1 ; int arg2 ;
  int val1 ; int ecode1 = 0 ; int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 1, argv[0] )); }
    arg1 = static_cast< int >(val1); ecode2 = SWIG_AsVal_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 2, argv[1] )); }
    arg2 = static_cast< int >(val2); result = (bool)OpenBabel::OBForceField::IgnoreCalculation(arg1,arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_ignore_calculation__SWIG_1(int argc, VALUE *argv, VALUE self) { int arg1 ; int arg2 ;
  int arg3 ; int val1 ; int ecode1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 1, argv[0] )); }
    arg1 = static_cast< int >(val1); ecode2 = SWIG_AsVal_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 2, argv[1] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 3, argv[2] )); }
    arg3 = static_cast< int >(val3); result = (bool)OpenBabel::OBForceField::IgnoreCalculation(arg1,arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_ignore_calculation__SWIG_2(int argc, VALUE *argv, VALUE self) { int arg1 ; int arg2 ;
  int arg3 ; int arg4 ; int val1 ; int ecode1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; int val4 ;
  int ecode4 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;}  ecode1 = SWIG_AsVal_int(argv[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 1, argv[0] )); }
    arg1 = static_cast< int >(val1); ecode2 = SWIG_AsVal_int(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 2, argv[1] )); }
    arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[2], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 3, argv[2] )); }
    arg3 = static_cast< int >(val3); ecode4 = SWIG_AsVal_int(argv[3], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "int","OpenBabel::OBForceField::IgnoreCalculation", 4, argv[3] )); }
    arg4 = static_cast< int >(val4); result = (bool)OpenBabel::OBForceField::IgnoreCalculation(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_ignore_calculation(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs; if (argc > 4) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 2) {
    return _wrap_OBForceField_ignore_calculation__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_ignore_calculation__SWIG_1(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBForceField_ignore_calculation__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBForceField.ignore_calculation", 
  "    bool OBForceField.ignore_calculation(int a, int b)\n" "    bool OBForceField.ignore_calculation(int a, int b, int c)\n"
  "    bool OBForceField.ignore_calculation(int a, int b, int c, int d)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_detect_explosion(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","DetectExplosion", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->DetectExplosion();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_validate_line_search(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::vector3 *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; OpenBabel::vector3 result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ValidateLineSearch", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","ValidateLineSearch", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","ValidateLineSearch", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","ValidateLineSearch", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3); result = (arg1)->ValidateLineSearch(arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_validate_steepest_descent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ValidateSteepestDescent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ValidateSteepestDescent", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->ValidateSteepestDescent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_validate_conjugate_gradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ValidateConjugateGradients", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","ValidateConjugateGradients", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (arg1)->ValidateConjugateGradients(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_validate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","Validate", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->Validate();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_validate_gradients(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ValidateGradients", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1); result = (bool)(arg1)->ValidateGradients();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_validate_gradient_error(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBForceField *arg1 = (OpenBabel::OBForceField *) 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; OpenBabel::vector3 result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBForceField, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBForceField *","ValidateGradientError", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBForceField * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","ValidateGradientError", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","ValidateGradientError", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","ValidateGradientError", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","ValidateGradientError", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3); result = (arg1)->ValidateGradientError(*arg2,*arg3);
  vresult = SWIG_NewPointerObj((new OpenBabel::vector3(static_cast< const OpenBabel::vector3& >(result))), SWIGTYPE_p_OpenBabel__vector3, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_bond_derivative(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; double *arg4 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorBondDerivative", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorBondDerivative", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorBondDerivative", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorBondDerivative", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4);
  result = (double)OpenBabel::OBForceField::VectorBondDerivative(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_distance_derivative(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) (double *)0 ; double *arg2 = (double *) (double *)0 ; double *arg3 = (double *) 0 ;
  double *arg4 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double const *const","OpenBabel::OBForceField::VectorDistanceDerivative", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const *const","OpenBabel::OBForceField::VectorDistanceDerivative", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDistanceDerivative", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDistanceDerivative", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4);
  result = (double)OpenBabel::OBForceField::VectorDistanceDerivative((double const *)arg1,(double const *)arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_length_derivative(int argc, VALUE *argv, VALUE self) { OpenBabel::vector3 *arg1 = 0 ;
  OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorLengthDerivative", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorLengthDerivative", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorLengthDerivative", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorLengthDerivative", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  result = (double)OpenBabel::OBForceField::VectorLengthDerivative(*arg1,*arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_angle_derivative__SWIG_0(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ; double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ; double *arg6 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; void *argp6 = 0 ;
  int res6 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 6) || (argc > 6)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 6)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngleDerivative", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngleDerivative", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngleDerivative", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngleDerivative", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4); res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngleDerivative", 5, argv[4] ));  }
   arg5 = reinterpret_cast< double * >(argp5); res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngleDerivative", 6, argv[5] ));  }
   arg6 = reinterpret_cast< double * >(argp6);
  result = (double)OpenBabel::OBForceField::VectorAngleDerivative(arg1,arg2,arg3,arg4,arg5,arg6);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_angle_derivative__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorAngleDerivative", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorAngleDerivative", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorAngleDerivative", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorAngleDerivative", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorAngleDerivative", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorAngleDerivative", 3, argv[2])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  result = (double)OpenBabel::OBForceField::VectorAngleDerivative(*arg1,*arg2,*arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_angle_derivative(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[6];
  int ii; argc = nargs; if (argc > 6) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 3) {
    return _wrap_OBForceField_vector_angle_derivative__SWIG_1(nargs, args, self);}  if (argc == 6) {
    return _wrap_OBForceField_vector_angle_derivative__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 6, "OBForceField.vector_angle_derivative", 
  "    double OBForceField.vector_angle_derivative(double *pos_a, double *pos_b, double *pos_c, double *force_a, double *force_b, double *force_c)\n"
  "    double OBForceField.vector_angle_derivative(OpenBabel::vector3 &a, OpenBabel::vector3 &b, OpenBabel::vector3 &c)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_oopderivative__SWIG_0(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ; double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ; double *arg6 = (double *) 0 ; double *arg7 = (double *) 0 ; double *arg8 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; void *argp6 = 0 ; int res6 = 0 ; void *argp7 = 0 ; int res7 = 0 ;
  void *argp8 = 0 ; int res8 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4); res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 5, argv[4] ));  }
   arg5 = reinterpret_cast< double * >(argp5); res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 6, argv[5] ));  }
   arg6 = reinterpret_cast< double * >(argp6); res7 = SWIG_ConvertPtr(argv[6], &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 7, argv[6] ));  }
   arg7 = reinterpret_cast< double * >(argp7); res8 = SWIG_ConvertPtr(argv[7], &argp8,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOPDerivative", 8, argv[7] ));  }
   arg8 = reinterpret_cast< double * >(argp8);
  result = (double)OpenBabel::OBForceField::VectorOOPDerivative(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_oopderivative__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ; OpenBabel::vector3 *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 3, argv[2])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 4, argv[3] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorOOPDerivative", 4, argv[3])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::OBForceField::VectorOOPDerivative(*arg1,*arg2,*arg3,*arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_oopderivative(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[8]; int ii;
  argc = nargs; if (argc > 8) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 4) {
    return _wrap_OBForceField_vector_oopderivative__SWIG_1(nargs, args, self);}  if (argc == 8) {
    return _wrap_OBForceField_vector_oopderivative__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 8, "OBForceField.vector_oopderivative", 
  "    double OBForceField.vector_oopderivative(double *pos_a, double *pos_b, double *pos_c, double *pos_d, double *force_a, double *force_b, double *force_c, double *force_d)\n"
  "    double OBForceField.vector_oopderivative(OpenBabel::vector3 &a, OpenBabel::vector3 &b, OpenBabel::vector3 &c, OpenBabel::vector3 &d)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_torsion_derivative__SWIG_0(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) 0 ; double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; double *arg4 = (double *) 0 ;
  double *arg5 = (double *) 0 ; double *arg6 = (double *) 0 ; double *arg7 = (double *) 0 ; double *arg8 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; void *argp5 = 0 ; int res5 = 0 ; void *argp6 = 0 ; int res6 = 0 ; void *argp7 = 0 ; int res7 = 0 ;
  void *argp8 = 0 ; int res8 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 8) || (argc > 8)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 8)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4); res5 = SWIG_ConvertPtr(argv[4], &argp5,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 5, argv[4] ));  }
   arg5 = reinterpret_cast< double * >(argp5); res6 = SWIG_ConvertPtr(argv[5], &argp6,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 6, argv[5] ));  }
   arg6 = reinterpret_cast< double * >(argp6); res7 = SWIG_ConvertPtr(argv[6], &argp7,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 7, argv[6] ));  }
   arg7 = reinterpret_cast< double * >(argp7); res8 = SWIG_ConvertPtr(argv[7], &argp8,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res8)) {
    SWIG_exception_fail(SWIG_ArgError(res8), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsionDerivative", 8, argv[7] ));  }
   arg8 = reinterpret_cast< double * >(argp8);
  result = (double)OpenBabel::OBForceField::VectorTorsionDerivative(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_torsion_derivative__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::vector3 *arg1 = 0 ; OpenBabel::vector3 *arg2 = 0 ; OpenBabel::vector3 *arg3 = 0 ; OpenBabel::vector3 *arg4 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ;
  int res4 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::vector3 * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 2, argv[1] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 2, argv[1])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[2], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 3, argv[2] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 3, argv[2])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[3], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 4, argv[3] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","OpenBabel::OBForceField::VectorTorsionDerivative", 4, argv[3])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4);
  result = (double)OpenBabel::OBForceField::VectorTorsionDerivative(*arg1,*arg2,*arg3,*arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_torsion_derivative(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[8];
  int ii; argc = nargs; if (argc > 8) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 4) {
    return _wrap_OBForceField_vector_torsion_derivative__SWIG_1(nargs, args, self);}  if (argc == 8) {
    return _wrap_OBForceField_vector_torsion_derivative__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 8, "OBForceField.vector_torsion_derivative", 
  "    double OBForceField.vector_torsion_derivative(double *pos_a, double *pos_b, double *pos_c, double *pos_d, double *force_a, double *force_b, double *force_c, double *force_d)\n"
  "    double OBForceField.vector_torsion_derivative(OpenBabel::vector3 &a, OpenBabel::vector3 &b, OpenBabel::vector3 &c, OpenBabel::vector3 &d)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_subtract__SWIG_0(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorSubtract", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorSubtract", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorSubtract", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); OpenBabel::OBForceField::VectorSubtract(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_subtract__SWIG_1(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) (double *)0 ; double *arg2 = (double *) (double *)0 ; double *arg3 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double const *const","OpenBabel::OBForceField::VectorSubtract", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double const *const","OpenBabel::OBForceField::VectorSubtract", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorSubtract", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3);
  OpenBabel::OBForceField::VectorSubtract((double const *)arg1,(double const *)arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_subtract(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs; if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 3) {
    return _wrap_OBForceField_vector_subtract__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_vector_subtract__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.vector_subtract", 
  "    void OBForceField.vector_subtract(double *i, double *j, double *result)\n"
  "    void OBForceField.vector_subtract(double const *const i, double const *const j, double *result)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_add(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAdd", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAdd", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAdd", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); OpenBabel::OBForceField::VectorAdd(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_divide(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double arg2 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDivide", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::OBForceField::VectorDivide", 2, argv[1] )); }
    arg2 = static_cast< double >(val2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDivide", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); OpenBabel::OBForceField::VectorDivide(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_multiply__SWIG_0(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double arg2 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; void *argp3 = 0 ;
  int res3 = 0 ; if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorMultiply", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::OBForceField::VectorMultiply", 2, argv[1] )); }
    arg2 = static_cast< double >(val2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorMultiply", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); OpenBabel::OBForceField::VectorMultiply(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_multiply__SWIG_1(int argc, VALUE *argv, VALUE self) {
  double *arg1 = (double *) (double *)0 ; double arg2 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double const *const","OpenBabel::OBForceField::VectorMultiply", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::OBForceField::VectorMultiply", 2, argv[1] )); }
    arg2 = static_cast< double >(val2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorMultiply", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); OpenBabel::OBForceField::VectorMultiply((double const *)arg1,arg2,arg3);
  return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_multiply(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs; if (argc > 3) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 3) {
    return _wrap_OBForceField_vector_multiply__SWIG_0(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBForceField_vector_multiply__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBForceField.vector_multiply", 
  "    void OBForceField.vector_multiply(double *i, double n, double *result)\n"
  "    void OBForceField.vector_multiply(double const *const i, double const n, double *result)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_self_multiply(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorSelfMultiply", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); ecode2 = SWIG_AsVal_double(argv[1], &val2); if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","OpenBabel::OBForceField::VectorSelfMultiply", 2, argv[1] )); }
    arg2 = static_cast< double >(val2); OpenBabel::OBForceField::VectorSelfMultiply(arg1,arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_normalize(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorNormalize", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); OpenBabel::OBForceField::VectorNormalize(arg1); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_copy(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorCopy", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorCopy", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); OpenBabel::OBForceField::VectorCopy(arg1,arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_length(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorLength", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); result = (double)OpenBabel::OBForceField::VectorLength(arg1);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_distance(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDistance", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDistance", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); result = (double)OpenBabel::OBForceField::VectorDistance(arg1,arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_angle(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngle", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngle", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorAngle", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); result = (double)OpenBabel::OBForceField::VectorAngle(arg1,arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_torsion(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; double *arg4 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsion", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsion", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsion", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorTorsion", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4); result = (double)OpenBabel::OBForceField::VectorTorsion(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_oop(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; double *arg4 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 4) || (argc > 4)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 4)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOP", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOP", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOP", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); res4 = SWIG_ConvertPtr(argv[3], &argp4,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorOOP", 4, argv[3] ));  }
   arg4 = reinterpret_cast< double * >(argp4); result = (double)OpenBabel::OBForceField::VectorOOP(arg1,arg2,arg3,arg4);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_clear(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorClear", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); OpenBabel::OBForceField::VectorClear(arg1); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_dot(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDot", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorDot", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); result = (double)OpenBabel::OBForceField::VectorDot(arg1,arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_vector_cross(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  double *arg2 = (double *) 0 ; double *arg3 = (double *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorCross", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorCross", 2, argv[1] ));  }
   arg2 = reinterpret_cast< double * >(argp2); res3 = SWIG_ConvertPtr(argv[2], &argp3,SWIGTYPE_p_double, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::VectorCross", 3, argv[2] ));  }
   arg3 = reinterpret_cast< double * >(argp3); OpenBabel::OBForceField::VectorCross(arg1,arg2,arg3); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBForceField_print_vector(int argc, VALUE *argv, VALUE self) { double *arg1 = (double *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_double, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "double *","OpenBabel::OBForceField::PrintVector", 1, argv[0] ));  }
   arg1 = reinterpret_cast< double * >(argp1); OpenBabel::OBForceField::PrintVector(arg1); return Qnil; fail: return Qnil; }
swig_class SwigClassOBOp;

SWIGINTERN VALUE _wrap_OBOp_default(int argc, VALUE *argv, VALUE self) { OpenBabel::OBOp **result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBOp **) &OpenBabel::OBOp::Default();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_p_OpenBabel__OBOp, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_find_type(int argc, VALUE *argv, VALUE self) { char *arg1 = (char *) 0 ; int res1 ; char *buf1 = 0 ;
  int alloc1 = 0 ; OpenBabel::OBOp *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_AsCharPtrAndSize(argv[0], &buf1, NULL, &alloc1); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "char const *","OpenBabel::OBOp::FindType", 1, argv[0] )); }
   arg1 = reinterpret_cast< char * >(buf1); result = (OpenBabel::OBOp *)OpenBabel::OBOp::FindType((char const *)arg1);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBOp, 0 |  0 );
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return vresult; fail: if (alloc1 == SWIG_NEWOBJ) delete[] buf1; return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_type_id(int argc, VALUE *argv, VALUE self) { OpenBabel::OBOp *arg1 = (OpenBabel::OBOp *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBOp, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBOp *","TypeID", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBOp * >(argp1); result = (char *)(arg1)->TypeID();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_do__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBOp *arg1 = (OpenBabel::OBOp *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ; OpenBabel::OBOp::OpMap *arg3 = (OpenBabel::OBOp::OpMap *) 0 ;
  char *arg4 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ;
  int res4 ; char *buf4 = 0 ; int alloc4 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 3) || (argc > 3)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBOp, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBOp *","Do", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBOp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Do", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBOp::OpMap *","Do", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBOp::OpMap * >(argp3); res4 = SWIG_AsCharPtrAndSize(argv[2], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "char const *","Do", 4, argv[2] )); } 
  arg4 = reinterpret_cast< char * >(buf4); result = (bool)(arg1)->Do(arg2,arg3,(char const *)arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return vresult; fail:
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4; return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_do__SWIG_1(int argc, VALUE *argv, VALUE self) { OpenBabel::OBOp *arg1 = (OpenBabel::OBOp *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ; OpenBabel::OBOp::OpMap *arg3 = (OpenBabel::OBOp::OpMap *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBOp, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBOp *","Do", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBOp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Do", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBOp::OpMap *","Do", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBOp::OpMap * >(argp3); result = (bool)(arg1)->Do(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_do__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBOp *arg1 = (OpenBabel::OBOp *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBOp, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBOp *","Do", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBOp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","Do", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (bool)(arg1)->Do(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_do(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii; argc = nargs + 1;
  argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; }  if (argc == 2) {
    return _wrap_OBOp_do__SWIG_2(nargs, args, self);}  if (argc == 3) { return _wrap_OBOp_do__SWIG_1(nargs, args, self);} 
  if (argc == 4) { return _wrap_OBOp_do__SWIG_0(nargs, args, self);}  fail: Ruby_Format_OverloadedError( argc, 5, "OBOp.do", 
  "    bool OBOp.do(OpenBabel::OBBase *pOb, OpenBabel::OBOp::OpMap *pOptions, char const *OptionText)\n"
  "    bool OBOp.do(OpenBabel::OBBase *pOb, OpenBabel::OBOp::OpMap *pOptions)\n" "    bool OBOp.do(OpenBabel::OBBase *pOb)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_works_with(int argc, VALUE *argv, VALUE self) { OpenBabel::OBOp *arg1 = (OpenBabel::OBOp *) 0 ;
  OpenBabel::OBBase *arg2 = (OpenBabel::OBBase *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBOp, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBOp const *","WorksWith", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBOp * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","WorksWith", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBase * >(argp2); result = (bool)((OpenBabel::OBOp const *)arg1)->WorksWith(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_op_options(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; std::string result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","OpenBabel::OBOp::OpOptions", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1); result = OpenBabel::OBOp::OpOptions(arg1);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBOp_do_ops(int argc, VALUE *argv, VALUE self) { OpenBabel::OBBase *arg1 = (OpenBabel::OBBase *) 0 ;
  OpenBabel::OBOp::OpMap *arg2 = (OpenBabel::OBOp::OpMap *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBBase *","OpenBabel::OBOp::DoOps", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBBase * >(argp1);
  res2 = SWIG_ConvertPtr(argv[1], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBOp::OpMap *","OpenBabel::OBOp::DoOps", 2, argv[1] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBOp::OpMap * >(argp2);
  result = (bool)OpenBabel::OBOp::DoOps(arg1,(std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN void
free_OpenBabel_OBOp(OpenBabel::OBOp *arg1) {
    delete arg1;
}

swig_class SwigClassOBMolAtomIter;

SWIGINTERN VALUE _wrap_new_OBMolAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolAtomIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMolAtomIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBMolAtomIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMolAtomIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMolAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMolAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolAtomIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBMolAtomIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAtomIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const &","OpenBabel::OBMolAtomIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolAtomIter const &","OpenBabel::OBMolAtomIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBMolAtomIter *)new OpenBabel::OBMolAtomIter((OpenBabel::OBMolAtomIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolAtomIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMolAtomIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBMolAtomIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBMolAtomIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBMolAtomIter.new",  "    OBMolAtomIter.new()\n"
  "    OBMolAtomIter.new(OpenBabel::OBMol *mol)\n" "    OBMolAtomIter.new(OpenBabel::OBMolAtomIter const &ai)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMolAtomIter(OpenBabel::OBMolAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMolAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMolAtomIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (OpenBabel::OBMolAtomIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBMolAtomIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolAtomIter(static_cast< const OpenBabel::OBMolAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolAtomIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMolAtomIter.inc",  "    OpenBabel::OBMolAtomIter OBMolAtomIter.inc()\n"
  "    OpenBabel::OBMolAtomIter OBMolAtomIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBMolAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *) &((OpenBabel::OBMolAtomIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (*arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_duplicate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","Duplicate", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Duplicate", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->Duplicate(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetHyb", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHyb", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetHyb(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetAtomicNum", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetAtomicNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetIsotope", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->SetIsotope(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetImplicitValence", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetImplicitValence(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IncrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->IncrementImplicitValence(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DecrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->DecrementImplicitValence(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetFormalCharge", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetFormalCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; short arg2 ; void *argp1 = 0 ; int res1 = 0 ; short val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","SetSpinMultiplicity", 2, argv[0] )); }  
  arg2 = static_cast< short >(val2); (*arg1)->SetSpinMultiplicity(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (*arg1)->SetType((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetType", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetType", 2, argv[0])); }
     arg2 = ptr; }  (*arg1)->SetType((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBMolAtomIter_set_type__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBMolAtomIter_set_type__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.set_type",  "    void OBAtom.set_type(char const *type)\n"
  "    void OBAtom.set_type(std::string const &type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetPartialCharge", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (*arg1)->SetPartialCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; double arg2 ; double arg3 ; double arg4 ; void *argp1 = 0 ;
  int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetVector", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","SetVector", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (*arg1)->SetVector(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetVector(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_set_vector__SWIG_2(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolAtomIter_set_vector__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBMolAtomIter_set_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBAtom.set_vector",  "    void OBAtom.set_vector(OpenBabel::vector3 const &v)\n"
  "    void OBAtom.set_vector(double const x, double const y, double const z)\n" "    void OBAtom.set_vector()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; double **arg2 = (double **) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetCoordPtr", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double **","SetCoordPtr", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double ** >(argp2); (*arg1)->SetCoordPtr(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (*arg1)->SetResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (*arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","UnsetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetClockwiseStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetAntiClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetAntiClockwiseStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetPositiveStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetNegativeStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","UnsetStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->UnsetStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetChiral", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->SetChiral(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","ClearCoordPtr", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->ClearCoordPtr(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned short result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetAtomicMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetExactMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetCoordinateIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetCIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetHyb", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetHvyValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetHeteroValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetX", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetY", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetZ", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","x", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","y", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","z", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetCoordinate", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (OpenBabel::vector3 *) &(*arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","GetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (OpenBabel::vector3 *) &(*arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_get_vector__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBMolAtomIter_get_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBAtom.get_vector",  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"
  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_residue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_residue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetResidue", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (OpenBabel::OBResidue *)(*arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_residue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_get_residue__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolAtomIter_get_residue__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_residue",  "    OpenBabel::OBResidue * OBAtom.get_residue()\n"
  "    OpenBabel::OBResidue * OBAtom.get_residue(bool perception)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMol *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ; double arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetNewBondVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","GetNewBondVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetNextAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","BeginBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","EndBonds", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","BeginBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","NextBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","BeginNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","NextNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetDistance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetDistance", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetDistance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetDistance", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_distance(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBMolAtomIter_get_distance__SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBMolAtomIter_get_distance__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_distance",  "    double OBAtom.get_distance(int index)\n"
  "    double OBAtom.get_distance(OpenBabel::OBAtom *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAngle", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetAngle", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetAngle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBMolAtomIter_get_angle__SWIG_1(nargs, args, self);}  check_1: if (argc == 3) {
    return _wrap_OBMolAtomIter_get_angle__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBAtom.get_angle",  "    double OBAtom.get_angle(int b, int c)\n"
  "    double OBAtom.get_angle(OpenBabel::OBAtom *b, OpenBabel::OBAtom *c)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","NewResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->NewResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","AddResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","AddResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (*arg1)->AddResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DeleteResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->DeleteResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","AddBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); (*arg1)->AddBond(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","InsertBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","InsertBond", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3); (*arg1)->InsertBond(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DeleteBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DeleteBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","ClearBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->ClearBond(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HtoMethyl", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetHybAndGeom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHybAndGeom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","ForceNoH", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->ForceNoH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasNoHForced", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_force_impl_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","ForceImplH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); (*arg1)->ForceImplH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_impl_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasImplHForced", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasImplHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","CountFreeOxygens", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","ImplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ExplicitHydrogenCount", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolAtomIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.explicit_hydrogen_count", 
  "    unsigned int OBAtom.explicit_hydrogen_count(bool ExcludeIsotopes)\n"
  "    unsigned int OBAtom.explicit_hydrogen_count()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","MemberOfRingCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","MemberOfRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","CountRingBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SmallestBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","AverageBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","BOSum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","KBOSum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsCarbon", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsNitrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsOxygen", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsSulfur", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsPhosphorus", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","IsInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","IsInRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsInRingSize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsHeteroatom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsNotCorH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsConnected", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsConnected", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsOneThree", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneThree", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsOneFour", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneFour", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsCarboxylOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsPhosphateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsSulfateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsNitroOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsAmideNitrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsNonPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsAromaticNOxide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsChiral", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsAxial", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsClockwise", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsAntiClockwise", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasChiralitySpecified", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasChiralVolume", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsHbondAcceptor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsHbondDonor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","IsHbondDonorH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","HasAlphaBetaUnsat", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolAtomIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.has_alpha_beta_unsat", 
  "    bool OBAtom.has_alpha_beta_unsat(bool includePandS)\n" "    bool OBAtom.has_alpha_beta_unsat()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasBondOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasBondOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","CountBondsOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","CountBondsOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasNonSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasDoubleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasAromaticBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","MatchesSMARTS", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","MatchesSMARTS", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","ClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBMolAtomIter_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBMolAtomIter_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBMolAtomIter_has_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data",  "    bool OBBase.has_data(std::string const &)\n"
  "    bool OBBase.has_data(char const *)\n" "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (*arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBMolAtomIter_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBMolAtomIter_delete_data__SWIG_2(nargs, args, self);} 
  check_2: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_3; return _wrap_OBMolAtomIter_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBMolAtomIter_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","CloneData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter const *","DataSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(*arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (*arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolAtomIter_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBMolAtomIter_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBMolAtomIter_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBMolAtomIter_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBMolAtomIter_get_data__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","GetAllData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (*arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","BeginData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAtomIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAtomIter *arg1 = (OpenBabel::OBMolAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAtomIter *","EndData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolAtomIter * >(argp1); result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBMolBondIter;

SWIGINTERN VALUE _wrap_new_OBMolBondIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolBondIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolBondIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMolBondIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBMolBondIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMolBondIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMolBondIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolBondIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMolBondIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolBondIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBMolBondIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolBondIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const &","OpenBabel::OBMolBondIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolBondIter const &","OpenBabel::OBMolBondIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBMolBondIter *)new OpenBabel::OBMolBondIter((OpenBabel::OBMolBondIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolBondIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMolBondIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBMolBondIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBMolBondIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBMolBondIter.new",  "    OBMolBondIter.new()\n"
  "    OBMolBondIter.new(OpenBabel::OBMol *mol)\n" "    OBMolBondIter.new(OpenBabel::OBMolBondIter const &bi)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMolBondIter(OpenBabel::OBMolBondIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMolBondIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (bool)((OpenBabel::OBMolBondIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMolBondIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (OpenBabel::OBMolBondIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBMolBondIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolBondIter(static_cast< const OpenBabel::OBMolBondIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolBondIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolBondIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolBondIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMolBondIter.inc",  "    OpenBabel::OBMolBondIter OBMolBondIter.inc()\n"
  "    OpenBabel::OBMolBondIter OBMolBondIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBMolBondIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (OpenBabel::OBBond *) &((OpenBabel::OBMolBondIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (*arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetBO", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetBO", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); (*arg1)->SetBO(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetBondOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetBondOrder", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetBondOrder(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetBegin", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetBegin", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->SetBegin(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetEnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetEnd", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->SetEnd(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (*arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_length__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetLength", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetLength", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); (*arg1)->SetLength(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_length__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ; double val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetLength", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (*arg1)->SetLength(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_length(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBMolBondIter_set_length__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBMolBondIter_set_length__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBBond.set_length", 
  "    void OBBond.set_length(OpenBabel::OBAtom *fixed, double length)\n" "    void OBBond.set_length(double length)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; int arg5 ; int arg6 ;
  void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  int val5 ; int ecode5 = 0 ; int val6 ; int ecode6 = 0 ; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","Set", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Set", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Set", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Set", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","Set", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); ecode6 = SWIG_AsVal_int(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","Set", 6, argv[4] )); }  
  arg6 = static_cast< int >(val6); (*arg1)->Set(arg2,arg3,arg4,arg5,arg6); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetKSingle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetKSingle(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetKDouble", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetKDouble(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetKTriple", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetKTriple(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetHash(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetWedge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetWedge(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetUp(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetDown(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetClosure", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->SetClosure(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_unset_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","UnsetHash", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->UnsetHash(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_unset_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","UnsetWedge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->UnsetWedge(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_unset_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","UnsetUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->UnsetUp(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_unset_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","UnsetDown", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->UnsetDown(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","UnsetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_unset_kekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","UnsetKekule", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); (*arg1)->UnsetKekule(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetBO", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetBondOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetFlags", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_begin_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetBeginAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_end_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetEndAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_begin_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetBeginAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_begin_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetBeginAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_begin_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolBondIter_get_begin_atom__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBMolBondIter_get_begin_atom__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBBond.get_begin_atom",  "    OpenBabel::OBAtom const * OBBond.get_begin_atom()\n"
  "    OpenBabel::OBAtom const * OBBond.get_begin_atom()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_end_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetEndAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_end_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetEndAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_end_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolBondIter_get_end_atom__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBMolBondIter_get_end_atom__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBBond.get_end_atom",  "    OpenBabel::OBAtom const * OBBond.get_end_atom()\n"
  "    OpenBabel::OBAtom const * OBBond.get_end_atom()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNbrAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMol *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_equib_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetEquibLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (double)(*arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","GetLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (double)(*arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_nbr_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetNbrAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNbrAtomIdx", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (unsigned int)(*arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","IsInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsRotor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsAmide", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_primary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsPrimaryAmide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_secondary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsSecondaryAmide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_ester(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsEster", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_carbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsCarbonyl", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_single(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsSingle", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_double(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsDouble", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_triple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsTriple", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsKSingle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsKDouble", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsKTriple", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsClosure", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsWedge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_is_double_bond_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","IsDoubleBondGeometry", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","ClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBMolBondIter_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBMolBondIter_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBMolBondIter_has_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data",  "    bool OBBase.has_data(std::string const &)\n"
  "    bool OBBase.has_data(char const *)\n" "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (*arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBMolBondIter_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBMolBondIter_delete_data__SWIG_2(nargs, args, self);} 
  check_2: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_3; return _wrap_OBMolBondIter_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBMolBondIter_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","CloneData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter const *","DataSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(*arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (*arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolBondIter_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBMolBondIter_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBMolBondIter_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBMolBondIter_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBMolBondIter_get_data__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","GetAllData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (*arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","BeginData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolBondIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolBondIter *arg1 = (OpenBabel::OBMolBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolBondIter *","EndData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolBondIter * >(argp1); result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBAtomAtomIter;

SWIGINTERN VALUE _wrap_new_OBAtomAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtomAtomIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBAtomAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtomAtomIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBAtomAtomIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBAtomAtomIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBAtomAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtomAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBAtomAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtomAtomIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBAtomAtomIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAtomAtomIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const &","OpenBabel::OBAtomAtomIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAtomAtomIter const &","OpenBabel::OBAtomAtomIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtomAtomIter *)new OpenBabel::OBAtomAtomIter((OpenBabel::OBAtomAtomIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBAtomAtomIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBAtomAtomIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBAtomAtomIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBAtomAtomIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBAtomAtomIter.new",  "    OBAtomAtomIter.new()\n"
  "    OBAtomAtomIter.new(OpenBabel::OBAtom *atm)\n" "    OBAtomAtomIter.new(OpenBabel::OBAtomAtomIter const &ai)\n");
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBAtomAtomIter(OpenBabel::OBAtomAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBAtomAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBAtomAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtomAtomIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (OpenBabel::OBAtomAtomIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBAtomAtomIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomAtomIter(static_cast< const OpenBabel::OBAtomAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBAtomAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtomAtomIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtomAtomIter.inc",  "    OpenBabel::OBAtomAtomIter OBAtomAtomIter.inc()\n"
  "    OpenBabel::OBAtomAtomIter OBAtomAtomIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBAtomAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *) &((OpenBabel::OBAtomAtomIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (*arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_duplicate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","Duplicate", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Duplicate", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->Duplicate(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetHyb", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHyb", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetHyb(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetAtomicNum", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetAtomicNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetIsotope", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->SetIsotope(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetImplicitValence", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetImplicitValence(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IncrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->IncrementImplicitValence(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DecrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->DecrementImplicitValence(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetFormalCharge", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetFormalCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; short arg2 ; void *argp1 = 0 ; int res1 = 0 ; short val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","SetSpinMultiplicity", 2, argv[0] )); }  
  arg2 = static_cast< short >(val2); (*arg1)->SetSpinMultiplicity(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (*arg1)->SetType((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetType", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetType", 2, argv[0])); }
     arg2 = ptr; }  (*arg1)->SetType((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBAtomAtomIter_set_type__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBAtomAtomIter_set_type__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.set_type",  "    void OBAtom.set_type(char const *type)\n"
  "    void OBAtom.set_type(std::string const &type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetPartialCharge", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (*arg1)->SetPartialCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; double arg2 ; double arg3 ; double arg4 ;
  void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetVector", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","SetVector", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (*arg1)->SetVector(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetVector(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_set_vector__SWIG_2(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtomAtomIter_set_vector__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBAtomAtomIter_set_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBAtom.set_vector",  "    void OBAtom.set_vector(OpenBabel::vector3 const &v)\n"
  "    void OBAtom.set_vector(double const x, double const y, double const z)\n" "    void OBAtom.set_vector()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; double **arg2 = (double **) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetCoordPtr", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double **","SetCoordPtr", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double ** >(argp2); (*arg1)->SetCoordPtr(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (*arg1)->SetResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (*arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","UnsetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetClockwiseStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetAntiClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetAntiClockwiseStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetPositiveStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetNegativeStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","UnsetStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->UnsetStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetChiral", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->SetChiral(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","ClearCoordPtr", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->ClearCoordPtr(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned short result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetAtomicMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetExactMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetCoordinateIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetCIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetHyb", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetHvyValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetHeteroValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetX", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetY", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetZ", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","x", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","y", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","z", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetCoordinate", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (OpenBabel::vector3 *) &(*arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","GetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (OpenBabel::vector3 *) &(*arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_get_vector__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBAtomAtomIter_get_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBAtom.get_vector",  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"
  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_residue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_residue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetResidue", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (OpenBabel::OBResidue *)(*arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_residue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_get_residue__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtomAtomIter_get_residue__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_residue",  "    OpenBabel::OBResidue * OBAtom.get_residue()\n"
  "    OpenBabel::OBResidue * OBAtom.get_residue(bool perception)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMol *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ; double arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetNewBondVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","GetNewBondVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetNextAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","BeginBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","EndBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","BeginBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","NextBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","BeginNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","NextNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetDistance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetDistance", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetDistance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetDistance", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_distance(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBAtomAtomIter_get_distance__SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBAtomAtomIter_get_distance__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_distance",  "    double OBAtom.get_distance(int index)\n"
  "    double OBAtom.get_distance(OpenBabel::OBAtom *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAngle", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetAngle", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBAtomAtomIter_get_angle__SWIG_1(nargs, args, self);}  check_1: if (argc == 3) {
    return _wrap_OBAtomAtomIter_get_angle__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBAtom.get_angle",  "    double OBAtom.get_angle(int b, int c)\n"
  "    double OBAtom.get_angle(OpenBabel::OBAtom *b, OpenBabel::OBAtom *c)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","NewResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->NewResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","AddResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","AddResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (*arg1)->AddResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DeleteResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->DeleteResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","AddBond", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","AddBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); (*arg1)->AddBond(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","InsertBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","InsertBond", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3); (*arg1)->InsertBond(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DeleteBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DeleteBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","ClearBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->ClearBond(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HtoMethyl", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetHybAndGeom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHybAndGeom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","ForceNoH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->ForceNoH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasNoHForced", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_force_impl_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","ForceImplH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); (*arg1)->ForceImplH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_impl_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasImplHForced", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasImplHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","CountFreeOxygens", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","ImplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ExplicitHydrogenCount", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtomAtomIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.explicit_hydrogen_count", 
  "    unsigned int OBAtom.explicit_hydrogen_count(bool ExcludeIsotopes)\n"
  "    unsigned int OBAtom.explicit_hydrogen_count()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","MemberOfRingCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","MemberOfRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","CountRingBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SmallestBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","AverageBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","BOSum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","KBOSum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsCarbon", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsNitrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsSulfur", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsPhosphorus", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","IsInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","IsInRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsInRingSize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsHeteroatom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsNotCorH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsConnected", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsConnected", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsOneThree", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneThree", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsOneFour", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneFour", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsCarboxylOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsPhosphateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsSulfateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsNitroOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsAmideNitrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsNonPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsAromaticNOxide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsChiral", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsAxial", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsClockwise", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsAntiClockwise", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasChiralitySpecified", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasChiralVolume", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsHbondAcceptor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsHbondDonor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","IsHbondDonorH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","HasAlphaBetaUnsat", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtomAtomIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.has_alpha_beta_unsat", 
  "    bool OBAtom.has_alpha_beta_unsat(bool includePandS)\n" "    bool OBAtom.has_alpha_beta_unsat()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasBondOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasBondOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","CountBondsOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","CountBondsOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasNonSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasDoubleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasAromaticBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","MatchesSMARTS", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","MatchesSMARTS", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","ClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBAtomAtomIter_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBAtomAtomIter_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBAtomAtomIter_has_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data",  "    bool OBBase.has_data(std::string const &)\n"
  "    bool OBBase.has_data(char const *)\n" "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (*arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBAtomAtomIter_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBAtomAtomIter_delete_data__SWIG_2(nargs, args, self);} 
  check_2: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_3; return _wrap_OBAtomAtomIter_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBAtomAtomIter_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","CloneData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter const *","DataSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(*arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (*arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomAtomIter_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBAtomAtomIter_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBAtomAtomIter_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBAtomAtomIter_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBAtomAtomIter_get_data__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","GetAllData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (*arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","BeginData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomAtomIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomAtomIter *arg1 = (OpenBabel::OBAtomAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomAtomIter *","EndData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomAtomIter * >(argp1); result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBAtomBondIter;

SWIGINTERN VALUE _wrap_new_OBAtomBondIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtomBondIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBAtomBondIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtom *arg1 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBAtomBondIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","OpenBabel::OBAtomBondIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtom * >(argp1);
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBAtomBondIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBAtomBondIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBAtomBondIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBAtomBondIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBAtomBondIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBAtomBondIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBAtomBondIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const &","OpenBabel::OBAtomBondIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBAtomBondIter const &","OpenBabel::OBAtomBondIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBAtomBondIter *)new OpenBabel::OBAtomBondIter((OpenBabel::OBAtomBondIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBAtomBondIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBAtomBondIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBAtomBondIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBAtomBondIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBAtomBondIter.new",  "    OBAtomBondIter.new()\n"
  "    OBAtomBondIter.new(OpenBabel::OBAtom *atm)\n" "    OBAtomBondIter.new(OpenBabel::OBAtomBondIter const &bi)\n");
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBAtomBondIter(OpenBabel::OBAtomBondIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBAtomBondIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (bool)((OpenBabel::OBAtomBondIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtomBondIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (OpenBabel::OBAtomBondIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBAtomBondIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomBondIter(static_cast< const OpenBabel::OBAtomBondIter& >(result))), SWIGTYPE_p_OpenBabel__OBAtomBondIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomBondIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBAtomBondIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtomBondIter.inc",  "    OpenBabel::OBAtomBondIter OBAtomBondIter.inc()\n"
  "    OpenBabel::OBAtomBondIter OBAtomBondIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBBond *)((OpenBabel::OBAtomBondIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (OpenBabel::OBBond *) &((OpenBabel::OBAtomBondIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (*arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","Visit", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetBO", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetBO", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); (*arg1)->SetBO(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetBondOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetBondOrder", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetBondOrder(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_begin(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetBegin", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetBegin", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->SetBegin(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_end(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetEnd", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetEnd", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->SetEnd(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (*arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_length__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  double arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetLength", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetLength", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); (*arg1)->SetLength(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_length__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetLength", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (*arg1)->SetLength(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_length(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { return _wrap_OBAtomBondIter_set_length__SWIG_1(nargs, args, self);}  if (argc == 3) {
    return _wrap_OBAtomBondIter_set_length__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBBond.set_length", 
  "    void OBBond.set_length(OpenBabel::OBAtom *fixed, double length)\n" "    void OBBond.set_length(double length)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; int arg2 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; OpenBabel::OBAtom *arg4 = (OpenBabel::OBAtom *) 0 ; int arg5 ; int arg6 ;
  void *argp1 = 0 ; int res1 = 0 ; int val2 ; int ecode2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ;
  int val5 ; int ecode5 = 0 ; int val6 ; int ecode6 = 0 ; if ((argc < 5) || (argc > 5)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 5)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","Set", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) { SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","Set", 2, argv[0] )); }
    arg2 = static_cast< int >(val2); res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Set", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Set", 4, argv[2] ));  } 
  arg4 = reinterpret_cast< OpenBabel::OBAtom * >(argp4); ecode5 = SWIG_AsVal_int(argv[3], &val5); if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), Ruby_Format_TypeError( "", "int","Set", 5, argv[3] )); }  
  arg5 = static_cast< int >(val5); ecode6 = SWIG_AsVal_int(argv[4], &val6); if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), Ruby_Format_TypeError( "", "int","Set", 6, argv[4] )); }  
  arg6 = static_cast< int >(val6); (*arg1)->Set(arg2,arg3,arg4,arg5,arg6); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetKSingle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetKSingle(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetKDouble", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetKDouble(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetKTriple", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetKTriple(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetHash(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetWedge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetWedge(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetUp(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetDown(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetClosure", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->SetClosure(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_unset_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","UnsetHash", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->UnsetHash(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_unset_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","UnsetWedge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->UnsetWedge(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_unset_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","UnsetUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->UnsetUp(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_unset_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","UnsetDown", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->UnsetDown(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","UnsetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_unset_kekule(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","UnsetKekule", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); (*arg1)->UnsetKekule(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_bo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetBO", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->GetBO();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_bond_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetBondOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->GetBondOrder();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_flags(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetFlags", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->GetFlags();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_begin_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetBeginAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->GetBeginAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_end_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetEndAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->GetEndAtomIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_begin_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetBeginAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_begin_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetBeginAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetBeginAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_begin_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomBondIter_get_begin_atom__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBAtomBondIter_get_begin_atom__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBBond.get_begin_atom",  "    OpenBabel::OBAtom const * OBBond.get_begin_atom()\n"
  "    OpenBabel::OBAtom const * OBBond.get_begin_atom()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_end_atom__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetEndAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_end_atom__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetEndAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetEndAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_end_atom(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomBondIter_get_end_atom__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBAtomBondIter_get_end_atom__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBBond.get_end_atom",  "    OpenBabel::OBAtom const * OBBond.get_end_atom()\n"
  "    OpenBabel::OBAtom const * OBBond.get_end_atom()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNbrAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->GetNbrAtom(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMol *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_equib_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetEquibLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (double)(*arg1)->GetEquibLength();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_length(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","GetLength", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (double)(*arg1)->GetLength();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_nbr_atom_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetNbrAtomIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetNbrAtomIdx", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (unsigned int)(*arg1)->GetNbrAtomIdx(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","IsInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_rotor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsRotor", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsRotor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsAmide", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_primary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsPrimaryAmide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsPrimaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_secondary_amide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsSecondaryAmide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsSecondaryAmide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_ester(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsEster", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsEster();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_carbonyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsCarbonyl", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsCarbonyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_single(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsSingle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_double(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsDouble", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_triple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsTriple", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_ksingle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsKSingle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsKSingle();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_kdouble(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsKDouble", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsKDouble();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_ktriple(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsKTriple", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsKTriple();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_closure(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsClosure", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsClosure();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_up(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsUp", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsUp();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_down(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsDown", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsDown();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_wedge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsWedge", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsWedge();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_hash(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsHash", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsHash();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_is_double_bond_geometry(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","IsDoubleBondGeometry", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->IsDoubleBondGeometry();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","ClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBAtomBondIter_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBAtomBondIter_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBAtomBondIter_has_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data",  "    bool OBBase.has_data(std::string const &)\n"
  "    bool OBBase.has_data(char const *)\n" "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (*arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBAtomBondIter_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBAtomBondIter_delete_data__SWIG_2(nargs, args, self);} 
  check_2: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_3; return _wrap_OBAtomBondIter_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBAtomBondIter_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","CloneData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter const *","DataSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(*arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (*arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBAtomBondIter_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBAtomBondIter_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBAtomBondIter_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBAtomBondIter_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBAtomBondIter_get_data__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","GetAllData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (*arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","BeginData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBAtomBondIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBAtomBondIter *arg1 = (OpenBabel::OBAtomBondIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBAtomBondIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBAtomBondIter *","EndData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBAtomBondIter * >(argp1); result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBResidueIter;

SWIGINTERN VALUE _wrap_new_OBResidueIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBResidueIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBResidueIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBResidueIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBResidueIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBResidueIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBResidueIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBResidueIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBResidueIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBResidueIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidueIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const &","OpenBabel::OBResidueIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBResidueIter const &","OpenBabel::OBResidueIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidueIter *)new OpenBabel::OBResidueIter((OpenBabel::OBResidueIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBResidueIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBResidueIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBResidueIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBResidueIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBResidueIter.new",  "    OBResidueIter.new()\n"
  "    OBResidueIter.new(OpenBabel::OBMol *mol)\n" "    OBResidueIter.new(OpenBabel::OBResidueIter const &ri)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBResidueIter(OpenBabel::OBResidueIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBResidueIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (bool)((OpenBabel::OBResidueIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidueIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (OpenBabel::OBResidueIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBResidueIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueIter(static_cast< const OpenBabel::OBResidueIter& >(result))), SWIGTYPE_p_OpenBabel__OBResidueIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBResidueIter.inc",  "    OpenBabel::OBResidueIter OBResidueIter.inc()\n"
  "    OpenBabel::OBResidueIter OBResidueIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidue *)((OpenBabel::OBResidueIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (OpenBabel::OBResidue *) &((OpenBabel::OBResidueIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_add_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","AddAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","AddAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->AddAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_insert_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","InsertAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","InsertAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->InsertAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_remove_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","RemoveAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","RemoveAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->RemoveAtom(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetName", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetName", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetName", 2, argv[0])); }
     arg2 = ptr; }  (*arg1)->SetName((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_num__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetNum", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->SetNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_num__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; std::string arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); { std::string *ptr = (std::string *)0;
    int res = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res) || !ptr) {
      SWIG_exception_fail(SWIG_ArgError((ptr ? res : SWIG_TypeError)), Ruby_Format_TypeError( "", "std::string const","SetNum", 2, argv[0] ));  }
     arg2 = *ptr; if (SWIG_IsNewObj(res)) delete ptr; }  (*arg1)->SetNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_num(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBResidueIter_set_num__SWIG_0(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBResidueIter_set_num__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBResidue.set_num",  "    void OBResidue.set_num(unsigned int const resnum)\n"
  "    void OBResidue.set_num(std::string const resnum)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; char arg2 ; void *argp1 = 0 ; int res1 = 0 ; char val2 ;
  int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetChain", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_char(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "char","SetChain", 2, argv[0] )); }  
  arg2 = static_cast< char >(val2); (*arg1)->SetChain(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetChainNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetChainNum", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->SetChainNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetIdx", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  std::string *arg3 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int res3 = SWIG_OLDOBJ ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetAtomID", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetAtomID", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); { std::string *ptr = (std::string *)0;
    res3 = SWIG_AsPtr_std_string(argv[1], &ptr); if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "std::string const &","SetAtomID", 3, argv[1] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetAtomID", 3, argv[1])); }
     arg3 = ptr; }  (*arg1)->SetAtomID(arg2,(std::string const &)*arg3); if (SWIG_IsNewObj(res3)) delete arg3; return Qnil;
  fail: if (SWIG_IsNewObj(res3)) delete arg3; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  bool arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetHetAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetHetAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_bool(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "bool","SetHetAtom", 3, argv[1] )); }  
  arg3 = static_cast< bool >(val3); (*arg1)->SetHetAtom(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  unsigned int arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int val3 ; int ecode3 = 0 ;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetSerialNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","SetSerialNum", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_unsigned_SS_int(argv[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "unsigned int","SetSerialNum", 3, argv[1] )); }  
  arg3 = static_cast< unsigned int >(val3); (*arg1)->SetSerialNum(arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_name(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetName", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->GetName();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetNum", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (unsigned int)(*arg1)->GetNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_num_string(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; std::string result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetNumString", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->GetNumString();
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_num_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetNumAtoms", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (unsigned int)(*arg1)->GetNumAtoms();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_chain(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetChain", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (char)(*arg1)->GetChain();
  vresult = SWIG_From_char(static_cast< char >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_chain_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetChainNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (unsigned int)(*arg1)->GetChainNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_res_key(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetResKey", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (unsigned int)(*arg1)->GetResKey();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetAtoms", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->GetAtoms();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >(static_cast< const std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_bonds__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ; bool val2 ;
  int ecode2 = 0 ; SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > > result;
  VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetBonds", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (*arg1)->GetBonds(arg2);
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >(static_cast< const std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_bonds__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > > result; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->GetBonds();
  vresult = SWIG_NewPointerObj((new std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >(static_cast< const std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_bonds(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueIter_get_bonds__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueIter_get_bonds__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBResidue.get_bonds", 
  "    std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > OBResidue.get_bonds(bool exterior)\n"
  "    std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > OBResidue.get_bonds()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_atom_id(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; std::string result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetAtomID", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAtomID", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (*arg1)->GetAtomID(arg2);
  vresult = SWIG_From_std_string(static_cast< std::string >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_serial_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; unsigned int result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetSerialNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetSerialNum", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (unsigned int)(*arg1)->GetSerialNum(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_amino_acid_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetAminoAcidProperty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAminoAcidProperty", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->GetAminoAcidProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_atom_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  int arg3 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; int val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetAtomProperty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAtomProperty", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetAtomProperty", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (bool)(*arg1)->GetAtomProperty(arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_residue_property(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","GetResidueProperty", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetResidueProperty", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->GetResidueProperty(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_is_het_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","IsHetAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsHetAtom", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsHetAtom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_is_residue_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","IsResidueType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsResidueType", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->IsResidueType(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_begin_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","BeginAtoms", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->BeginAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_end_atoms(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","EndAtoms", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->EndAtoms();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBAtomIterator(static_cast< const OpenBabel::OBAtomIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_begin_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","BeginAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","BeginAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","BeginAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->BeginAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","NextAtom", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","NextAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator &","NextAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator * >(argp2);
  result = (OpenBabel::OBAtom *)(*arg1)->NextAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","Clear", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","ClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","HasData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBResidueIter_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBResidueIter_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBResidueIter_has_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data",  "    bool OBBase.has_data(std::string const &)\n"
  "    bool OBBase.has_data(char const *)\n" "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (*arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBResidueIter_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBResidueIter_delete_data__SWIG_2(nargs, args, self);} 
  check_2: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_3; return _wrap_OBResidueIter_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBResidueIter_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","SetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","CloneData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter const *","DataSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(*arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (*arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueIter_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBResidueIter_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBResidueIter_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBResidueIter_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBResidueIter_get_data__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","GetAllData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (*arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","BeginData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueIter *arg1 = (OpenBabel::OBResidueIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueIter *","EndData", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBResidueIter * >(argp1); result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBResidueAtomIter;

SWIGINTERN VALUE _wrap_new_OBResidueAtomIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBResidueAtomIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidue *arg1 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","OpenBabel::OBResidueAtomIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidue * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBResidueAtomIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBResidueAtomIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBResidueAtomIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBResidueAtomIter__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = 0 ; void *argp1 ; int res1 = 0 ; OpenBabel::OBResidueAtomIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBResidueAtomIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const &","OpenBabel::OBResidueAtomIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBResidueAtomIter const &","OpenBabel::OBResidueAtomIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *)new OpenBabel::OBResidueAtomIter((OpenBabel::OBResidueAtomIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBResidueAtomIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii;
  argc = nargs; if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBResidueAtomIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBResidue, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBResidueAtomIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBResidueAtomIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBResidueAtomIter.new",  "    OBResidueAtomIter.new()\n"
  "    OBResidueAtomIter.new(OpenBabel::OBResidue *res)\n"
  "    OBResidueAtomIter.new(OpenBabel::OBResidueAtomIter const &ri)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBResidueAtomIter(OpenBabel::OBResidueAtomIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBResidueAtomIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (bool)((OpenBabel::OBResidueAtomIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidueAtomIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBResidueAtomIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; OpenBabel::OBResidueAtomIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBResidueAtomIter(static_cast< const OpenBabel::OBResidueAtomIter& >(result))), SWIGTYPE_p_OpenBabel__OBResidueAtomIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueAtomIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBResidueAtomIter.inc",  "    OpenBabel::OBResidueAtomIter OBResidueAtomIter.inc()\n"
  "    OpenBabel::OBResidueAtomIter OBResidueAtomIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *)((OpenBabel::OBResidueAtomIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (OpenBabel::OBAtom *) &((OpenBabel::OBResidueAtomIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_Visit_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  bool val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","Visit", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","Visit", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); if (arg1) (*arg1)->Visit = arg2; return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_Visit_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","Visit", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool) ((*arg1)->Visit);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_duplicate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","Duplicate", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","Duplicate", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); (*arg1)->Duplicate(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetIdx", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetIdx(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetHyb", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHyb", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetHyb(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetAtomicNum", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetAtomicNum(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","SetIsotope", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->SetIsotope(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetImplicitValence", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetImplicitValence(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_increment_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IncrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->IncrementImplicitValence(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_decrement_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DecrementImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->DecrementImplicitValence(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetFormalCharge", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); (*arg1)->SetFormalCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; short arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  short val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_short(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "short","SetSpinMultiplicity", 2, argv[0] )); }  
  arg2 = static_cast< short >(val2); (*arg1)->SetSpinMultiplicity(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","SetType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (*arg1)->SetType((char const *)arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return Qnil; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","SetType", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","SetType", 2, argv[0])); }
     arg2 = ptr; }  (*arg1)->SetType((std::string const &)*arg2); if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBResidueAtomIter_set_type__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBResidueAtomIter_set_type__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.set_type",  "    void OBAtom.set_type(char const *type)\n"
  "    void OBAtom.set_type(std::string const &type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; double arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  double val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetPartialCharge", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); (*arg1)->SetPartialCharge(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 const &","SetVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 const &","SetVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); (*arg1)->SetVector((OpenBabel::vector3 const &)*arg2); return Qnil;
  fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; double arg2 ; double arg3 ; double arg4 ;
  void *argp1 = 0 ; int res1 = 0 ; double val2 ; int ecode2 = 0 ; double val3 ; int ecode3 = 0 ; double val4 ; int ecode4 = 0 ;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_double(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "double","SetVector", 2, argv[0] )); }  
  arg2 = static_cast< double >(val2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","SetVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); ecode4 = SWIG_AsVal_double(argv[2], &val4); if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), Ruby_Format_TypeError( "", "double","SetVector", 4, argv[2] )); }  
  arg4 = static_cast< double >(val4); (*arg1)->SetVector(arg2,arg3,arg4); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_vector__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetVector(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[5]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 5) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_set_vector__SWIG_2(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueAtomIter_set_vector__SWIG_0(nargs, args, self);}  if (argc == 4) {
    return _wrap_OBResidueAtomIter_set_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 5, "OBAtom.set_vector",  "    void OBAtom.set_vector(OpenBabel::vector3 const &v)\n"
  "    void OBAtom.set_vector(double const x, double const y, double const z)\n" "    void OBAtom.set_vector()\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; double **arg2 = (double **) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetCoordPtr", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_p_double, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "double **","SetCoordPtr", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< double ** >(argp2); (*arg1)->SetCoordPtr(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","SetResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (*arg1)->SetResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (*arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_unset_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","UnsetAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->UnsetAromatic(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetClockwiseStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_anti_clockwise_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetAntiClockwiseStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetAntiClockwiseStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetPositiveStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetNegativeStereo(); return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_unset_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","UnsetStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->UnsetStereo(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetInRing(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetChiral", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->SetChiral(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_clear_coord_ptr(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","ClearCoordPtr", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->ClearCoordPtr(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_formal_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetFormalCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (int)(*arg1)->GetFormalCharge();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_atomic_num(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetAtomicNum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetAtomicNum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_isotope(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned short result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetIsotope", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned short)(*arg1)->GetIsotope();
  vresult = SWIG_From_unsigned_SS_short(static_cast< unsigned short >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_spin_multiplicity(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetSpinMultiplicity", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (int)(*arg1)->GetSpinMultiplicity();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_atomic_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetAtomicMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->GetAtomicMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_exact_mass(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetExactMass", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->GetExactMass();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_coordinate_idx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetCoordinateIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetCoordinateIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_cidx(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetCIdx", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetCIdx();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_hyb(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetHyb", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHyb();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_implicit_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetImplicitValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetImplicitValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_hvy_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetHvyValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHvyValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_hetero_valence(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetHeteroValence", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->GetHeteroValence();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetType", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetX", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->GetX();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetY", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->GetY();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetZ", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->GetZ();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_x(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","x", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->x();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_y(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","y", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->y();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_z(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","z", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->z();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_coordinate(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  double *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetCoordinate", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double *)(*arg1)->GetCoordinate();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_double, 0 |  0 ); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_vector__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (OpenBabel::vector3 *) &(*arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_vector__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::vector3 *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","GetVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (OpenBabel::vector3 *) &(*arg1)->GetVector();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__vector3, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_vector(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[2]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 2) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_get_vector__SWIG_0(nargs, args, self);}  if (argc == 1) {
    return _wrap_OBResidueAtomIter_get_vector__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 2, "OBAtom.get_vector",  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"
  "    OpenBabel::vector3 const & OBAtom.get_vector()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_partial_charge(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetPartialCharge", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->GetPartialCharge();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_residue__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (OpenBabel::OBResidue *)(*arg1)->GetResidue();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_residue__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  bool val2 ; int ecode2 = 0 ; OpenBabel::OBResidue *result = 0 ; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","GetResidue", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (OpenBabel::OBResidue *)(*arg1)->GetResidue(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_residue(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_get_residue__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueAtomIter_get_residue__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_residue",  "    OpenBabel::OBResidue * OBAtom.get_residue()\n"
  "    OpenBabel::OBResidue * OBAtom.get_residue(bool perception)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMol *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_new_bond_vector(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ; double arg3 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double val3 ; int ecode3 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetNewBondVector", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","GetNewBondVector", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2); ecode3 = SWIG_AsVal_double(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "double","GetNewBondVector", 3, argv[1] )); }  
  arg3 = static_cast< double >(val3); result = (bool)(*arg1)->GetNewBondVector(*arg2,arg3);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->GetBond(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_next_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetNextAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (OpenBabel::OBAtom *)(*arg1)->GetNextAtom();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_begin_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","BeginBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (*arg1)->BeginBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_end_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","EndBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (*arg1)->EndBonds();
  vresult = SWIG_NewPointerObj((new OpenBabel::OBBondIterator(static_cast< const OpenBabel::OBBondIterator& >(result))), SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_begin_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","BeginBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->BeginBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_next_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBond *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","NextBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBBond *)(*arg1)->NextBond(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_begin_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","BeginNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","BeginNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->BeginNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_next_nbr_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBAtom *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","NextNbrAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","NextNbrAtom", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2); result = (OpenBabel::OBAtom *)(*arg1)->NextNbrAtom(*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_distance__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetDistance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetDistance", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_distance__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetDistance", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetDistance", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (double)(*arg1)->GetDistance(arg2);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_distance(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1;
    return _wrap_OBResidueAtomIter_get_distance__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    return _wrap_OBResidueAtomIter_get_distance__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.get_distance",  "    double OBAtom.get_distance(int index)\n"
  "    double OBAtom.get_distance(OpenBabel::OBAtom *)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_angle__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; int arg3 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ; int val3 ; int ecode3 = 0 ; double result; VALUE vresult = Qnil;
  if ((argc < 2) || (argc > 2)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","GetAngle", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); ecode3 = SWIG_AsVal_int(argv[1], &val3); if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), Ruby_Format_TypeError( "", "int","GetAngle", 3, argv[1] )); }  
  arg3 = static_cast< int >(val3); result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_angle__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  OpenBabel::OBAtom *arg3 = (OpenBabel::OBAtom *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; double result; VALUE vresult = Qnil; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","GetAngle", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBAtom * >(argp3); result = (double)(*arg1)->GetAngle(arg2,arg3);
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_angle(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[4]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 4) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 3) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBResidueAtomIter_get_angle__SWIG_1(nargs, args, self);}  check_1: if (argc == 3) {
    return _wrap_OBResidueAtomIter_get_angle__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 4, "OBAtom.get_angle",  "    double OBAtom.get_angle(int b, int c)\n"
  "    double OBAtom.get_angle(OpenBabel::OBAtom *b, OpenBabel::OBAtom *c)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_new_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","NewResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->NewResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_add_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBResidue *arg2 = (OpenBabel::OBResidue *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","AddResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBResidue, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBResidue *","AddResidue", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBResidue * >(argp2); (*arg1)->AddResidue(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DeleteResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->DeleteResidue(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_add_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","AddBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","AddBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); (*arg1)->AddBond(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_insert_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBondIterator *arg2 = 0 ;
  OpenBabel::OBBond *arg3 = (OpenBabel::OBBond *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ;
  void *argp3 = 0 ; int res3 = 0 ; if ((argc < 2) || (argc > 2)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","InsertBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBondIterator &","InsertBond", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBondIterator * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","InsertBond", 3, argv[1] ));  } 
  arg3 = reinterpret_cast< OpenBabel::OBBond * >(argp3); (*arg1)->InsertBond(*arg2,arg3); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DeleteBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","DeleteBond", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(*arg1)->DeleteBond(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_clear_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","ClearBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->ClearBond(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_hto_methyl(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HtoMethyl", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HtoMethyl();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_hyb_and_geom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetHybAndGeom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","SetHybAndGeom", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->SetHybAndGeom(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_force_no_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","ForceNoH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->ForceNoH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_no_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasNoHForced", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasNoHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_force_impl_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","ForceImplH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); (*arg1)->ForceImplH(); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_impl_hforced(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasImplHForced", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasImplHForced();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_count_free_oxygens(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","CountFreeOxygens", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->CountFreeOxygens();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_implicit_hydrogen_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","ImplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->ImplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  bool val2 ; int ecode2 = 0 ; unsigned int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","ExplicitHydrogenCount", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (unsigned int)(*arg1)->ExplicitHydrogenCount(arg2);
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","ExplicitHydrogenCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->ExplicitHydrogenCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_explicit_hydrogen_count(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueAtomIter_explicit_hydrogen_count__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.explicit_hydrogen_count", 
  "    unsigned int OBAtom.explicit_hydrogen_count(bool ExcludeIsotopes)\n"
  "    unsigned int OBAtom.explicit_hydrogen_count()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_member_of_ring_count(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","MemberOfRingCount", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->MemberOfRingCount();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_member_of_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","MemberOfRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->MemberOfRingSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_count_ring_bonds(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","CountRingBonds", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->CountRingBonds();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_smallest_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SmallestBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->SmallestBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_average_bond_angle(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; double result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","AverageBondAngle", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (double)(*arg1)->AverageBondAngle();
  vresult = SWIG_From_double(static_cast< double >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_bosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","BOSum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->BOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_kbosum(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","KBOSum", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->KBOSum();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_residue(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasResidue", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasResidue();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_carbon(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsCarbon", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsCarbon();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsNitrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_sulfur(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsSulfur", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsSulfur();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_phosphorus(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsPhosphorus", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsPhosphorus();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","IsInRing", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsInRing();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_in_ring_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","IsInRingSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsInRingSize", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->IsInRingSize(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_heteroatom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsHeteroatom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsHeteroatom();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_not_cor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsNotCorH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsNotCorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_connected(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsConnected", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsConnected", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsConnected(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_one_three(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsOneThree", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneThree", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsOneThree(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_one_four(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsOneFour", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsOneFour", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsOneFour(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_carboxyl_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsCarboxylOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsCarboxylOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_phosphate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsPhosphateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsPhosphateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_sulfate_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsSulfateOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsSulfateOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_nitro_oxygen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsNitroOxygen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsNitroOxygen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_amide_nitrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsAmideNitrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsAmideNitrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_non_polar_hydrogen(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsNonPolarHydrogen", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsNonPolarHydrogen();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_aromatic_noxide(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsAromaticNOxide", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsAromaticNOxide();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_chiral(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsChiral", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsChiral();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_axial(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsAxial", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsAxial();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsClockwise", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_anti_clockwise(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsAntiClockwise", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsAntiClockwise();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_positive_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsPositiveStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsPositiveStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_negative_stereo(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsNegativeStereo", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsNegativeStereo();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_chirality_specified(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasChiralitySpecified", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasChiralitySpecified();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_chiral_volume(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasChiralVolume", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasChiralVolume();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_hbond_acceptor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsHbondAcceptor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondAcceptor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_hbond_donor(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsHbondDonor", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondDonor();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_is_hbond_donor_h(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","IsHbondDonorH", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->IsHbondDonorH();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; bool arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  bool val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_bool(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "bool","HasAlphaBetaUnsat", 2, argv[0] )); }  
  arg2 = static_cast< bool >(val2); result = (bool)(*arg1)->HasAlphaBetaUnsat(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasAlphaBetaUnsat", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasAlphaBetaUnsat();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_alpha_beta_unsat(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3];
  int ii; argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_1(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBResidueAtomIter_has_alpha_beta_unsat__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBAtom.has_alpha_beta_unsat", 
  "    bool OBAtom.has_alpha_beta_unsat(bool includePandS)\n" "    bool OBAtom.has_alpha_beta_unsat()\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_bond_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasBondOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasBondOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasBondOfOrder(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_count_bonds_of_order(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; int result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","CountBondsOfOrder", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","CountBondsOfOrder", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (int)(*arg1)->CountBondsOfOrder(arg2);
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_non_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasNonSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasNonSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_single_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasSingleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasSingleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_double_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasDoubleBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasDoubleBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_aromatic_bond(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasAromaticBond", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->HasAromaticBond();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_matches_smarts(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","MatchesSMARTS", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","MatchesSMARTS", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->MatchesSMARTS((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_clear(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","Clear", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (bool)(*arg1)->Clear();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_do_transformations(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *arg2 = (std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; OpenBabel::OBBase *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DoTransformations", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *","DoTransformations", 2, argv[0] ));  }
  
  arg2 = reinterpret_cast< std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > * >(argp2);
  result = (OpenBabel::OBBase *)(*arg1)->DoTransformations((std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBase, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_class_description(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","ClassDescription", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (char *)(*arg1)->ClassDescription();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","HasData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","HasData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->HasData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","HasData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (bool)(*arg1)->HasData((char const *)arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","HasData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","HasData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (bool)(*arg1)->HasData(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_has_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } } 
    if (!_v) goto check_1; return _wrap_OBResidueAtomIter_has_data__SWIG_2(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_OBResidueAtomIter_has_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) {
    return _wrap_OBResidueAtomIter_has_data__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.has_data",  "    bool OBBase.has_data(std::string const &)\n"
  "    bool OBBase.has_data(char const *)\n" "    bool OBBase.has_data(unsigned int const type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","DeleteData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","DeleteData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->DeleteData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &","DeleteData", 2, argv[0])); }
   arg2 = reinterpret_cast< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > * >(argp2);
  (*arg1)->DeleteData(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 = SWIG_OLDOBJ ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","DeleteData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","DeleteData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","DeleteData", 2, argv[0])); }
     arg2 = ptr; }  result = (bool)(*arg1)->DeleteData((std::string const &)*arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_delete_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBGenericData, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_1; return _wrap_OBResidueAtomIter_delete_data__SWIG_1(nargs, args, self);}  check_1: if (argc == 2) {
    int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_2; return _wrap_OBResidueAtomIter_delete_data__SWIG_2(nargs, args, self);}
   check_2: if (argc == 2) { int _v = 0; { { int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }
     if (!_v) goto check_3; return _wrap_OBResidueAtomIter_delete_data__SWIG_0(nargs, args, self);}  check_3: if (argc == 2) {
    return _wrap_OBResidueAtomIter_delete_data__SWIG_3(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.delete_data",  "    bool OBBase.delete_data(unsigned int type)\n"
  "    bool OBBase.delete_data(OpenBabel::OBGenericData *)\n"
  "    bool OBBase.delete_data(std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > &)\n"
  "    bool OBBase.delete_data(std::string const &s)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_set_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","SetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","SetData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->SetData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_clone_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ;
  OpenBabel::OBGenericData *arg2 = (OpenBabel::OBGenericData *) 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","CloneData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBGenericData *","CloneData", 2, argv[0] ));  }
   arg2 = reinterpret_cast< OpenBabel::OBGenericData * >(argp2); (*arg1)->CloneData(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_data_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter const *","DataSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (unsigned int)(*arg1)->DataSize();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData(arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 = SWIG_OLDOBJ ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); { std::string *ptr = (std::string *)0;
    res2 = SWIG_AsPtr_std_string(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string const &","GetData", 2, argv[0] )); } 
    if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string const &","GetData", 2, argv[0])); }
     arg2 = ptr; }  result = (OpenBabel::OBGenericData *)(*arg1)->GetData((std::string const &)*arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (SWIG_IsNewObj(res2)) delete arg2; return vresult; fail: if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data__SWIG_2(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ;
  int res1 = 0 ; int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; OpenBabel::OBGenericData *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char const *","GetData", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); result = (OpenBabel::OBGenericData *)(*arg1)->GetData((char const *)arg2);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBGenericData, 0 |  0 );
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return vresult; fail: if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data__SWIG_3(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *result = 0 ; VALUE vresult = Qnil;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1);
  result = (std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *) &(*arg1)->GetData();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0 |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data__SWIG_4(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; OpenBabel::DataOrigin arg2 ; void *argp1 = 0 ;
  int res1 = 0 ; int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "OpenBabel::DataOrigin","GetData", 2, argv[0] )); }  
  arg2 = static_cast< OpenBabel::DataOrigin >(val2); result = (*arg1)->GetData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_data(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBResidueAtomIter_get_data__SWIG_3(nargs, args, self);}  if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_unsigned_SS_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_2;
    return _wrap_OBResidueAtomIter_get_data__SWIG_0(nargs, args, self);}  check_2: if (argc == 2) { int _v = 0; { {
        int res = SWIG_AsVal_int(argv[1], NULL); _v = SWIG_CheckState(res); } }  if (!_v) goto check_3;
    return _wrap_OBResidueAtomIter_get_data__SWIG_4(nargs, args, self);}  check_3: if (argc == 2) { int _v = 0; {
      int res = SWIG_AsPtr_std_string(argv[1], (std::string**)(0)); _v = SWIG_CheckState(res);}  if (!_v) goto check_4;
    return _wrap_OBResidueAtomIter_get_data__SWIG_1(nargs, args, self);}  check_4: if (argc == 2) {
    return _wrap_OBResidueAtomIter_get_data__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBBase.get_data", 
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(unsigned int const type)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(std::string const &)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(char const *)\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data()\n"
  "    std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > OBBase.get_data(OpenBabel::DataOrigin source)\n");
  return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_get_all_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; unsigned int arg2 ; void *argp1 = 0 ; int res1 = 0 ;
  unsigned int val2 ; int ecode2 = 0 ;
  std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","GetAllData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); ecode2 = SWIG_AsVal_unsigned_SS_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "unsigned int","GetAllData", 2, argv[0] )); }  
  arg2 = static_cast< unsigned int >(val2); result = (*arg1)->GetAllData(arg2);
  vresult = swig::from(static_cast< std::vector<OpenBabel::OBGenericData*,std::allocator< OpenBabel::OBGenericData * > > >(result));
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_begin_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","BeginData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (*arg1)->BeginData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBResidueAtomIter_end_data(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBResidueAtomIter *arg1 = (OpenBabel::OBResidueAtomIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  SwigValueWrapper< std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator > result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBResidueAtomIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBResidueAtomIter *","EndData", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBResidueAtomIter * >(argp1); result = (*arg1)->EndData();
  vresult = SWIG_NewPointerObj(swig::make_nonconst_iterator(static_cast< const OpenBabel::OBDataIterator & >(result), self),
  swig::Iterator::descriptor(),SWIG_POINTER_OWN); return vresult; fail: return Qnil; }
swig_class SwigClassOBMolAngleIter;

SWIGINTERN VALUE _wrap_new_OBMolAngleIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolAngleIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolAngleIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMolAngleIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBMolAngleIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMolAngleIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMolAngleIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolAngleIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMolAngleIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolAngleIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBMolAngleIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolAngleIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAngleIter const &","OpenBabel::OBMolAngleIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolAngleIter const &","OpenBabel::OBMolAngleIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = (OpenBabel::OBMolAngleIter *)new OpenBabel::OBMolAngleIter((OpenBabel::OBMolAngleIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolAngleIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMolAngleIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBMolAngleIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBMolAngleIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBMolAngleIter.new",  "    OBMolAngleIter.new()\n"
  "    OBMolAngleIter.new(OpenBabel::OBMol *mol)\n" "    OBMolAngleIter.new(OpenBabel::OBMolAngleIter const &ai)\n");
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMolAngleIter(OpenBabel::OBMolAngleIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMolAngleIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAngleIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = (bool)((OpenBabel::OBMolAngleIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAngleIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMolAngleIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAngleIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1); result = (OpenBabel::OBMolAngleIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolAngleIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolAngleIter *arg1 = (OpenBabel::OBMolAngleIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolAngleIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolAngleIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolAngleIter * >(argp1);
  result = ((OpenBabel::OBMolAngleIter const *)arg1)->operator *();
  vresult = swig::from(static_cast< std::vector<unsigned int,std::allocator< unsigned int > > >(result)); return vresult; fail:
  return Qnil; }
swig_class SwigClassOBMolTorsionIter;

SWIGINTERN VALUE _wrap_new_OBMolTorsionIter__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *result = 0 ; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter(); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolTorsionIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMolTorsionIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBMolTorsionIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMolTorsionIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMolTorsionIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolTorsionIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMolTorsionIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolTorsionIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBMolTorsionIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolTorsionIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolTorsionIter const &","OpenBabel::OBMolTorsionIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolTorsionIter const &","OpenBabel::OBMolTorsionIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *)new OpenBabel::OBMolTorsionIter((OpenBabel::OBMolTorsionIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolTorsionIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMolTorsionIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBMolTorsionIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBMolTorsionIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBMolTorsionIter.new",  "    OBMolTorsionIter.new()\n"
  "    OBMolTorsionIter.new(OpenBabel::OBMol *mol)\n" "    OBMolTorsionIter.new(OpenBabel::OBMolTorsionIter const &ai)\n");
  return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMolTorsionIter(OpenBabel::OBMolTorsionIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMolTorsionIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolTorsionIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (bool)((OpenBabel::OBMolTorsionIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolTorsionIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMolTorsionIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolTorsionIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = (OpenBabel::OBMolTorsionIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolTorsionIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolTorsionIter *arg1 = (OpenBabel::OBMolTorsionIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolTorsionIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolTorsionIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolTorsionIter * >(argp1);
  result = ((OpenBabel::OBMolTorsionIter const *)arg1)->operator *();
  vresult = swig::from(static_cast< std::vector<unsigned int,std::allocator< unsigned int > > >(result)); return vresult; fail:
  return Qnil; }
swig_class SwigClassOBMolPairIter;

SWIGINTERN VALUE _wrap_new_OBMolPairIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolPairIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolPairIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMolPairIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBMolPairIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMolPairIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMolPairIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolPairIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMolPairIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolPairIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBMolPairIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolPairIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolPairIter const &","OpenBabel::OBMolPairIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolPairIter const &","OpenBabel::OBMolPairIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = (OpenBabel::OBMolPairIter *)new OpenBabel::OBMolPairIter((OpenBabel::OBMolPairIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolPairIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMolPairIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBMolPairIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBMolPairIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBMolPairIter.new",  "    OBMolPairIter.new()\n"
  "    OBMolPairIter.new(OpenBabel::OBMol *mol)\n" "    OBMolPairIter.new(OpenBabel::OBMolPairIter const &ai)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMolPairIter(OpenBabel::OBMolPairIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMolPairIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolPairIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = (bool)((OpenBabel::OBMolPairIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolPairIter_inc(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMolPairIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolPairIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1); result = (OpenBabel::OBMolPairIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolPairIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolPairIter *arg1 = (OpenBabel::OBMolPairIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< unsigned int,std::allocator< unsigned int > > result; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolPairIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolPairIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolPairIter * >(argp1);
  result = ((OpenBabel::OBMolPairIter const *)arg1)->operator *();
  vresult = swig::from(static_cast< std::vector<unsigned int,std::allocator< unsigned int > > >(result)); return vresult; fail:
  return Qnil; }
swig_class SwigClassOBMolRingIter;

SWIGINTERN VALUE _wrap_new_OBMolRingIter__SWIG_0(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolRingIter *result = 0 ;
  if ((argc < 0) || (argc > 0)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter(); DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolRingIter__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMol *arg1 = (OpenBabel::OBMol *) 0 ; void *argp1 = 0 ; int res1 = 0 ; OpenBabel::OBMolRingIter *result = 0 ;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","OpenBabel::OBMolRingIter", 1, argv[0] ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMol * >(argp1);
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter(arg1); DATA_PTR(self) = result; return self; fail:
  return Qnil; }
#ifdef HAVE_RB_DEFINE_ALLOC_FUNC
SWIGINTERN VALUE _wrap_OBMolRingIter_allocate(VALUE self) {
#else
   SWIGINTERN VALUE _wrap_OBMolRingIter_allocate(int argc, VALUE *argv, VALUE self) {
#endif
     VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_OpenBabel__OBMolRingIter);
#ifndef HAVE_RB_DEFINE_ALLOC_FUNC
    rb_obj_call_init(vresult, argc, argv);
#endif
     return vresult; }
SWIGINTERN VALUE _wrap_new_OBMolRingIter__SWIG_2(int argc, VALUE *argv, VALUE self) { OpenBabel::OBMolRingIter *arg1 = 0 ;
  void *argp1 ; int res1 = 0 ; OpenBabel::OBMolRingIter *result = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(argv[0], &argp1, SWIGTYPE_p_OpenBabel__OBMolRingIter,  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter const &","OpenBabel::OBMolRingIter", 1, argv[0] ));  }
   if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBMolRingIter const &","OpenBabel::OBMolRingIter", 1, argv[0])); }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBMolRingIter *)new OpenBabel::OBMolRingIter((OpenBabel::OBMolRingIter const &)*arg1);
  DATA_PTR(self) = result; return self; fail: return Qnil; }
SWIGINTERN VALUE _wrap_new_OBMolRingIter(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[1]; int ii; argc = nargs;
  if (argc > 1) SWIG_fail; for (ii = 0; (ii < argc); ++ii) { argv[ii] = args[ii]; }  if (argc == 0) {
    return _wrap_new_OBMolRingIter__SWIG_0(nargs, args, self);}  if (argc == 1) { int _v = 0; { void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_OpenBabel__OBMol, 0); _v = SWIG_CheckState(res);} 
    if (!_v) goto check_2; return _wrap_new_OBMolRingIter__SWIG_1(nargs, args, self);}  check_2: if (argc == 1) {
    return _wrap_new_OBMolRingIter__SWIG_2(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 1, "OBMolRingIter.new",  "    OBMolRingIter.new()\n"
  "    OBMolRingIter.new(OpenBabel::OBMol *mol)\n" "    OBMolRingIter.new(OpenBabel::OBMolRingIter const &ri)\n"); return Qnil; }
SWIGINTERN void
free_OpenBabel_OBMolRingIter(OpenBabel::OBMolRingIter *arg1) {
    delete arg1;
}

SWIGINTERN VALUE _wrap_OBMolRingIter_good(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter const *","operator bool", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (bool)((OpenBabel::OBMolRingIter const *)arg1)->operator bool();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_inc__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMolRingIter *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (OpenBabel::OBMolRingIter *) &(arg1)->operator ++();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_inc__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; OpenBabel::OBMolRingIter result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","operator ++", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","operator ++", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (arg1)->operator ++(arg2);
  vresult = SWIG_NewPointerObj((new OpenBabel::OBMolRingIter(static_cast< const OpenBabel::OBMolRingIter& >(result))), SWIGTYPE_p_OpenBabel__OBMolRingIter, SWIG_POINTER_OWN |  0 );
  return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_inc(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 1) { return _wrap_OBMolRingIter_inc__SWIG_0(nargs, args, self);}  if (argc == 2) {
    return _wrap_OBMolRingIter_inc__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBMolRingIter.inc",  "    OpenBabel::OBMolRingIter OBMolRingIter.inc()\n"
  "    OpenBabel::OBMolRingIter OBMolRingIter.inc(int)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_deref(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBRing *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter const *","operator ->", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBRing *)((OpenBabel::OBMolRingIter const *)arg1)->operator ->();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter___ref__(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBRing *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter const *","operator *", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (OpenBabel::OBRing *) &((OpenBabel::OBMolRingIter const *)arg1)->operator *();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBRing, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter__path_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; std::vector< int,std::allocator< int > > *arg2 = 0 ;
  void *argp1 = 0 ; int res1 = 0 ; int res2 = SWIG_OLDOBJ ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","_path", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); {
    std::vector<int,std::allocator< int > > *ptr = (std::vector<int,std::allocator< int > > *)0;
    res2 = swig::asptr(argv[0], &ptr); if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::vector< int,std::allocator< int > > const &","_path", 2, argv[0] )); }
     if (!ptr) {
      SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::vector< int,std::allocator< int > > const &","_path", 2, argv[0])); }
     arg2 = ptr; }  if (arg1) (*arg1)->_path = *arg2; if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; fail:
  if (SWIG_IsNewObj(res2)) delete arg2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter__path_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  std::vector< int,std::allocator< int > > *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","_path", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  result = (std::vector< int,std::allocator< int > > *) & ((*arg1)->_path);
  vresult = swig::from(static_cast< std::vector<int,std::allocator< int > > >(*result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter__pathset_set(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; OpenBabel::OBBitVec *arg2 = 0 ; void *argp1 = 0 ;
  int res1 = 0 ; void *argp2 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","_pathset", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__OBBitVec,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBitVec const &","_pathset", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::OBBitVec const &","_pathset", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::OBBitVec * >(argp2); if (arg1) (*arg1)->_pathset = *arg2; return Qnil; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter__pathset_get(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBBitVec *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","_pathset", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (OpenBabel::OBBitVec *) & ((*arg1)->_pathset);
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBBitVec, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter const *","Size", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (int)(*arg1)->Size();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_path_size(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter const *","PathSize", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (int)(*arg1)->PathSize();
  vresult = SWIG_From_int(static_cast< int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_is_aromatic(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; bool result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","IsAromatic", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (bool)(*arg1)->IsAromatic();
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_set_type__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; char *arg2 = (char *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  int res2 ; char *buf2 = 0 ; int alloc2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); res2 = SWIG_AsCharPtrAndSize(argv[0], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "char *","SetType", 2, argv[0] )); } 
  arg2 = reinterpret_cast< char * >(buf2); (*arg1)->SetType(arg2); if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2; return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_set_type__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; std::string *arg2 = 0 ; void *argp1 = 0 ; int res1 = 0 ;
  void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","SetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_std__string,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "std::string &","SetType", 2, argv[0] ));  } 
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "std::string &","SetType", 2, argv[0])); }
   arg2 = reinterpret_cast< std::string * >(argp2); (*arg1)->SetType(*arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_set_type(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__string, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBMolRingIter_set_type__SWIG_1(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBMolRingIter_set_type__SWIG_0(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBRing.set_type",  "    void OBRing.set_type(char *type)\n"
  "    void OBRing.set_type(std::string &type)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_get_type(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; char *result = 0 ;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","GetType", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (char *)(*arg1)->GetType();
  vresult = SWIG_FromCharPtr((const char *)result); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_get_root_atom(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ; unsigned int result;
  VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","GetRootAtom", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (unsigned int)(*arg1)->GetRootAtom();
  vresult = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_is_member__SWIG_0(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; OpenBabel::OBAtom *arg2 = (OpenBabel::OBAtom *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","IsMember", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBAtom, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBAtom *","IsMember", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBAtom * >(argp2); result = (bool)(*arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_is_member__SWIG_1(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; OpenBabel::OBBond *arg2 = (OpenBabel::OBBond *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 1) || (argc > 1)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","IsMember", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBBond, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBBond *","IsMember", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBBond * >(argp2); result = (bool)(*arg1)->IsMember(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_is_member(int nargs, VALUE *args, VALUE self) { int argc; VALUE argv[3]; int ii;
  argc = nargs + 1; argv[0] = self; if (argc > 3) SWIG_fail; for (ii = 1; (ii < argc); ++ii) { argv[ii] = args[ii-1]; } 
  if (argc == 2) { int _v = 0; { void *vptr = 0; int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_OpenBabel__OBAtom, 0);
      _v = SWIG_CheckState(res);}  if (!_v) goto check_1; return _wrap_OBMolRingIter_is_member__SWIG_0(nargs, args, self);} 
  check_1: if (argc == 2) { return _wrap_OBMolRingIter_is_member__SWIG_1(nargs, args, self);}  fail:
  Ruby_Format_OverloadedError( argc, 3, "OBRing.is_member",  "    bool OBRing.is_member(OpenBabel::OBAtom *a)\n"
  "    bool OBRing.is_member(OpenBabel::OBBond *b)\n"); return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_is_in_ring(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; int arg2 ; void *argp1 = 0 ; int res1 = 0 ; int val2 ;
  int ecode2 = 0 ; bool result; VALUE vresult = Qnil; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","IsInRing", 1, self ));  } 
  arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); ecode2 = SWIG_AsVal_int(argv[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), Ruby_Format_TypeError( "", "int","IsInRing", 2, argv[0] )); }  
  arg2 = static_cast< int >(val2); result = (bool)(*arg1)->IsInRing(arg2);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_set_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; OpenBabel::OBMol *arg2 = (OpenBabel::OBMol *) 0 ;
  void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ; int res2 = 0 ; if ((argc < 1) || (argc > 1)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","SetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2,SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::OBMol *","SetParent", 2, argv[0] ));  } 
  arg2 = reinterpret_cast< OpenBabel::OBMol * >(argp2); (*arg1)->SetParent(arg2); return Qnil; fail: return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_get_parent(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; void *argp1 = 0 ; int res1 = 0 ;
  OpenBabel::OBMol *result = 0 ; VALUE vresult = Qnil; if ((argc < 0) || (argc > 0)) {
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","GetParent", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1); result = (OpenBabel::OBMol *)(*arg1)->GetParent();
  vresult = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OpenBabel__OBMol, 0 |  0 ); return vresult; fail:
  return Qnil; }
SWIGINTERN VALUE _wrap_OBMolRingIter_find_center_and_normal(int argc, VALUE *argv, VALUE self) {
  OpenBabel::OBMolRingIter *arg1 = (OpenBabel::OBMolRingIter *) 0 ; OpenBabel::vector3 *arg2 = 0 ;
  OpenBabel::vector3 *arg3 = 0 ; OpenBabel::vector3 *arg4 = 0 ; void *argp1 = 0 ; int res1 = 0 ; void *argp2 = 0 ;
  int res2 = 0 ; void *argp3 = 0 ; int res3 = 0 ; void *argp4 = 0 ; int res4 = 0 ; bool result; VALUE vresult = Qnil;
  if ((argc < 3) || (argc > 3)) { rb_raise(rb_eArgError, "wrong # of arguments(%d for 3)",argc); SWIG_fail;} 
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OpenBabel__OBMolRingIter, 0 |  0 ); if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), Ruby_Format_TypeError( "", "OpenBabel::OBMolRingIter *","findCenterAndNormal", 1, self ));  }
   arg1 = reinterpret_cast< OpenBabel::OBMolRingIter * >(argp1);
  res2 = SWIG_ConvertPtr(argv[0], &argp2, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","findCenterAndNormal", 2, argv[0] ));  }
   if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","findCenterAndNormal", 2, argv[0])); }
   arg2 = reinterpret_cast< OpenBabel::vector3 * >(argp2);
  res3 = SWIG_ConvertPtr(argv[1], &argp3, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","findCenterAndNormal", 3, argv[1] ));  }
   if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","findCenterAndNormal", 3, argv[1])); }
   arg3 = reinterpret_cast< OpenBabel::vector3 * >(argp3);
  res4 = SWIG_ConvertPtr(argv[2], &argp4, SWIGTYPE_p_OpenBabel__vector3,  0 ); if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), Ruby_Format_TypeError( "", "OpenBabel::vector3 &","findCenterAndNormal", 4, argv[2] ));  }
   if (!argp4) {
    SWIG_exception_fail(SWIG_ValueError, Ruby_Format_TypeError("invalid null reference ", "OpenBabel::vector3 &","findCenterAndNormal", 4, argv[2])); }
   arg4 = reinterpret_cast< OpenBabel::vector3 * >(argp4); result = (bool)(*arg1)->findCenterAndNormal(*arg2,*arg3,*arg4);
  vresult = SWIG_From_bool(static_cast< bool >(result)); return vresult; fail: return Qnil; }

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_OpenBabel__OBAtomTyperTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBAtomTyper *) x));
}
static void *_p_OpenBabel__OBAromaticTyperTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBAromaticTyper *) x));
}
static void *_p_OpenBabel__OBResidueDataTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBResidueData *) x));
}
static void *_p_OpenBabel__OBRingTyperTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBRingTyper *) x));
}
static void *_p_OpenBabel__OBIsotopeTableTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBIsotopeTable *) x));
}
static void *_p_OpenBabel__OBTypeTableTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBTypeTable *) x));
}
static void *_p_OpenBabel__OBElementTableTo_p_OpenBabel__OBGlobalDataBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGlobalDataBase *)  ((OpenBabel::OBElementTable *) x));
}
static void *_p_swig__IteratorTo_p_swig__ConstIterator(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((swig::ConstIterator *)  ((swig::Iterator *) x));
}
static void *_p_OpenBabel__OBDescriptorTo_p_OpenBabel__OBPlugin(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBPlugin *)  ((OpenBabel::OBDescriptor *) x));
}
static void *_p_OpenBabel__OBOpTo_p_OpenBabel__OBPlugin(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBPlugin *)  ((OpenBabel::OBOp *) x));
}
static void *_p_OpenBabel__OBForceFieldTo_p_OpenBabel__OBPlugin(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBPlugin *)  ((OpenBabel::OBForceField *) x));
}
static void *_p_OpenBabel__OBFormatTo_p_OpenBabel__OBPlugin(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBPlugin *)  ((OpenBabel::OBFormat *) x));
}
static void *_p_OpenBabel__OBFingerprintTo_p_OpenBabel__OBPlugin(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBPlugin *)  ((OpenBabel::OBFingerprint *) x));
}
static void *_p_OpenBabel__OBMolTo_p_OpenBabel__OBBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBMol *) x));
}
static void *_p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBResidue *) x));
}
static void *_p_OpenBabel__OBBondTo_p_OpenBabel__OBBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBBond *) x));
}
static void *_p_OpenBabel__OBAtomTo_p_OpenBabel__OBBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBBase *)  ((OpenBabel::OBAtom *) x));
}
static void *_p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVibrationData *) x));
}
static void *_p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBTorsionData *) x));
}
static void *_p_OpenBabel__OBRotationDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBRotationData *) x));
}
static void *_p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBPairData *) x));
}
static void *_p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBAngleData *) x));
}
static void *_p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBChiralData *) x));
}
static void *_p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBRingData *) x));
}
static void *_p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSerialNums *) x));
}
static void *_p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBExternalBondData *) x));
}
static void *_p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSetData *) x));
}
static void *_p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBSymmetryData *) x));
}
static void *_p_OpenBabel__OBMatrixDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBMatrixData *) x));
}
static void *_p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBCommentData *) x));
}
static void *_p_OpenBabel__OBVectorDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVectorData *) x));
}
static void *_p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBVirtualBond *) x));
}
static void *_p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBConformerData *) x));
}
static void *_p_OpenBabel__OBGridDataTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBGridData *) x));
}
static void *_p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData *)  ((OpenBabel::OBUnitCell *) x));
}
static void *_p_p_OpenBabel__OBVibrationDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVibrationData **) x));
}
static void *_p_p_OpenBabel__OBTorsionDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBTorsionData **) x));
}
static void *_p_p_OpenBabel__OBRotationDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBRotationData **) x));
}
static void *_p_p_OpenBabel__OBPairDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBPairData **) x));
}
static void *_p_p_OpenBabel__OBAngleDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBAngleData **) x));
}
static void *_p_p_OpenBabel__OBChiralDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBChiralData **) x));
}
static void *_p_p_OpenBabel__OBRingDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBRingData **) x));
}
static void *_p_p_OpenBabel__OBSerialNumsTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSerialNums **) x));
}
static void *_p_p_OpenBabel__OBExternalBondDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBExternalBondData **) x));
}
static void *_p_p_OpenBabel__OBSetDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSetData **) x));
}
static void *_p_p_OpenBabel__OBSymmetryDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBSymmetryData **) x));
}
static void *_p_p_OpenBabel__OBMatrixDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBMatrixData **) x));
}
static void *_p_p_OpenBabel__OBCommentDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBCommentData **) x));
}
static void *_p_p_OpenBabel__OBVectorDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVectorData **) x));
}
static void *_p_p_OpenBabel__OBVirtualBondTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBVirtualBond **) x));
}
static void *_p_p_OpenBabel__OBConformerDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBConformerData **) x));
}
static void *_p_p_OpenBabel__OBGridDataTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBGridData **) x));
}
static void *_p_p_OpenBabel__OBUnitCellTo_p_p_OpenBabel__OBGenericData(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBGenericData **)  ((OpenBabel::OBUnitCell **) x));
}
static void *_p_OpenBabel__OBFFCalculation3To_p_OpenBabel__OBFFCalculation2(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBFFCalculation2 *)  ((OpenBabel::OBFFCalculation3 *) x));
}
static void *_p_OpenBabel__OBFFCalculation4To_p_OpenBabel__OBFFCalculation2(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBFFCalculation2 *) (OpenBabel::OBFFCalculation3 *) ((OpenBabel::OBFFCalculation4 *) x));
}
static void *_p_OpenBabel__OBFFCalculation4To_p_OpenBabel__OBFFCalculation3(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((OpenBabel::OBFFCalculation3 *)  ((OpenBabel::OBFFCalculation4 *) x));
}
static swig_type_info _swigt__p_OpMap = {"_p_OpMap", "OpMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__CharPtrLess = {"_p_OpenBabel__CharPtrLess", "OpenBabel::CharPtrLess *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__DoubleType = {"_p_OpenBabel__DoubleType", "OpenBabel::DoubleType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FastSearch = {"_p_OpenBabel__FastSearch", "OpenBabel::FastSearch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FastSearchIndexer = {"_p_OpenBabel__FastSearchIndexer", "OpenBabel::FastSearchIndexer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FptIndex = {"_p_OpenBabel__FptIndex", "OpenBabel::FptIndex *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__FptIndexHeader = {"_p_OpenBabel__FptIndexHeader", "OpenBabel::FptIndexHeader *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__LineSearchType = {"_p_OpenBabel__LineSearchType", "OpenBabel::LineSearchType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAngle = {"_p_OpenBabel__OBAngle", "OpenBabel::OBAngle *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAngleData = {"_p_OpenBabel__OBAngleData", "OpenBabel::OBAngleData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAromaticTyper = {"_p_OpenBabel__OBAromaticTyper", "OpenBabel::OBAromaticTyper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtom = {"_p_OpenBabel__OBAtom", "OpenBabel::OBNodeBase *|OpenBabel::OBAtom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomAtomIter = {"_p_OpenBabel__OBAtomAtomIter", "OpenBabel::OBAtomAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomBondIter = {"_p_OpenBabel__OBAtomBondIter", "OpenBabel::OBAtomBondIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBAtomTyper = {"_p_OpenBabel__OBAtomTyper", "OpenBabel::OBAtomTyper *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBase = {"_p_OpenBabel__OBBase", "OpenBabel::OBBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBitVec = {"_p_OpenBabel__OBBitVec", "OpenBabel::OBBitVec *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBBond = {"_p_OpenBabel__OBBond", "OpenBabel::OBBond *|OpenBabel::OBEdgeBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBChainsParser = {"_p_OpenBabel__OBChainsParser", "OpenBabel::OBChainsParser *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBChiralData = {"_p_OpenBabel__OBChiralData", "OpenBabel::OBChiralData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBCommentData = {"_p_OpenBabel__OBCommentData", "OpenBabel::OBCommentData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBConformerData = {"_p_OpenBabel__OBConformerData", "OpenBabel::OBConformerData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBConversion = {"_p_OpenBabel__OBConversion", "OpenBabel::OBConversion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBDescriptor = {"_p_OpenBabel__OBDescriptor", "OpenBabel::OBDescriptor *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBElement = {"_p_OpenBabel__OBElement", "OpenBabel::OBElement *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBElementTable = {"_p_OpenBabel__OBElementTable", "OpenBabel::OBElementTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBError = {"_p_OpenBabel__OBError", "OpenBabel::OBError *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBExternalBond = {"_p_OpenBabel__OBExternalBond", "OpenBabel::OBExternalBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBExternalBondData = {"_p_OpenBabel__OBExternalBondData", "OpenBabel::OBExternalBondData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFCalculation2 = {"_p_OpenBabel__OBFFCalculation2", "OpenBabel::OBFFCalculation2 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFCalculation3 = {"_p_OpenBabel__OBFFCalculation3", "OpenBabel::OBFFCalculation3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFCalculation4 = {"_p_OpenBabel__OBFFCalculation4", "OpenBabel::OBFFCalculation4 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFConstraint = {"_p_OpenBabel__OBFFConstraint", "OpenBabel::OBFFConstraint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFConstraints = {"_p_OpenBabel__OBFFConstraints", "OpenBabel::OBFFConstraints *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFFParameter = {"_p_OpenBabel__OBFFParameter", "OpenBabel::OBFFParameter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFingerprint = {"_p_OpenBabel__OBFingerprint", "OpenBabel::OBFingerprint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBForceField = {"_p_OpenBabel__OBForceField", "OpenBabel::OBForceField *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBFormat = {"_p_OpenBabel__OBFormat", "OpenBabel::OBFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGenericData = {"_p_OpenBabel__OBGenericData", "OpenBabel::OBGenericData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGlobalDataBase = {"_p_OpenBabel__OBGlobalDataBase", "OpenBabel::OBGlobalDataBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingTyper = {"_p_OpenBabel__OBRingTyper", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_OpenBabel__OBGridData = {"_p_OpenBabel__OBGridData", "OpenBabel::OBGridData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBInternalCoord = {"_p_OpenBabel__OBInternalCoord", "OpenBabel::OBInternalCoord *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBIsotopeTable = {"_p_OpenBabel__OBIsotopeTable", "OpenBabel::OBIsotopeTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMatrixData = {"_p_OpenBabel__OBMatrixData", "OpenBabel::OBMatrixData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMessageHandler = {"_p_OpenBabel__OBMessageHandler", "OpenBabel::OBMessageHandler *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMol = {"_p_OpenBabel__OBMol", "OpenBabel::OBMol *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAngleIter = {"_p_OpenBabel__OBMolAngleIter", "OpenBabel::OBMolAngleIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomDFSIter = {"_p_OpenBabel__OBMolAtomDFSIter", "OpenBabel::OBMolAtomDFSIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolAtomIter = {"_p_OpenBabel__OBMolAtomIter", "OpenBabel::OBMolAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolBondIter = {"_p_OpenBabel__OBMolBondIter", "OpenBabel::OBMolBondIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolPairIter = {"_p_OpenBabel__OBMolPairIter", "OpenBabel::OBMolPairIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolRingIter = {"_p_OpenBabel__OBMolRingIter", "OpenBabel::OBMolRingIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBMolTorsionIter = {"_p_OpenBabel__OBMolTorsionIter", "OpenBabel::OBMolTorsionIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBOp = {"_p_OpenBabel__OBOp", "OpenBabel::OBOp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairData = {"_p_OpenBabel__OBPairData", "OpenBabel::OBPairData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairTemplateT_double_t = {"_p_OpenBabel__OBPairTemplateT_double_t", "OpenBabel::OBPairFloatingPoint *|OpenBabel::OBPairTemplate< double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPairTemplateT_int_t = {"_p_OpenBabel__OBPairTemplateT_int_t", "OpenBabel::OBPairInteger *|OpenBabel::OBPairTemplate< int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPlugin = {"_p_OpenBabel__OBPlugin", "OpenBabel::OBPlugin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBPlugin__PluginMapType__const_iterator = {"_p_OpenBabel__OBPlugin__PluginMapType__const_iterator", "OpenBabel::OBPlugin::PluginMapType::const_iterator *|OpenBabel::OBPlugin::PluginIterator *|OpenBabel::Formatpos *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRTree = {"_p_OpenBabel__OBRTree", "OpenBabel::OBRTree *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRandom = {"_p_OpenBabel__OBRandom", "OpenBabel::OBRandom *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidue = {"_p_OpenBabel__OBResidue", "OpenBabel::OBResidue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueAtomIter = {"_p_OpenBabel__OBResidueAtomIter", "OpenBabel::OBResidueAtomIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueData = {"_p_OpenBabel__OBResidueData", "OpenBabel::OBResidueData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBResidueIter = {"_p_OpenBabel__OBResidueIter", "OpenBabel::OBResidueIter *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRing = {"_p_OpenBabel__OBRing", "OpenBabel::OBRing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingData = {"_p_OpenBabel__OBRingData", "OpenBabel::OBRingData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRingSearch = {"_p_OpenBabel__OBRingSearch", "OpenBabel::OBRingSearch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBRotationData = {"_p_OpenBabel__OBRotationData", "OpenBabel::OBRotationData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSSMatch = {"_p_OpenBabel__OBSSMatch", "OpenBabel::OBSSMatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSerialNums = {"_p_OpenBabel__OBSerialNums", "OpenBabel::OBSerialNums *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSetData = {"_p_OpenBabel__OBSetData", "OpenBabel::OBSetData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSmartsPattern = {"_p_OpenBabel__OBSmartsPattern", "OpenBabel::OBSmartsPattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSqrtTbl = {"_p_OpenBabel__OBSqrtTbl", "OpenBabel::OBSqrtTbl *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBStopwatch = {"_p_OpenBabel__OBStopwatch", "OpenBabel::OBStopwatch *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBSymmetryData = {"_p_OpenBabel__OBSymmetryData", "OpenBabel::OBSymmetryData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTorsion = {"_p_OpenBabel__OBTorsion", "OpenBabel::OBTorsion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTorsionData = {"_p_OpenBabel__OBTorsionData", "OpenBabel::OBTorsionData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBTypeTable = {"_p_OpenBabel__OBTypeTable", "OpenBabel::OBTypeTable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBUnitCell = {"_p_OpenBabel__OBUnitCell", "OpenBabel::OBUnitCell *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVectorData = {"_p_OpenBabel__OBVectorData", "OpenBabel::OBVectorData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVibrationData = {"_p_OpenBabel__OBVibrationData", "OpenBabel::OBVibrationData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__OBVirtualBond = {"_p_OpenBabel__OBVirtualBond", "OpenBabel::OBVirtualBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__Pattern = {"_p_OpenBabel__Pattern", "OpenBabel::Pattern *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__SpaceGroup = {"_p_OpenBabel__SpaceGroup", "OpenBabel::SpaceGroup *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__Template = {"_p_OpenBabel__Template", "OpenBabel::Template *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__matrix3x3 = {"_p_OpenBabel__matrix3x3", "OpenBabel::matrix3x3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__obLogBuf = {"_p_OpenBabel__obLogBuf", "OpenBabel::obLogBuf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "OpenBabel::quad< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OpenBabel__vector3 = {"_p_OpenBabel__vector3", "OpenBabel::vector3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PluginIterator = {"_p_PluginIterator", "PluginIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PluginMapType = {"_p_PluginMapType", "PluginMapType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Unit = {"_p_Unit", "Unit *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_3__double = {"_p_a_3__double", "double (*)[3]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_a_4__char = {"_p_a_4__char", "char (*)[4]", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_reference = {"_p_const_reference", "const_reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBDescriptor = {"_p_p_OpenBabel__OBDescriptor", "OpenBabel::OBDescriptor **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBFingerprint = {"_p_p_OpenBabel__OBFingerprint", "OpenBabel::OBFingerprint **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBForceField = {"_p_p_OpenBabel__OBForceField", "OpenBabel::OBForceField **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBFormat = {"_p_p_OpenBabel__OBFormat", "OpenBabel::OBFormat **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBOp = {"_p_p_OpenBabel__OBOp", "OpenBabel::OBOp **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_int = {"_p_p_int", "int **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_void = {"_p_p_void", "void **|VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_reference = {"_p_reference", "reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__dequeT_int_t = {"_p_std__dequeT_int_t", "std::deque< int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t = {"_p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t", "OpenBabel::OBPlugin::PluginMapType *|std::map< char const *,OpenBabel::OBPlugin *,OpenBabel::CharPtrLess,std::allocator< std::pair< char const *const,OpenBabel::OBPlugin * > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t = {"_p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t", "std::map< int,OpenBabel::OBAtom *,std::less< int >,std::allocator< std::pair< int const,OpenBabel::OBAtom * > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t = {"_p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t", "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > > *|OpenBabel::OBOp::OpMap *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__multimapT_double_unsigned_int_t = {"_p_std__multimapT_double_unsigned_int_t", "std::multimap< double,unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t = {"_p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t", "std::pair< OpenBabel::OBAtom *,OpenBabel::OBAtom * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__streampos = {"_p_std__streampos", "std::streampos *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__type_info = {"_p_std__type_info", "std::type_info *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t = {"_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator = {"_p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator", "std::vector< OpenBabel::OBAtom *,std::allocator< OpenBabel::OBAtom * > >::iterator *|OpenBabel::OBAtomIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t = {"_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t", "std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator = {"_p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator", "std::vector< OpenBabel::OBBond *,std::allocator< OpenBabel::OBBond * > >::iterator *|OpenBabel::OBBondIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t = {"_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t", "std::vector< OpenBabel::OBBond,std::allocator< OpenBabel::OBBond > > *|std::vector< OpenBabel::OBBond > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type", "std::vector< OpenBabel::OBBond >::allocator_type *|std::allocator< OpenBabel::OBBond > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type = {"_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type", "std::vector< OpenBabel::OBBond >::value_type *|OpenBabel::OBBond *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t = {"_p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t", "std::vector< OpenBabel::OBExternalBond,std::allocator< OpenBabel::OBExternalBond > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t = {"_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t", "std::vector< OpenBabel::OBGenericData * > *|std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type", "std::vector< OpenBabel::OBGenericData * >::allocator_type *|std::allocator< OpenBabel::OBGenericData * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator = {"_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator", "OpenBabel::OBDataIterator *|std::vector< OpenBabel::OBGenericData *,std::allocator< OpenBabel::OBGenericData * > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type = {"_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type", "std::vector< OpenBabel::OBGenericData * >::value_type *|OpenBabel::OBGenericData **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVibrationData = {"_p_p_OpenBabel__OBVibrationData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBTorsionData = {"_p_p_OpenBabel__OBTorsionData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBRotationData = {"_p_p_OpenBabel__OBRotationData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBPairData = {"_p_p_OpenBabel__OBPairData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBAngleData = {"_p_p_OpenBabel__OBAngleData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBChiralData = {"_p_p_OpenBabel__OBChiralData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBRingData = {"_p_p_OpenBabel__OBRingData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSerialNums = {"_p_p_OpenBabel__OBSerialNums", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBMatrixData = {"_p_p_OpenBabel__OBMatrixData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBExternalBondData = {"_p_p_OpenBabel__OBExternalBondData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSetData = {"_p_p_OpenBabel__OBSetData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBSymmetryData = {"_p_p_OpenBabel__OBSymmetryData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBCommentData = {"_p_p_OpenBabel__OBCommentData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVectorData = {"_p_p_OpenBabel__OBVectorData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBVirtualBond = {"_p_p_OpenBabel__OBVirtualBond", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBConformerData = {"_p_p_OpenBabel__OBConformerData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBGridData = {"_p_p_OpenBabel__OBGridData", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_p_OpenBabel__OBUnitCell = {"_p_p_OpenBabel__OBUnitCell", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t = {"_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator = {"_p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator", "std::vector< OpenBabel::OBInternalCoord *,std::allocator< OpenBabel::OBInternalCoord * > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t = {"_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t", "std::vector< OpenBabel::OBMol,std::allocator< OpenBabel::OBMol > > *|std::vector< OpenBabel::OBMol > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type", "std::vector< OpenBabel::OBMol >::allocator_type *|std::allocator< OpenBabel::OBMol > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type = {"_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type", "std::vector< OpenBabel::OBMol >::value_type *|OpenBabel::OBMol *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator = {"_p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator", "OpenBabel::OBResidueIterator *|std::vector< OpenBabel::OBResidue *,std::allocator< OpenBabel::OBResidue * > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t = {"_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t", "std::vector< OpenBabel::OBResidue > *|std::vector< OpenBabel::OBResidue,std::allocator< OpenBabel::OBResidue > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type", "std::allocator< OpenBabel::OBResidue > *|std::vector< OpenBabel::OBResidue >::allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type = {"_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type", "std::vector< OpenBabel::OBResidue >::value_type *|OpenBabel::OBResidue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t = {"_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > > *|std::vector< OpenBabel::OBRing * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type", "std::vector< OpenBabel::OBRing * >::allocator_type *|std::allocator< OpenBabel::OBRing * > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator = {"_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator", "std::vector< OpenBabel::OBRing *,std::allocator< OpenBabel::OBRing * > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type = {"_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type", "std::vector< OpenBabel::OBRing * >::value_type *|OpenBabel::OBRing **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t = {"_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t", "std::vector< OpenBabel::OBRing,std::allocator< OpenBabel::OBRing > > *|std::vector< OpenBabel::OBRing > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type", "std::vector< OpenBabel::OBRing >::allocator_type *|std::allocator< OpenBabel::OBRing > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type = {"_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type", "std::vector< OpenBabel::OBRing >::value_type *|OpenBabel::OBRing *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t = {"_p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t", "std::vector< OpenBabel::OBTorsion,std::allocator< OpenBabel::OBTorsion > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t = {"_p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t", "std::vector< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double >,std::allocator< OpenBabel::triple< OpenBabel::OBAtom *,OpenBabel::OBAtom *,double > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t = {"_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t", "std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > *|std::vector< OpenBabel::vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type = {"_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type", "std::vector< OpenBabel::vector3 >::allocator_type *|std::allocator< OpenBabel::vector3 > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type = {"_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type", "std::vector< OpenBabel::vector3 >::value_type *|OpenBabel::vector3 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_p_std__allocatorT_double_p_t_t = {"_p_std__vectorT_double_p_std__allocatorT_double_p_t_t", "std::vector< double *,std::allocator< double * > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator = {"_p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator", "std::vector< double *,std::allocator< double * > >::iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t = {"_p_std__vectorT_double_std__allocatorT_double_t_t", "std::vector< double,std::allocator< double > > *|std::vector< double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type = {"_p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type", "std::vector< double >::allocator_type *|std::allocator< double > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_int_std__allocatorT_int_t_t = {"_p_std__vectorT_int_std__allocatorT_int_t_t", "std::vector< int,std::allocator< int > > *|std::vector< int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type = {"_p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type", "std::vector< int >::allocator_type *|std::allocator< int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t = {"_p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t", "std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t = {"_p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t", "std::vector< std::pair< std::string,std::string >,std::allocator< std::pair< std::string,std::string > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t = {"_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", "std::vector< std::string,std::allocator< std::string > > *|std::vector< std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type = {"_p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type", "std::vector< std::string >::allocator_type *|std::allocator< std::string > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t = {"_p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t", "std::vector< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > >,std::allocator< std::vector< OpenBabel::vector3,std::allocator< OpenBabel::vector3 > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t = {"_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t", "std::vector< std::vector< int > > *|std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *|std::vector< std::vector< int,std::allocator< int > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type = {"_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type", "std::vector< std::vector< int > >::allocator_type *|std::allocator< std::vector< int,std::allocator< int > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t = {"_p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t", "std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t = {"_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t", "std::vector< unsigned int,std::allocator< unsigned int > > *|std::vector< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type = {"_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type", "std::vector< unsigned int >::allocator_type *|std::allocator< unsigned int > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t = {"_p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t", "std::vector< unsigned short,std::allocator< unsigned short > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__ConstIterator = {"_p_swig__ConstIterator", "swig::ConstIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__GC_VALUE = {"_p_swig__GC_VALUE", "swig::GC_VALUE *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__Iterator = {"_p_swig__Iterator", "swig::Iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "unsigned int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type = {"_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type", "OpenBabel::OBGenericData *|std::vector< OpenBabel::OBGenericData * >::value_type", 0, 0, (void*)0, 0};
static swig_type_info _swigt__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type = {"_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type", "std::vector< OpenBabel::OBRing * >::value_type|OpenBabel::OBRing *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_OpMap,
  &_swigt__p_OpenBabel__CharPtrLess,
  &_swigt__p_OpenBabel__DoubleType,
  &_swigt__p_OpenBabel__FastSearch,
  &_swigt__p_OpenBabel__FastSearchIndexer,
  &_swigt__p_OpenBabel__FptIndex,
  &_swigt__p_OpenBabel__FptIndexHeader,
  &_swigt__p_OpenBabel__LineSearchType,
  &_swigt__p_OpenBabel__OBAngle,
  &_swigt__p_OpenBabel__OBAngleData,
  &_swigt__p_OpenBabel__OBAromaticTyper,
  &_swigt__p_OpenBabel__OBAtom,
  &_swigt__p_OpenBabel__OBAtomAtomIter,
  &_swigt__p_OpenBabel__OBAtomBondIter,
  &_swigt__p_OpenBabel__OBAtomTyper,
  &_swigt__p_OpenBabel__OBBase,
  &_swigt__p_OpenBabel__OBBitVec,
  &_swigt__p_OpenBabel__OBBond,
  &_swigt__p_OpenBabel__OBChainsParser,
  &_swigt__p_OpenBabel__OBChiralData,
  &_swigt__p_OpenBabel__OBCommentData,
  &_swigt__p_OpenBabel__OBConformerData,
  &_swigt__p_OpenBabel__OBConversion,
  &_swigt__p_OpenBabel__OBDescriptor,
  &_swigt__p_OpenBabel__OBElement,
  &_swigt__p_OpenBabel__OBElementTable,
  &_swigt__p_OpenBabel__OBError,
  &_swigt__p_OpenBabel__OBExternalBond,
  &_swigt__p_OpenBabel__OBExternalBondData,
  &_swigt__p_OpenBabel__OBFFCalculation2,
  &_swigt__p_OpenBabel__OBFFCalculation3,
  &_swigt__p_OpenBabel__OBFFCalculation4,
  &_swigt__p_OpenBabel__OBFFConstraint,
  &_swigt__p_OpenBabel__OBFFConstraints,
  &_swigt__p_OpenBabel__OBFFParameter,
  &_swigt__p_OpenBabel__OBFingerprint,
  &_swigt__p_OpenBabel__OBForceField,
  &_swigt__p_OpenBabel__OBFormat,
  &_swigt__p_OpenBabel__OBGenericData,
  &_swigt__p_OpenBabel__OBGlobalDataBase,
  &_swigt__p_OpenBabel__OBGridData,
  &_swigt__p_OpenBabel__OBInternalCoord,
  &_swigt__p_OpenBabel__OBIsotopeTable,
  &_swigt__p_OpenBabel__OBMatrixData,
  &_swigt__p_OpenBabel__OBMessageHandler,
  &_swigt__p_OpenBabel__OBMol,
  &_swigt__p_OpenBabel__OBMolAngleIter,
  &_swigt__p_OpenBabel__OBMolAtomDFSIter,
  &_swigt__p_OpenBabel__OBMolAtomIter,
  &_swigt__p_OpenBabel__OBMolBondIter,
  &_swigt__p_OpenBabel__OBMolPairIter,
  &_swigt__p_OpenBabel__OBMolRingIter,
  &_swigt__p_OpenBabel__OBMolTorsionIter,
  &_swigt__p_OpenBabel__OBOp,
  &_swigt__p_OpenBabel__OBPairData,
  &_swigt__p_OpenBabel__OBPairTemplateT_double_t,
  &_swigt__p_OpenBabel__OBPairTemplateT_int_t,
  &_swigt__p_OpenBabel__OBPlugin,
  &_swigt__p_OpenBabel__OBPlugin__PluginMapType__const_iterator,
  &_swigt__p_OpenBabel__OBRTree,
  &_swigt__p_OpenBabel__OBRandom,
  &_swigt__p_OpenBabel__OBResidue,
  &_swigt__p_OpenBabel__OBResidueAtomIter,
  &_swigt__p_OpenBabel__OBResidueData,
  &_swigt__p_OpenBabel__OBResidueIter,
  &_swigt__p_OpenBabel__OBRing,
  &_swigt__p_OpenBabel__OBRingData,
  &_swigt__p_OpenBabel__OBRingSearch,
  &_swigt__p_OpenBabel__OBRingTyper,
  &_swigt__p_OpenBabel__OBRotationData,
  &_swigt__p_OpenBabel__OBSSMatch,
  &_swigt__p_OpenBabel__OBSerialNums,
  &_swigt__p_OpenBabel__OBSetData,
  &_swigt__p_OpenBabel__OBSmartsPattern,
  &_swigt__p_OpenBabel__OBSqrtTbl,
  &_swigt__p_OpenBabel__OBStopwatch,
  &_swigt__p_OpenBabel__OBSymmetryData,
  &_swigt__p_OpenBabel__OBTorsion,
  &_swigt__p_OpenBabel__OBTorsionData,
  &_swigt__p_OpenBabel__OBTypeTable,
  &_swigt__p_OpenBabel__OBUnitCell,
  &_swigt__p_OpenBabel__OBVectorData,
  &_swigt__p_OpenBabel__OBVibrationData,
  &_swigt__p_OpenBabel__OBVirtualBond,
  &_swigt__p_OpenBabel__Pattern,
  &_swigt__p_OpenBabel__SpaceGroup,
  &_swigt__p_OpenBabel__Template,
  &_swigt__p_OpenBabel__matrix3x3,
  &_swigt__p_OpenBabel__obLogBuf,
  &_swigt__p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_OpenBabel__vector3,
  &_swigt__p_PluginIterator,
  &_swigt__p_PluginMapType,
  &_swigt__p_Unit,
  &_swigt__p_a_3__double,
  &_swigt__p_a_4__char,
  &_swigt__p_allocator_type,
  &_swigt__p_char,
  &_swigt__p_const_reference,
  &_swigt__p_difference_type,
  &_swigt__p_double,
  &_swigt__p_int,
  &_swigt__p_p_OpenBabel__OBAngleData,
  &_swigt__p_p_OpenBabel__OBChiralData,
  &_swigt__p_p_OpenBabel__OBCommentData,
  &_swigt__p_p_OpenBabel__OBConformerData,
  &_swigt__p_p_OpenBabel__OBDescriptor,
  &_swigt__p_p_OpenBabel__OBExternalBondData,
  &_swigt__p_p_OpenBabel__OBFingerprint,
  &_swigt__p_p_OpenBabel__OBForceField,
  &_swigt__p_p_OpenBabel__OBFormat,
  &_swigt__p_p_OpenBabel__OBGridData,
  &_swigt__p_p_OpenBabel__OBMatrixData,
  &_swigt__p_p_OpenBabel__OBOp,
  &_swigt__p_p_OpenBabel__OBPairData,
  &_swigt__p_p_OpenBabel__OBRingData,
  &_swigt__p_p_OpenBabel__OBRotationData,
  &_swigt__p_p_OpenBabel__OBSerialNums,
  &_swigt__p_p_OpenBabel__OBSetData,
  &_swigt__p_p_OpenBabel__OBSymmetryData,
  &_swigt__p_p_OpenBabel__OBTorsionData,
  &_swigt__p_p_OpenBabel__OBUnitCell,
  &_swigt__p_p_OpenBabel__OBVectorData,
  &_swigt__p_p_OpenBabel__OBVibrationData,
  &_swigt__p_p_OpenBabel__OBVirtualBond,
  &_swigt__p_p_double,
  &_swigt__p_p_int,
  &_swigt__p_p_void,
  &_swigt__p_reference,
  &_swigt__p_size_type,
  &_swigt__p_std__dequeT_int_t,
  &_swigt__p_std__istream,
  &_swigt__p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t,
  &_swigt__p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t,
  &_swigt__p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t,
  &_swigt__p_std__multimapT_double_unsigned_int_t,
  &_swigt__p_std__ostream,
  &_swigt__p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  &_swigt__p_std__streampos,
  &_swigt__p_std__string,
  &_swigt__p_std__type_info,
  &_swigt__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,
  &_swigt__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,
  &_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,
  &_swigt__p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator,
  &_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type,
  &_swigt__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator,
  &_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,
  &_swigt__p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator,
  &_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,
  &_swigt__p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t,
  &_swigt__p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t,
  &_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t,
  &_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type,
  &_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,
  &_swigt__p_std__vectorT_double_p_std__allocatorT_double_p_t_t,
  &_swigt__p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator,
  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t,
  &_swigt__p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type,
  &_swigt__p_std__vectorT_int_std__allocatorT_int_t_t,
  &_swigt__p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type,
  &_swigt__p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t,
  &_swigt__p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t,
  &_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t,
  &_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type,
  &_swigt__p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type,
  &_swigt__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,
  &_swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,
  &_swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type,
  &_swigt__p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t,
  &_swigt__p_swig__ConstIterator,
  &_swigt__p_swig__GC_VALUE,
  &_swigt__p_swig__Iterator,
  &_swigt__p_unsigned_int,
  &_swigt__p_value_type,
  &_swigt__std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type,
  &_swigt__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type,
};

static swig_cast_info _swigc__p_OpMap[] = {  {&_swigt__p_OpMap, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__CharPtrLess[] = {  {&_swigt__p_OpenBabel__CharPtrLess, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__DoubleType[] = {  {&_swigt__p_OpenBabel__DoubleType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FastSearch[] = {  {&_swigt__p_OpenBabel__FastSearch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FastSearchIndexer[] = {  {&_swigt__p_OpenBabel__FastSearchIndexer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FptIndex[] = {  {&_swigt__p_OpenBabel__FptIndex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__FptIndexHeader[] = {  {&_swigt__p_OpenBabel__FptIndexHeader, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__LineSearchType[] = {  {&_swigt__p_OpenBabel__LineSearchType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAngle[] = {  {&_swigt__p_OpenBabel__OBAngle, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAngleData[] = {  {&_swigt__p_OpenBabel__OBAngleData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAromaticTyper[] = {  {&_swigt__p_OpenBabel__OBAromaticTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtom[] = {  {&_swigt__p_OpenBabel__OBAtom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomAtomIter[] = {  {&_swigt__p_OpenBabel__OBAtomAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomBondIter[] = {  {&_swigt__p_OpenBabel__OBAtomBondIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBAtomTyper[] = {  {&_swigt__p_OpenBabel__OBAtomTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBase[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, _p_OpenBabel__OBMolTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, _p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBMol, _p_OpenBabel__OBMolTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBResidue, _p_OpenBabel__OBResidueTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBBase, 0, 0, 0},  {&_swigt__p_OpenBabel__OBBond, _p_OpenBabel__OBBondTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, _p_OpenBabel__OBBondTo_p_OpenBabel__OBBase, 0, 0},  {&_swigt__p_OpenBabel__OBAtom, _p_OpenBabel__OBAtomTo_p_OpenBabel__OBBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBitVec[] = {  {&_swigt__p_OpenBabel__OBBitVec, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBBond[] = {  {&_swigt__p_OpenBabel__OBBond, 0, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBChainsParser[] = {  {&_swigt__p_OpenBabel__OBChainsParser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBChiralData[] = {  {&_swigt__p_OpenBabel__OBChiralData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBCommentData[] = {  {&_swigt__p_OpenBabel__OBCommentData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBConformerData[] = {  {&_swigt__p_OpenBabel__OBConformerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBConversion[] = {  {&_swigt__p_OpenBabel__OBConversion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBDescriptor[] = {  {&_swigt__p_OpenBabel__OBDescriptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBElement[] = {  {&_swigt__p_OpenBabel__OBElement, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBElementTable[] = {  {&_swigt__p_OpenBabel__OBElementTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBError[] = {  {&_swigt__p_OpenBabel__OBError, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBExternalBond[] = {  {&_swigt__p_OpenBabel__OBExternalBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBExternalBondData[] = {  {&_swigt__p_OpenBabel__OBExternalBondData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFCalculation2[] = {  {&_swigt__p_OpenBabel__OBFFCalculation2, 0, 0, 0},  {&_swigt__p_OpenBabel__OBFFCalculation3, _p_OpenBabel__OBFFCalculation3To_p_OpenBabel__OBFFCalculation2, 0, 0},  {&_swigt__p_OpenBabel__OBFFCalculation4, _p_OpenBabel__OBFFCalculation4To_p_OpenBabel__OBFFCalculation2, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFCalculation3[] = {  {&_swigt__p_OpenBabel__OBFFCalculation3, 0, 0, 0},  {&_swigt__p_OpenBabel__OBFFCalculation4, _p_OpenBabel__OBFFCalculation4To_p_OpenBabel__OBFFCalculation3, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFCalculation4[] = {  {&_swigt__p_OpenBabel__OBFFCalculation4, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFConstraint[] = {  {&_swigt__p_OpenBabel__OBFFConstraint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFConstraints[] = {  {&_swigt__p_OpenBabel__OBFFConstraints, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFFParameter[] = {  {&_swigt__p_OpenBabel__OBFFParameter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFingerprint[] = {  {&_swigt__p_OpenBabel__OBFingerprint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBForceField[] = {  {&_swigt__p_OpenBabel__OBForceField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBFormat[] = {  {&_swigt__p_OpenBabel__OBFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGenericData[] = {  {&_swigt__p_OpenBabel__OBVibrationData, _p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBTorsionData, _p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBRotationData, _p_OpenBabel__OBRotationDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBPairData, _p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBAngleData, _p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBChiralData, _p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBRingData, _p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSerialNums, _p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBMatrixData, _p_OpenBabel__OBMatrixDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBExternalBondData, _p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__OBSetData, _p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSymmetryData, _p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBCommentData, _p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBVectorData, _p_OpenBabel__OBVectorDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBVirtualBond, _p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBConformerData, _p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBGridData, _p_OpenBabel__OBGridDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBGenericData, 0, 0, 0},  {&_swigt__p_OpenBabel__OBUnitCell, _p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingTyper[] = {{&_swigt__p_OpenBabel__OBRingTyper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGlobalDataBase[] = {  {&_swigt__p_OpenBabel__OBAtomTyper, _p_OpenBabel__OBAtomTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBAromaticTyper, _p_OpenBabel__OBAromaticTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBGlobalDataBase, 0, 0, 0},  {&_swigt__p_OpenBabel__OBResidueData, _p_OpenBabel__OBResidueDataTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBRingTyper, _p_OpenBabel__OBRingTyperTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBIsotopeTable, _p_OpenBabel__OBIsotopeTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBTypeTable, _p_OpenBabel__OBTypeTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},  {&_swigt__p_OpenBabel__OBElementTable, _p_OpenBabel__OBElementTableTo_p_OpenBabel__OBGlobalDataBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBGridData[] = {  {&_swigt__p_OpenBabel__OBGridData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBInternalCoord[] = {  {&_swigt__p_OpenBabel__OBInternalCoord, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBIsotopeTable[] = {  {&_swigt__p_OpenBabel__OBIsotopeTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMatrixData[] = {  {&_swigt__p_OpenBabel__OBMatrixData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMessageHandler[] = {  {&_swigt__p_OpenBabel__OBMessageHandler, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMol[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__OBMol, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAngleIter[] = {  {&_swigt__p_OpenBabel__OBMolAngleIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomDFSIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomDFSIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolAtomIter[] = {  {&_swigt__p_OpenBabel__OBMolAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolBondIter[] = {  {&_swigt__p_OpenBabel__OBMolBondIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolPairIter[] = {  {&_swigt__p_OpenBabel__OBMolPairIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolRingIter[] = {  {&_swigt__p_OpenBabel__OBMolRingIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBMolTorsionIter[] = {  {&_swigt__p_OpenBabel__OBMolTorsionIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBOp[] = {  {&_swigt__p_OpenBabel__OBOp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairData[] = {  {&_swigt__p_OpenBabel__OBPairData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairTemplateT_double_t[] = {  {&_swigt__p_OpenBabel__OBPairTemplateT_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPairTemplateT_int_t[] = {  {&_swigt__p_OpenBabel__OBPairTemplateT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPlugin[] = {  {&_swigt__p_OpenBabel__OBDescriptor, _p_OpenBabel__OBDescriptorTo_p_OpenBabel__OBPlugin, 0, 0},  {&_swigt__p_OpenBabel__OBPlugin, 0, 0, 0},  {&_swigt__p_OpenBabel__OBForceField, _p_OpenBabel__OBForceFieldTo_p_OpenBabel__OBPlugin, 0, 0},  {&_swigt__p_OpenBabel__OBOp, _p_OpenBabel__OBOpTo_p_OpenBabel__OBPlugin, 0, 0},  {&_swigt__p_OpenBabel__OBFormat, _p_OpenBabel__OBFormatTo_p_OpenBabel__OBPlugin, 0, 0},  {&_swigt__p_OpenBabel__OBFingerprint, _p_OpenBabel__OBFingerprintTo_p_OpenBabel__OBPlugin, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBPlugin__PluginMapType__const_iterator[] = {  {&_swigt__p_OpenBabel__OBPlugin__PluginMapType__const_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRTree[] = {  {&_swigt__p_OpenBabel__OBRTree, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRandom[] = {  {&_swigt__p_OpenBabel__OBRandom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidue[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__OBResidue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueAtomIter[] = {  {&_swigt__p_OpenBabel__OBResidueAtomIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueData[] = {  {&_swigt__p_OpenBabel__OBResidueData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBResidueIter[] = {  {&_swigt__p_OpenBabel__OBResidueIter, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRing[] = {  {&_swigt__p_OpenBabel__OBRing, 0, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, 0, 0, 0},  {&_swigt__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingData[] = {  {&_swigt__p_OpenBabel__OBRingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRingSearch[] = {  {&_swigt__p_OpenBabel__OBRingSearch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBRotationData[] = {  {&_swigt__p_OpenBabel__OBRotationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSSMatch[] = {  {&_swigt__p_OpenBabel__OBSSMatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSerialNums[] = {  {&_swigt__p_OpenBabel__OBSerialNums, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSetData[] = {  {&_swigt__p_OpenBabel__OBSetData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSmartsPattern[] = {  {&_swigt__p_OpenBabel__OBSmartsPattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSqrtTbl[] = {  {&_swigt__p_OpenBabel__OBSqrtTbl, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBStopwatch[] = {  {&_swigt__p_OpenBabel__OBStopwatch, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBSymmetryData[] = {  {&_swigt__p_OpenBabel__OBSymmetryData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTorsion[] = {  {&_swigt__p_OpenBabel__OBTorsion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTorsionData[] = {  {&_swigt__p_OpenBabel__OBTorsionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBTypeTable[] = {  {&_swigt__p_OpenBabel__OBTypeTable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBUnitCell[] = {  {&_swigt__p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVectorData[] = {  {&_swigt__p_OpenBabel__OBVectorData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVibrationData[] = {  {&_swigt__p_OpenBabel__OBVibrationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__OBVirtualBond[] = {  {&_swigt__p_OpenBabel__OBVirtualBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__Pattern[] = {  {&_swigt__p_OpenBabel__Pattern, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__SpaceGroup[] = {  {&_swigt__p_OpenBabel__SpaceGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__Template[] = {  {&_swigt__p_OpenBabel__Template, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__matrix3x3[] = {  {&_swigt__p_OpenBabel__matrix3x3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__obLogBuf[] = {  {&_swigt__p_OpenBabel__obLogBuf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OpenBabel__vector3[] = {  {&_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PluginIterator[] = {  {&_swigt__p_PluginIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PluginMapType[] = {  {&_swigt__p_PluginMapType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Unit[] = {  {&_swigt__p_Unit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_3__double[] = {  {&_swigt__p_a_3__double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_a_4__char[] = {  {&_swigt__p_a_4__char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_reference[] = {  {&_swigt__p_const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBDescriptor[] = {  {&_swigt__p_p_OpenBabel__OBDescriptor, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBFingerprint[] = {  {&_swigt__p_p_OpenBabel__OBFingerprint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBForceField[] = {  {&_swigt__p_p_OpenBabel__OBForceField, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBFormat[] = {  {&_swigt__p_p_OpenBabel__OBFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBOp[] = {  {&_swigt__p_p_OpenBabel__OBOp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_int[] = {  {&_swigt__p_p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_void[] = {  {&_swigt__p_p_void, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_reference[] = {  {&_swigt__p_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__dequeT_int_t[] = {  {&_swigt__p_std__dequeT_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t[] = {  {&_swigt__p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t[] = {  {&_swigt__p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__multimapT_double_unsigned_int_t[] = {  {&_swigt__p_std__multimapT_double_unsigned_int_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t[] = {  {&_swigt__p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__streampos[] = {  {&_swigt__p_std__streampos, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__type_info[] = {  {&_swigt__p_std__type_info, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type[] = {  {&_swigt__p_OpenBabel__OBBond, 0, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVibrationData[] = {{&_swigt__p_p_OpenBabel__OBVibrationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBTorsionData[] = {{&_swigt__p_p_OpenBabel__OBTorsionData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBRotationData[] = {{&_swigt__p_p_OpenBabel__OBRotationData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBPairData[] = {{&_swigt__p_p_OpenBabel__OBPairData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBAngleData[] = {{&_swigt__p_p_OpenBabel__OBAngleData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBChiralData[] = {{&_swigt__p_p_OpenBabel__OBChiralData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBRingData[] = {{&_swigt__p_p_OpenBabel__OBRingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSerialNums[] = {{&_swigt__p_p_OpenBabel__OBSerialNums, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBMatrixData[] = {{&_swigt__p_p_OpenBabel__OBMatrixData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBExternalBondData[] = {{&_swigt__p_p_OpenBabel__OBExternalBondData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSetData[] = {{&_swigt__p_p_OpenBabel__OBSetData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBSymmetryData[] = {{&_swigt__p_p_OpenBabel__OBSymmetryData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBCommentData[] = {{&_swigt__p_p_OpenBabel__OBCommentData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVectorData[] = {{&_swigt__p_p_OpenBabel__OBVectorData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBVirtualBond[] = {{&_swigt__p_p_OpenBabel__OBVirtualBond, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBConformerData[] = {{&_swigt__p_p_OpenBabel__OBConformerData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBGridData[] = {{&_swigt__p_p_OpenBabel__OBGridData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_OpenBabel__OBUnitCell[] = {{&_swigt__p_p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBVibrationData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBTorsionData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBRotationData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBPairData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBAngleData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBChiralData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBRingData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBSerialNums, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBMatrixData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBExternalBondData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBSetData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBSymmetryData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBCommentData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBVectorData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBVirtualBond, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBConformerData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBGridData, 0, 0, 0},  {&_swigt__p_p_OpenBabel__OBUnitCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__OBMol, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__OBResidue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type[] = {  {&_swigt__p_OpenBabel__OBRing, 0, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, 0, 0, 0},  {&_swigt__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t[] = {  {&_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type[] = {  {&_swigt__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__vector3, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_p_std__allocatorT_double_p_t_t[] = {  {&_swigt__p_std__vectorT_double_p_std__allocatorT_double_p_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator[] = {  {&_swigt__p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_int_std__allocatorT_int_t_t[] = {  {&_swigt__p_std__vectorT_int_std__allocatorT_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t[] = {  {&_swigt__p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t[] = {  {&_swigt__p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t[] = {  {&_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t[] = {  {&_swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type[] = {  {&_swigt__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t[] = {  {&_swigt__p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__ConstIterator[] = {  {&_swigt__p_swig__ConstIterator, 0, 0, 0},  {&_swigt__p_swig__Iterator, _p_swig__IteratorTo_p_swig__ConstIterator, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__GC_VALUE[] = {  {&_swigt__p_swig__GC_VALUE, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__Iterator[] = {  {&_swigt__p_swig__Iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type[] = {  {&_swigt__p_OpenBabel__OBVibrationData, _p_OpenBabel__OBVibrationDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBTorsionData, _p_OpenBabel__OBTorsionDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBRotationData, _p_OpenBabel__OBRotationDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBPairData, _p_OpenBabel__OBPairDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBAngleData, _p_OpenBabel__OBAngleDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBChiralData, _p_OpenBabel__OBChiralDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBRingData, _p_OpenBabel__OBRingDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSerialNums, _p_OpenBabel__OBSerialNumsTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBMatrixData, _p_OpenBabel__OBMatrixDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBExternalBondData, _p_OpenBabel__OBExternalBondDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type, 0, 0, 0},  {&_swigt__p_OpenBabel__OBSetData, _p_OpenBabel__OBSetDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBSymmetryData, _p_OpenBabel__OBSymmetryDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBCommentData, _p_OpenBabel__OBCommentDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBVectorData, _p_OpenBabel__OBVectorDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBVirtualBond, _p_OpenBabel__OBVirtualBondTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBConformerData, _p_OpenBabel__OBConformerDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBGridData, _p_OpenBabel__OBGridDataTo_p_OpenBabel__OBGenericData, 0, 0},  {&_swigt__p_OpenBabel__OBGenericData, 0, 0, 0},  {&_swigt__p_OpenBabel__OBUnitCell, _p_OpenBabel__OBUnitCellTo_p_OpenBabel__OBGenericData, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type[] = {  {&_swigt__p_OpenBabel__OBRing, 0, 0, 0},  {&_swigt__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type, 0, 0, 0},  {&_swigt__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_OpMap,
  _swigc__p_OpenBabel__CharPtrLess,
  _swigc__p_OpenBabel__DoubleType,
  _swigc__p_OpenBabel__FastSearch,
  _swigc__p_OpenBabel__FastSearchIndexer,
  _swigc__p_OpenBabel__FptIndex,
  _swigc__p_OpenBabel__FptIndexHeader,
  _swigc__p_OpenBabel__LineSearchType,
  _swigc__p_OpenBabel__OBAngle,
  _swigc__p_OpenBabel__OBAngleData,
  _swigc__p_OpenBabel__OBAromaticTyper,
  _swigc__p_OpenBabel__OBAtom,
  _swigc__p_OpenBabel__OBAtomAtomIter,
  _swigc__p_OpenBabel__OBAtomBondIter,
  _swigc__p_OpenBabel__OBAtomTyper,
  _swigc__p_OpenBabel__OBBase,
  _swigc__p_OpenBabel__OBBitVec,
  _swigc__p_OpenBabel__OBBond,
  _swigc__p_OpenBabel__OBChainsParser,
  _swigc__p_OpenBabel__OBChiralData,
  _swigc__p_OpenBabel__OBCommentData,
  _swigc__p_OpenBabel__OBConformerData,
  _swigc__p_OpenBabel__OBConversion,
  _swigc__p_OpenBabel__OBDescriptor,
  _swigc__p_OpenBabel__OBElement,
  _swigc__p_OpenBabel__OBElementTable,
  _swigc__p_OpenBabel__OBError,
  _swigc__p_OpenBabel__OBExternalBond,
  _swigc__p_OpenBabel__OBExternalBondData,
  _swigc__p_OpenBabel__OBFFCalculation2,
  _swigc__p_OpenBabel__OBFFCalculation3,
  _swigc__p_OpenBabel__OBFFCalculation4,
  _swigc__p_OpenBabel__OBFFConstraint,
  _swigc__p_OpenBabel__OBFFConstraints,
  _swigc__p_OpenBabel__OBFFParameter,
  _swigc__p_OpenBabel__OBFingerprint,
  _swigc__p_OpenBabel__OBForceField,
  _swigc__p_OpenBabel__OBFormat,
  _swigc__p_OpenBabel__OBGenericData,
  _swigc__p_OpenBabel__OBGlobalDataBase,
  _swigc__p_OpenBabel__OBGridData,
  _swigc__p_OpenBabel__OBInternalCoord,
  _swigc__p_OpenBabel__OBIsotopeTable,
  _swigc__p_OpenBabel__OBMatrixData,
  _swigc__p_OpenBabel__OBMessageHandler,
  _swigc__p_OpenBabel__OBMol,
  _swigc__p_OpenBabel__OBMolAngleIter,
  _swigc__p_OpenBabel__OBMolAtomDFSIter,
  _swigc__p_OpenBabel__OBMolAtomIter,
  _swigc__p_OpenBabel__OBMolBondIter,
  _swigc__p_OpenBabel__OBMolPairIter,
  _swigc__p_OpenBabel__OBMolRingIter,
  _swigc__p_OpenBabel__OBMolTorsionIter,
  _swigc__p_OpenBabel__OBOp,
  _swigc__p_OpenBabel__OBPairData,
  _swigc__p_OpenBabel__OBPairTemplateT_double_t,
  _swigc__p_OpenBabel__OBPairTemplateT_int_t,
  _swigc__p_OpenBabel__OBPlugin,
  _swigc__p_OpenBabel__OBPlugin__PluginMapType__const_iterator,
  _swigc__p_OpenBabel__OBRTree,
  _swigc__p_OpenBabel__OBRandom,
  _swigc__p_OpenBabel__OBResidue,
  _swigc__p_OpenBabel__OBResidueAtomIter,
  _swigc__p_OpenBabel__OBResidueData,
  _swigc__p_OpenBabel__OBResidueIter,
  _swigc__p_OpenBabel__OBRing,
  _swigc__p_OpenBabel__OBRingData,
  _swigc__p_OpenBabel__OBRingSearch,
  _swigc__p_OpenBabel__OBRingTyper,
  _swigc__p_OpenBabel__OBRotationData,
  _swigc__p_OpenBabel__OBSSMatch,
  _swigc__p_OpenBabel__OBSerialNums,
  _swigc__p_OpenBabel__OBSetData,
  _swigc__p_OpenBabel__OBSmartsPattern,
  _swigc__p_OpenBabel__OBSqrtTbl,
  _swigc__p_OpenBabel__OBStopwatch,
  _swigc__p_OpenBabel__OBSymmetryData,
  _swigc__p_OpenBabel__OBTorsion,
  _swigc__p_OpenBabel__OBTorsionData,
  _swigc__p_OpenBabel__OBTypeTable,
  _swigc__p_OpenBabel__OBUnitCell,
  _swigc__p_OpenBabel__OBVectorData,
  _swigc__p_OpenBabel__OBVibrationData,
  _swigc__p_OpenBabel__OBVirtualBond,
  _swigc__p_OpenBabel__Pattern,
  _swigc__p_OpenBabel__SpaceGroup,
  _swigc__p_OpenBabel__Template,
  _swigc__p_OpenBabel__matrix3x3,
  _swigc__p_OpenBabel__obLogBuf,
  _swigc__p_OpenBabel__quadT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_OpenBabel__vector3,
  _swigc__p_PluginIterator,
  _swigc__p_PluginMapType,
  _swigc__p_Unit,
  _swigc__p_a_3__double,
  _swigc__p_a_4__char,
  _swigc__p_allocator_type,
  _swigc__p_char,
  _swigc__p_const_reference,
  _swigc__p_difference_type,
  _swigc__p_double,
  _swigc__p_int,
  _swigc__p_p_OpenBabel__OBAngleData,
  _swigc__p_p_OpenBabel__OBChiralData,
  _swigc__p_p_OpenBabel__OBCommentData,
  _swigc__p_p_OpenBabel__OBConformerData,
  _swigc__p_p_OpenBabel__OBDescriptor,
  _swigc__p_p_OpenBabel__OBExternalBondData,
  _swigc__p_p_OpenBabel__OBFingerprint,
  _swigc__p_p_OpenBabel__OBForceField,
  _swigc__p_p_OpenBabel__OBFormat,
  _swigc__p_p_OpenBabel__OBGridData,
  _swigc__p_p_OpenBabel__OBMatrixData,
  _swigc__p_p_OpenBabel__OBOp,
  _swigc__p_p_OpenBabel__OBPairData,
  _swigc__p_p_OpenBabel__OBRingData,
  _swigc__p_p_OpenBabel__OBRotationData,
  _swigc__p_p_OpenBabel__OBSerialNums,
  _swigc__p_p_OpenBabel__OBSetData,
  _swigc__p_p_OpenBabel__OBSymmetryData,
  _swigc__p_p_OpenBabel__OBTorsionData,
  _swigc__p_p_OpenBabel__OBUnitCell,
  _swigc__p_p_OpenBabel__OBVectorData,
  _swigc__p_p_OpenBabel__OBVibrationData,
  _swigc__p_p_OpenBabel__OBVirtualBond,
  _swigc__p_p_double,
  _swigc__p_p_int,
  _swigc__p_p_void,
  _swigc__p_reference,
  _swigc__p_size_type,
  _swigc__p_std__dequeT_int_t,
  _swigc__p_std__istream,
  _swigc__p_std__mapT_char_const_p_OpenBabel__OBPlugin_p_OpenBabel__CharPtrLess_std__allocatorT_std__pairT_char_const_pconst_OpenBabel__OBPlugin_p_t_t_t,
  _swigc__p_std__mapT_int_OpenBabel__OBAtom_p_std__lessT_int_t_std__allocatorT_std__pairT_int_const_OpenBabel__OBAtom_p_t_t_t,
  _swigc__p_std__mapT_std__string_std__string_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_std__string_t_t_t,
  _swigc__p_std__multimapT_double_unsigned_int_t,
  _swigc__p_std__ostream,
  _swigc__p_std__pairT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_t,
  _swigc__p_std__streampos,
  _swigc__p_std__string,
  _swigc__p_std__type_info,
  _swigc__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBAtom_p_std__allocatorT_OpenBabel__OBAtom_p_t_t__iterator,
  _swigc__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBBond_p_std__allocatorT_OpenBabel__OBBond_p_t_t__iterator,
  _swigc__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t__value_type,
  _swigc__p_std__vectorT_OpenBabel__OBExternalBond_std__allocatorT_OpenBabel__OBExternalBond_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__iterator,
  _swigc__p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type,
  _swigc__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBInternalCoord_p_std__allocatorT_OpenBabel__OBInternalCoord_p_t_t__iterator,
  _swigc__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t__value_type,
  _swigc__p_std__vectorT_OpenBabel__OBResidue_p_std__allocatorT_OpenBabel__OBResidue_p_t_t__iterator,
  _swigc__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t__value_type,
  _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__iterator,
  _swigc__p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type,
  _swigc__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t,
  _swigc__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t__value_type,
  _swigc__p_std__vectorT_OpenBabel__OBTorsion_std__allocatorT_OpenBabel__OBTorsion_t_t,
  _swigc__p_std__vectorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_std__allocatorT_OpenBabel__tripleT_OpenBabel__OBAtom_p_OpenBabel__OBAtom_p_double_t_t_t,
  _swigc__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t,
  _swigc__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__allocator_type,
  _swigc__p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t__value_type,
  _swigc__p_std__vectorT_double_p_std__allocatorT_double_p_t_t,
  _swigc__p_std__vectorT_double_p_std__allocatorT_double_p_t_t__iterator,
  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t,
  _swigc__p_std__vectorT_double_std__allocatorT_double_t_t__allocator_type,
  _swigc__p_std__vectorT_int_std__allocatorT_int_t_t,
  _swigc__p_std__vectorT_int_std__allocatorT_int_t_t__allocator_type,
  _swigc__p_std__vectorT_std__pairT_int_int_t_std__allocatorT_std__pairT_int_int_t_t_t,
  _swigc__p_std__vectorT_std__pairT_std__string_std__string_t_std__allocatorT_std__pairT_std__string_std__string_t_t_t,
  _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t,
  _swigc__p_std__vectorT_std__string_std__allocatorT_std__string_t_t__allocator_type,
  _swigc__p_std__vectorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_std__allocatorT_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t__allocator_type,
  _swigc__p_std__vectorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_std__allocatorT_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t_t_t,
  _swigc__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t,
  _swigc__p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t__allocator_type,
  _swigc__p_std__vectorT_unsigned_short_std__allocatorT_unsigned_short_t_t,
  _swigc__p_swig__ConstIterator,
  _swigc__p_swig__GC_VALUE,
  _swigc__p_swig__Iterator,
  _swigc__p_unsigned_int,
  _swigc__p_value_type,
  _swigc__std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t__value_type,
  _swigc__std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t__value_type,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic 
 * memory is used. Also, since swig_type_info structures store pointers to 
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization. 
 * The idea is that swig generates all the structures that are needed. 
 * The runtime then collects these partially filled structures. 
 * The SWIG_InitializeModule function takes these initial arrays out of 
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned staticly to an initial 
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it 
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded. 
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the 
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int found, init;

  clientdata = clientdata;

  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }

  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
    module_head = &swig_module;
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    found=0;
    iter=module_head;
    do {
      if (iter==&swig_module) {
        found=1;
        break;
      }
      iter=iter->next;
    } while (iter!= module_head);

    /* if the is found in the list, then all is done and we may leave */
    if (found) return;
    /* otherwise we must add out module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }

  /* When multiple interpeters are used, a module could have already been initialized in
     a different interpreter, but not yet have a pointer in this interpreter.
     In this case, we do not want to continue adding types... everything should be
     set up already */
  if (init == 0) return;

  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
  
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif

    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
	type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }

    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
    
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
	if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
	if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
	  printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
	  cast->type = ret;
	  ret = 0;
	} else {
	  /* Check for casting already in the list */
	  swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
	  if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
	  if (!ocast) ret = 0;
	}
      }

      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
	printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;

#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
  printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;

  if (init_run) return;
  init_run = 1;

  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
            SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{ /* c-mode */
#endif
}
#endif

/*

*/
#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void Init_openbabel(void) {
  size_t i;
  
  SWIG_InitRuntime();
  mOpenBabel = rb_define_module("OpenBabel");
  
  SWIG_InitializeModule(0);
  for (i = 0; i < swig_module.size; i++) {
    SWIG_define_class(swig_module.types[i]);
  }
  
  SWIG_RubyInitializeTrackings();
  
  SwigClassGCVALUE.klass = rb_define_class_under(mOpenBabel, "GCVALUE", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__GC_VALUE, (void *) &SwigClassGCVALUE);
  rb_undef_alloc_func(SwigClassGCVALUE.klass);
  rb_define_method(SwigClassGCVALUE.klass, "inspect", VALUEFUNC(_wrap_GCVALUE_inspect), -1);
  rb_define_method(SwigClassGCVALUE.klass, "to_s", VALUEFUNC(_wrap_GCVALUE_to_s), -1);
  SwigClassGCVALUE.mark = 0;
  SwigClassGCVALUE.trackObjects = 0;
  
  swig::GC_VALUE::initialize();
  
  
  SwigClassConstIterator.klass = rb_define_class_under(mOpenBabel, "ConstIterator", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_swig__ConstIterator, (void *) &SwigClassConstIterator);
  rb_undef_alloc_func(SwigClassConstIterator.klass);
  rb_define_method(SwigClassConstIterator.klass, "value", VALUEFUNC(_wrap_ConstIterator_value), -1);
  rb_define_method(SwigClassConstIterator.klass, "dup", VALUEFUNC(_wrap_ConstIterator_dup), -1);
  rb_define_method(SwigClassConstIterator.klass, "inspect", VALUEFUNC(_wrap_ConstIterator_inspect), -1);
  rb_define_method(SwigClassConstIterator.klass, "to_s", VALUEFUNC(_wrap_ConstIterator_to_s), -1);
  rb_define_method(SwigClassConstIterator.klass, "next", VALUEFUNC(_wrap_ConstIterator_next), -1);
  rb_define_method(SwigClassConstIterator.klass, "previous", VALUEFUNC(_wrap_ConstIterator_previous), -1);
  rb_define_method(SwigClassConstIterator.klass, "==", VALUEFUNC(_wrap_ConstIterator___eq__), -1);
  rb_define_method(SwigClassConstIterator.klass, "+", VALUEFUNC(_wrap_ConstIterator___add__), -1);
  rb_define_method(SwigClassConstIterator.klass, "-", VALUEFUNC(_wrap_ConstIterator___sub__), -1);
  SwigClassConstIterator.mark = 0;
  SwigClassConstIterator.destroy = (void (*)(void *)) free_swig_ConstIterator;
  SwigClassConstIterator.trackObjects = 0;
  
  SwigClassIterator.klass = rb_define_class_under(mOpenBabel, "Iterator", ((swig_class *) SWIGTYPE_p_swig__ConstIterator->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_swig__Iterator, (void *) &SwigClassIterator);
  rb_undef_alloc_func(SwigClassIterator.klass);
  rb_define_method(SwigClassIterator.klass, "value=", VALUEFUNC(_wrap_Iterator_valuee___), -1);
  rb_define_method(SwigClassIterator.klass, "dup", VALUEFUNC(_wrap_Iterator_dup), -1);
  rb_define_method(SwigClassIterator.klass, "next", VALUEFUNC(_wrap_Iterator_next), -1);
  rb_define_method(SwigClassIterator.klass, "previous", VALUEFUNC(_wrap_Iterator_previous), -1);
  rb_define_method(SwigClassIterator.klass, "==", VALUEFUNC(_wrap_Iterator___eq__), -1);
  rb_define_method(SwigClassIterator.klass, "+", VALUEFUNC(_wrap_Iterator___add__), -1);
  rb_define_method(SwigClassIterator.klass, "-", VALUEFUNC(_wrap_Iterator___sub__), -1);
  SwigClassIterator.mark = 0;
  SwigClassIterator.destroy = (void (*)(void *)) free_swig_Iterator;
  SwigClassIterator.trackObjects = 0;
  
  SwigClassVectorInt.klass = rb_define_class_under(mOpenBabel, "VectorInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_int_std__allocatorT_int_t_t, (void *) &SwigClassVectorInt);
  rb_include_module(SwigClassVectorInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorInt.klass, _wrap_VectorInt_allocate);
  rb_define_method(SwigClassVectorInt.klass, "initialize", VALUEFUNC(_wrap_new_VectorInt), -1);
  rb_define_method(SwigClassVectorInt.klass, "dup", VALUEFUNC(_wrap_VectorInt_dup), -1);
  rb_define_method(SwigClassVectorInt.klass, "inspect", VALUEFUNC(_wrap_VectorInt_inspect), -1);
  rb_define_method(SwigClassVectorInt.klass, "to_a", VALUEFUNC(_wrap_VectorInt_to_a), -1);
  rb_define_method(SwigClassVectorInt.klass, "to_s", VALUEFUNC(_wrap_VectorInt_to_s), -1);
  rb_define_method(SwigClassVectorInt.klass, "slice", VALUEFUNC(_wrap_VectorInt_slice), -1);
  rb_define_method(SwigClassVectorInt.klass, "each", VALUEFUNC(_wrap_VectorInt_each), -1);
  rb_define_method(SwigClassVectorInt.klass, "select", VALUEFUNC(_wrap_VectorInt_select), -1);
  rb_define_method(SwigClassVectorInt.klass, "reject_bang", VALUEFUNC(_wrap_VectorInt_reject_bang), -1);
  rb_define_alias(SwigClassVectorInt.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorInt.klass, "delete_at", VALUEFUNC(_wrap_VectorInt_delete_at), -1);
  rb_define_method(SwigClassVectorInt.klass, "__delete_2__", VALUEFUNC(_wrap_VectorInt___delete_2__), -1);
  rb_define_method(SwigClassVectorInt.klass, "pop", VALUEFUNC(_wrap_VectorInt_pop), -1);
  rb_define_method(SwigClassVectorInt.klass, "push", VALUEFUNC(_wrap_VectorInt_push), -1);
  rb_define_alias(SwigClassVectorInt.klass, "<<", "push");
  rb_define_method(SwigClassVectorInt.klass, "reject", VALUEFUNC(_wrap_VectorInt_reject), -1);
  rb_define_method(SwigClassVectorInt.klass, "at", VALUEFUNC(_wrap_VectorInt_at), -1);
  rb_define_method(SwigClassVectorInt.klass, "[]", VALUEFUNC(_wrap_VectorInt___getitem__), -1);
  rb_define_method(SwigClassVectorInt.klass, "[]=", VALUEFUNC(_wrap_VectorInt___setitem__), -1);
  rb_define_method(SwigClassVectorInt.klass, "shift", VALUEFUNC(_wrap_VectorInt_shift), -1);
  rb_define_method(SwigClassVectorInt.klass, "unshift", VALUEFUNC(_wrap_VectorInt_unshift), -1);
  rb_define_method(SwigClassVectorInt.klass, "empty", VALUEFUNC(_wrap_VectorInt_empty), -1);
  rb_define_method(SwigClassVectorInt.klass, "size", VALUEFUNC(_wrap_VectorInt_size), -1);
  rb_define_method(SwigClassVectorInt.klass, "clear", VALUEFUNC(_wrap_VectorInt_clear), -1);
  rb_define_method(SwigClassVectorInt.klass, "swap", VALUEFUNC(_wrap_VectorInt_swap), -1);
  rb_define_method(SwigClassVectorInt.klass, "get_allocator", VALUEFUNC(_wrap_VectorInt_get_allocator), -1);
  rb_define_method(SwigClassVectorInt.klass, "begin", VALUEFUNC(_wrap_VectorInt_begin), -1);
  rb_define_method(SwigClassVectorInt.klass, "end", VALUEFUNC(_wrap_VectorInt_end), -1);
  rb_define_method(SwigClassVectorInt.klass, "rbegin", VALUEFUNC(_wrap_VectorInt_rbegin), -1);
  rb_define_method(SwigClassVectorInt.klass, "rend", VALUEFUNC(_wrap_VectorInt_rend), -1);
  rb_define_method(SwigClassVectorInt.klass, "erase", VALUEFUNC(_wrap_VectorInt_erase), -1);
  rb_define_method(SwigClassVectorInt.klass, "front", VALUEFUNC(_wrap_VectorInt_front), -1);
  rb_define_method(SwigClassVectorInt.klass, "back", VALUEFUNC(_wrap_VectorInt_back), -1);
  rb_define_method(SwigClassVectorInt.klass, "assign", VALUEFUNC(_wrap_VectorInt_assign), -1);
  rb_define_method(SwigClassVectorInt.klass, "resize", VALUEFUNC(_wrap_VectorInt_resize), -1);
  rb_define_method(SwigClassVectorInt.klass, "insert", VALUEFUNC(_wrap_VectorInt_insert), -1);
  rb_define_method(SwigClassVectorInt.klass, "reserve", VALUEFUNC(_wrap_VectorInt_reserve), -1);
  rb_define_method(SwigClassVectorInt.klass, "capacity", VALUEFUNC(_wrap_VectorInt_capacity), -1);
  rb_define_method(SwigClassVectorInt.klass, "map_bang", VALUEFUNC(_wrap_VectorInt_map_bang), -1);
  rb_define_method(SwigClassVectorInt.klass, "__delete__", VALUEFUNC(_wrap_VectorInt___delete__), -1);
  SwigClassVectorInt.mark = 0;
  SwigClassVectorInt.destroy = (void (*)(void *)) free_std_vector_Sl_int_Sg_;
  SwigClassVectorInt.trackObjects = 0;
  
  SwigClassVectorUnsignedInt.klass = rb_define_class_under(mOpenBabel, "VectorUnsignedInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_unsigned_int_std__allocatorT_unsigned_int_t_t, (void *) &SwigClassVectorUnsignedInt);
  rb_include_module(SwigClassVectorUnsignedInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorUnsignedInt.klass, _wrap_VectorUnsignedInt_allocate);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "initialize", VALUEFUNC(_wrap_new_VectorUnsignedInt), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "dup", VALUEFUNC(_wrap_VectorUnsignedInt_dup), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "inspect", VALUEFUNC(_wrap_VectorUnsignedInt_inspect), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "to_a", VALUEFUNC(_wrap_VectorUnsignedInt_to_a), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "to_s", VALUEFUNC(_wrap_VectorUnsignedInt_to_s), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "slice", VALUEFUNC(_wrap_VectorUnsignedInt_slice), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "each", VALUEFUNC(_wrap_VectorUnsignedInt_each), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "select", VALUEFUNC(_wrap_VectorUnsignedInt_select), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "reject_bang", VALUEFUNC(_wrap_VectorUnsignedInt_reject_bang), -1);
  rb_define_alias(SwigClassVectorUnsignedInt.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorUnsignedInt.klass, "delete_at", VALUEFUNC(_wrap_VectorUnsignedInt_delete_at), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "__delete_2__", VALUEFUNC(_wrap_VectorUnsignedInt___delete_2__), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "pop", VALUEFUNC(_wrap_VectorUnsignedInt_pop), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "push", VALUEFUNC(_wrap_VectorUnsignedInt_push), -1);
  rb_define_alias(SwigClassVectorUnsignedInt.klass, "<<", "push");
  rb_define_method(SwigClassVectorUnsignedInt.klass, "reject", VALUEFUNC(_wrap_VectorUnsignedInt_reject), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "at", VALUEFUNC(_wrap_VectorUnsignedInt_at), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "[]", VALUEFUNC(_wrap_VectorUnsignedInt___getitem__), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "[]=", VALUEFUNC(_wrap_VectorUnsignedInt___setitem__), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "shift", VALUEFUNC(_wrap_VectorUnsignedInt_shift), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "unshift", VALUEFUNC(_wrap_VectorUnsignedInt_unshift), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "empty", VALUEFUNC(_wrap_VectorUnsignedInt_empty), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "size", VALUEFUNC(_wrap_VectorUnsignedInt_size), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "clear", VALUEFUNC(_wrap_VectorUnsignedInt_clear), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "swap", VALUEFUNC(_wrap_VectorUnsignedInt_swap), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "get_allocator", VALUEFUNC(_wrap_VectorUnsignedInt_get_allocator), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "begin", VALUEFUNC(_wrap_VectorUnsignedInt_begin), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "end", VALUEFUNC(_wrap_VectorUnsignedInt_end), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "rbegin", VALUEFUNC(_wrap_VectorUnsignedInt_rbegin), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "rend", VALUEFUNC(_wrap_VectorUnsignedInt_rend), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "erase", VALUEFUNC(_wrap_VectorUnsignedInt_erase), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "front", VALUEFUNC(_wrap_VectorUnsignedInt_front), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "back", VALUEFUNC(_wrap_VectorUnsignedInt_back), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "assign", VALUEFUNC(_wrap_VectorUnsignedInt_assign), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "resize", VALUEFUNC(_wrap_VectorUnsignedInt_resize), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "insert", VALUEFUNC(_wrap_VectorUnsignedInt_insert), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "reserve", VALUEFUNC(_wrap_VectorUnsignedInt_reserve), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "capacity", VALUEFUNC(_wrap_VectorUnsignedInt_capacity), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "map_bang", VALUEFUNC(_wrap_VectorUnsignedInt_map_bang), -1);
  rb_define_method(SwigClassVectorUnsignedInt.klass, "__delete__", VALUEFUNC(_wrap_VectorUnsignedInt___delete__), -1);
  SwigClassVectorUnsignedInt.mark = 0;
  SwigClassVectorUnsignedInt.destroy = (void (*)(void *)) free_std_vector_Sl_unsigned_SS_int_Sg_;
  SwigClassVectorUnsignedInt.trackObjects = 0;
  
  SwigClassVVInt.klass = rb_define_class_under(mOpenBabel, "VVInt", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_std__vectorT_int_std__allocatorT_int_t_t_std__allocatorT_std__vectorT_int_std__allocatorT_int_t_t_t_t, (void *) &SwigClassVVInt);
  rb_include_module(SwigClassVVInt.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVVInt.klass, _wrap_VVInt_allocate);
  rb_define_method(SwigClassVVInt.klass, "initialize", VALUEFUNC(_wrap_new_VVInt), -1);
  rb_define_method(SwigClassVVInt.klass, "dup", VALUEFUNC(_wrap_VVInt_dup), -1);
  rb_define_method(SwigClassVVInt.klass, "inspect", VALUEFUNC(_wrap_VVInt_inspect), -1);
  rb_define_method(SwigClassVVInt.klass, "to_a", VALUEFUNC(_wrap_VVInt_to_a), -1);
  rb_define_method(SwigClassVVInt.klass, "to_s", VALUEFUNC(_wrap_VVInt_to_s), -1);
  rb_define_method(SwigClassVVInt.klass, "slice", VALUEFUNC(_wrap_VVInt_slice), -1);
  rb_define_method(SwigClassVVInt.klass, "each", VALUEFUNC(_wrap_VVInt_each), -1);
  rb_define_method(SwigClassVVInt.klass, "select", VALUEFUNC(_wrap_VVInt_select), -1);
  rb_define_method(SwigClassVVInt.klass, "reject_bang", VALUEFUNC(_wrap_VVInt_reject_bang), -1);
  rb_define_alias(SwigClassVVInt.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVVInt.klass, "delete_at", VALUEFUNC(_wrap_VVInt_delete_at), -1);
  rb_define_method(SwigClassVVInt.klass, "__delete_2__", VALUEFUNC(_wrap_VVInt___delete_2__), -1);
  rb_define_method(SwigClassVVInt.klass, "pop", VALUEFUNC(_wrap_VVInt_pop), -1);
  rb_define_method(SwigClassVVInt.klass, "push", VALUEFUNC(_wrap_VVInt_push), -1);
  rb_define_alias(SwigClassVVInt.klass, "<<", "push");
  rb_define_method(SwigClassVVInt.klass, "reject", VALUEFUNC(_wrap_VVInt_reject), -1);
  rb_define_method(SwigClassVVInt.klass, "at", VALUEFUNC(_wrap_VVInt_at), -1);
  rb_define_method(SwigClassVVInt.klass, "[]", VALUEFUNC(_wrap_VVInt___getitem__), -1);
  rb_define_method(SwigClassVVInt.klass, "[]=", VALUEFUNC(_wrap_VVInt___setitem__), -1);
  rb_define_method(SwigClassVVInt.klass, "shift", VALUEFUNC(_wrap_VVInt_shift), -1);
  rb_define_method(SwigClassVVInt.klass, "unshift", VALUEFUNC(_wrap_VVInt_unshift), -1);
  rb_define_method(SwigClassVVInt.klass, "empty", VALUEFUNC(_wrap_VVInt_empty), -1);
  rb_define_method(SwigClassVVInt.klass, "size", VALUEFUNC(_wrap_VVInt_size), -1);
  rb_define_method(SwigClassVVInt.klass, "clear", VALUEFUNC(_wrap_VVInt_clear), -1);
  rb_define_method(SwigClassVVInt.klass, "swap", VALUEFUNC(_wrap_VVInt_swap), -1);
  rb_define_method(SwigClassVVInt.klass, "get_allocator", VALUEFUNC(_wrap_VVInt_get_allocator), -1);
  rb_define_method(SwigClassVVInt.klass, "begin", VALUEFUNC(_wrap_VVInt_begin), -1);
  rb_define_method(SwigClassVVInt.klass, "end", VALUEFUNC(_wrap_VVInt_end), -1);
  rb_define_method(SwigClassVVInt.klass, "rbegin", VALUEFUNC(_wrap_VVInt_rbegin), -1);
  rb_define_method(SwigClassVVInt.klass, "rend", VALUEFUNC(_wrap_VVInt_rend), -1);
  rb_define_method(SwigClassVVInt.klass, "erase", VALUEFUNC(_wrap_VVInt_erase), -1);
  rb_define_method(SwigClassVVInt.klass, "front", VALUEFUNC(_wrap_VVInt_front), -1);
  rb_define_method(SwigClassVVInt.klass, "back", VALUEFUNC(_wrap_VVInt_back), -1);
  rb_define_method(SwigClassVVInt.klass, "assign", VALUEFUNC(_wrap_VVInt_assign), -1);
  rb_define_method(SwigClassVVInt.klass, "resize", VALUEFUNC(_wrap_VVInt_resize), -1);
  rb_define_method(SwigClassVVInt.klass, "insert", VALUEFUNC(_wrap_VVInt_insert), -1);
  rb_define_method(SwigClassVVInt.klass, "reserve", VALUEFUNC(_wrap_VVInt_reserve), -1);
  rb_define_method(SwigClassVVInt.klass, "capacity", VALUEFUNC(_wrap_VVInt_capacity), -1);
  SwigClassVVInt.mark = 0;
  SwigClassVVInt.destroy = (void (*)(void *)) free_std_vector_Sl_std_vector_Sl_int_Sg__Sg_;
  SwigClassVVInt.trackObjects = 0;
  
  SwigClassVectorDouble.klass = rb_define_class_under(mOpenBabel, "VectorDouble", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_double_std__allocatorT_double_t_t, (void *) &SwigClassVectorDouble);
  rb_include_module(SwigClassVectorDouble.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorDouble.klass, _wrap_VectorDouble_allocate);
  rb_define_method(SwigClassVectorDouble.klass, "initialize", VALUEFUNC(_wrap_new_VectorDouble), -1);
  rb_define_method(SwigClassVectorDouble.klass, "dup", VALUEFUNC(_wrap_VectorDouble_dup), -1);
  rb_define_method(SwigClassVectorDouble.klass, "inspect", VALUEFUNC(_wrap_VectorDouble_inspect), -1);
  rb_define_method(SwigClassVectorDouble.klass, "to_a", VALUEFUNC(_wrap_VectorDouble_to_a), -1);
  rb_define_method(SwigClassVectorDouble.klass, "to_s", VALUEFUNC(_wrap_VectorDouble_to_s), -1);
  rb_define_method(SwigClassVectorDouble.klass, "slice", VALUEFUNC(_wrap_VectorDouble_slice), -1);
  rb_define_method(SwigClassVectorDouble.klass, "each", VALUEFUNC(_wrap_VectorDouble_each), -1);
  rb_define_method(SwigClassVectorDouble.klass, "select", VALUEFUNC(_wrap_VectorDouble_select), -1);
  rb_define_method(SwigClassVectorDouble.klass, "reject_bang", VALUEFUNC(_wrap_VectorDouble_reject_bang), -1);
  rb_define_alias(SwigClassVectorDouble.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorDouble.klass, "delete_at", VALUEFUNC(_wrap_VectorDouble_delete_at), -1);
  rb_define_method(SwigClassVectorDouble.klass, "__delete_2__", VALUEFUNC(_wrap_VectorDouble___delete_2__), -1);
  rb_define_method(SwigClassVectorDouble.klass, "pop", VALUEFUNC(_wrap_VectorDouble_pop), -1);
  rb_define_method(SwigClassVectorDouble.klass, "push", VALUEFUNC(_wrap_VectorDouble_push), -1);
  rb_define_alias(SwigClassVectorDouble.klass, "<<", "push");
  rb_define_method(SwigClassVectorDouble.klass, "reject", VALUEFUNC(_wrap_VectorDouble_reject), -1);
  rb_define_method(SwigClassVectorDouble.klass, "at", VALUEFUNC(_wrap_VectorDouble_at), -1);
  rb_define_method(SwigClassVectorDouble.klass, "[]", VALUEFUNC(_wrap_VectorDouble___getitem__), -1);
  rb_define_method(SwigClassVectorDouble.klass, "[]=", VALUEFUNC(_wrap_VectorDouble___setitem__), -1);
  rb_define_method(SwigClassVectorDouble.klass, "shift", VALUEFUNC(_wrap_VectorDouble_shift), -1);
  rb_define_method(SwigClassVectorDouble.klass, "unshift", VALUEFUNC(_wrap_VectorDouble_unshift), -1);
  rb_define_method(SwigClassVectorDouble.klass, "empty", VALUEFUNC(_wrap_VectorDouble_empty), -1);
  rb_define_method(SwigClassVectorDouble.klass, "size", VALUEFUNC(_wrap_VectorDouble_size), -1);
  rb_define_method(SwigClassVectorDouble.klass, "clear", VALUEFUNC(_wrap_VectorDouble_clear), -1);
  rb_define_method(SwigClassVectorDouble.klass, "swap", VALUEFUNC(_wrap_VectorDouble_swap), -1);
  rb_define_method(SwigClassVectorDouble.klass, "get_allocator", VALUEFUNC(_wrap_VectorDouble_get_allocator), -1);
  rb_define_method(SwigClassVectorDouble.klass, "begin", VALUEFUNC(_wrap_VectorDouble_begin), -1);
  rb_define_method(SwigClassVectorDouble.klass, "end", VALUEFUNC(_wrap_VectorDouble_end), -1);
  rb_define_method(SwigClassVectorDouble.klass, "rbegin", VALUEFUNC(_wrap_VectorDouble_rbegin), -1);
  rb_define_method(SwigClassVectorDouble.klass, "rend", VALUEFUNC(_wrap_VectorDouble_rend), -1);
  rb_define_method(SwigClassVectorDouble.klass, "erase", VALUEFUNC(_wrap_VectorDouble_erase), -1);
  rb_define_method(SwigClassVectorDouble.klass, "front", VALUEFUNC(_wrap_VectorDouble_front), -1);
  rb_define_method(SwigClassVectorDouble.klass, "back", VALUEFUNC(_wrap_VectorDouble_back), -1);
  rb_define_method(SwigClassVectorDouble.klass, "assign", VALUEFUNC(_wrap_VectorDouble_assign), -1);
  rb_define_method(SwigClassVectorDouble.klass, "resize", VALUEFUNC(_wrap_VectorDouble_resize), -1);
  rb_define_method(SwigClassVectorDouble.klass, "insert", VALUEFUNC(_wrap_VectorDouble_insert), -1);
  rb_define_method(SwigClassVectorDouble.klass, "reserve", VALUEFUNC(_wrap_VectorDouble_reserve), -1);
  rb_define_method(SwigClassVectorDouble.klass, "capacity", VALUEFUNC(_wrap_VectorDouble_capacity), -1);
  rb_define_method(SwigClassVectorDouble.klass, "map_bang", VALUEFUNC(_wrap_VectorDouble_map_bang), -1);
  rb_define_method(SwigClassVectorDouble.klass, "__delete__", VALUEFUNC(_wrap_VectorDouble___delete__), -1);
  SwigClassVectorDouble.mark = 0;
  SwigClassVectorDouble.destroy = (void (*)(void *)) free_std_vector_Sl_double_Sg_;
  SwigClassVectorDouble.trackObjects = 0;
  
  SwigClassVectorString.klass = rb_define_class_under(mOpenBabel, "VectorString", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_std__string_std__allocatorT_std__string_t_t, (void *) &SwigClassVectorString);
  rb_include_module(SwigClassVectorString.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorString.klass, _wrap_VectorString_allocate);
  rb_define_method(SwigClassVectorString.klass, "initialize", VALUEFUNC(_wrap_new_VectorString), -1);
  rb_define_method(SwigClassVectorString.klass, "dup", VALUEFUNC(_wrap_VectorString_dup), -1);
  rb_define_method(SwigClassVectorString.klass, "inspect", VALUEFUNC(_wrap_VectorString_inspect), -1);
  rb_define_method(SwigClassVectorString.klass, "to_a", VALUEFUNC(_wrap_VectorString_to_a), -1);
  rb_define_method(SwigClassVectorString.klass, "to_s", VALUEFUNC(_wrap_VectorString_to_s), -1);
  rb_define_method(SwigClassVectorString.klass, "slice", VALUEFUNC(_wrap_VectorString_slice), -1);
  rb_define_method(SwigClassVectorString.klass, "each", VALUEFUNC(_wrap_VectorString_each), -1);
  rb_define_method(SwigClassVectorString.klass, "select", VALUEFUNC(_wrap_VectorString_select), -1);
  rb_define_method(SwigClassVectorString.klass, "reject_bang", VALUEFUNC(_wrap_VectorString_reject_bang), -1);
  rb_define_alias(SwigClassVectorString.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorString.klass, "delete_at", VALUEFUNC(_wrap_VectorString_delete_at), -1);
  rb_define_method(SwigClassVectorString.klass, "__delete_2__", VALUEFUNC(_wrap_VectorString___delete_2__), -1);
  rb_define_method(SwigClassVectorString.klass, "pop", VALUEFUNC(_wrap_VectorString_pop), -1);
  rb_define_method(SwigClassVectorString.klass, "push", VALUEFUNC(_wrap_VectorString_push), -1);
  rb_define_alias(SwigClassVectorString.klass, "<<", "push");
  rb_define_method(SwigClassVectorString.klass, "reject", VALUEFUNC(_wrap_VectorString_reject), -1);
  rb_define_method(SwigClassVectorString.klass, "at", VALUEFUNC(_wrap_VectorString_at), -1);
  rb_define_method(SwigClassVectorString.klass, "[]", VALUEFUNC(_wrap_VectorString___getitem__), -1);
  rb_define_method(SwigClassVectorString.klass, "[]=", VALUEFUNC(_wrap_VectorString___setitem__), -1);
  rb_define_method(SwigClassVectorString.klass, "shift", VALUEFUNC(_wrap_VectorString_shift), -1);
  rb_define_method(SwigClassVectorString.klass, "unshift", VALUEFUNC(_wrap_VectorString_unshift), -1);
  rb_define_method(SwigClassVectorString.klass, "empty", VALUEFUNC(_wrap_VectorString_empty), -1);
  rb_define_method(SwigClassVectorString.klass, "size", VALUEFUNC(_wrap_VectorString_size), -1);
  rb_define_method(SwigClassVectorString.klass, "clear", VALUEFUNC(_wrap_VectorString_clear), -1);
  rb_define_method(SwigClassVectorString.klass, "swap", VALUEFUNC(_wrap_VectorString_swap), -1);
  rb_define_method(SwigClassVectorString.klass, "get_allocator", VALUEFUNC(_wrap_VectorString_get_allocator), -1);
  rb_define_method(SwigClassVectorString.klass, "begin", VALUEFUNC(_wrap_VectorString_begin), -1);
  rb_define_method(SwigClassVectorString.klass, "end", VALUEFUNC(_wrap_VectorString_end), -1);
  rb_define_method(SwigClassVectorString.klass, "rbegin", VALUEFUNC(_wrap_VectorString_rbegin), -1);
  rb_define_method(SwigClassVectorString.klass, "rend", VALUEFUNC(_wrap_VectorString_rend), -1);
  rb_define_method(SwigClassVectorString.klass, "erase", VALUEFUNC(_wrap_VectorString_erase), -1);
  rb_define_method(SwigClassVectorString.klass, "front", VALUEFUNC(_wrap_VectorString_front), -1);
  rb_define_method(SwigClassVectorString.klass, "back", VALUEFUNC(_wrap_VectorString_back), -1);
  rb_define_method(SwigClassVectorString.klass, "assign", VALUEFUNC(_wrap_VectorString_assign), -1);
  rb_define_method(SwigClassVectorString.klass, "resize", VALUEFUNC(_wrap_VectorString_resize), -1);
  rb_define_method(SwigClassVectorString.klass, "insert", VALUEFUNC(_wrap_VectorString_insert), -1);
  rb_define_method(SwigClassVectorString.klass, "reserve", VALUEFUNC(_wrap_VectorString_reserve), -1);
  rb_define_method(SwigClassVectorString.klass, "capacity", VALUEFUNC(_wrap_VectorString_capacity), -1);
  rb_define_method(SwigClassVectorString.klass, "map_bang", VALUEFUNC(_wrap_VectorString_map_bang), -1);
  rb_define_method(SwigClassVectorString.klass, "__delete__", VALUEFUNC(_wrap_VectorString___delete__), -1);
  SwigClassVectorString.mark = 0;
  SwigClassVectorString.destroy = (void (*)(void *)) free_std_vector_Sl_std_string_Sg_;
  SwigClassVectorString.trackObjects = 0;
  
  SwigClassVVector3.klass = rb_define_class_under(mOpenBabel, "VVector3", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__vector3_std__allocatorT_OpenBabel__vector3_t_t, (void *) &SwigClassVVector3);
  rb_include_module(SwigClassVVector3.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVVector3.klass, _wrap_VVector3_allocate);
  rb_define_method(SwigClassVVector3.klass, "initialize", VALUEFUNC(_wrap_new_VVector3), -1);
  rb_define_method(SwigClassVVector3.klass, "dup", VALUEFUNC(_wrap_VVector3_dup), -1);
  rb_define_method(SwigClassVVector3.klass, "inspect", VALUEFUNC(_wrap_VVector3_inspect), -1);
  rb_define_method(SwigClassVVector3.klass, "to_a", VALUEFUNC(_wrap_VVector3_to_a), -1);
  rb_define_method(SwigClassVVector3.klass, "to_s", VALUEFUNC(_wrap_VVector3_to_s), -1);
  rb_define_method(SwigClassVVector3.klass, "slice", VALUEFUNC(_wrap_VVector3_slice), -1);
  rb_define_method(SwigClassVVector3.klass, "each", VALUEFUNC(_wrap_VVector3_each), -1);
  rb_define_method(SwigClassVVector3.klass, "select", VALUEFUNC(_wrap_VVector3_select), -1);
  rb_define_method(SwigClassVVector3.klass, "reject_bang", VALUEFUNC(_wrap_VVector3_reject_bang), -1);
  rb_define_alias(SwigClassVVector3.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVVector3.klass, "delete_at", VALUEFUNC(_wrap_VVector3_delete_at), -1);
  rb_define_method(SwigClassVVector3.klass, "__delete_2__", VALUEFUNC(_wrap_VVector3___delete_2__), -1);
  rb_define_method(SwigClassVVector3.klass, "pop", VALUEFUNC(_wrap_VVector3_pop), -1);
  rb_define_method(SwigClassVVector3.klass, "push", VALUEFUNC(_wrap_VVector3_push), -1);
  rb_define_alias(SwigClassVVector3.klass, "<<", "push");
  rb_define_method(SwigClassVVector3.klass, "reject", VALUEFUNC(_wrap_VVector3_reject), -1);
  rb_define_method(SwigClassVVector3.klass, "at", VALUEFUNC(_wrap_VVector3_at), -1);
  rb_define_method(SwigClassVVector3.klass, "[]", VALUEFUNC(_wrap_VVector3___getitem__), -1);
  rb_define_method(SwigClassVVector3.klass, "[]=", VALUEFUNC(_wrap_VVector3___setitem__), -1);
  rb_define_method(SwigClassVVector3.klass, "shift", VALUEFUNC(_wrap_VVector3_shift), -1);
  rb_define_method(SwigClassVVector3.klass, "unshift", VALUEFUNC(_wrap_VVector3_unshift), -1);
  rb_define_method(SwigClassVVector3.klass, "empty", VALUEFUNC(_wrap_VVector3_empty), -1);
  rb_define_method(SwigClassVVector3.klass, "size", VALUEFUNC(_wrap_VVector3_size), -1);
  rb_define_method(SwigClassVVector3.klass, "clear", VALUEFUNC(_wrap_VVector3_clear), -1);
  rb_define_method(SwigClassVVector3.klass, "swap", VALUEFUNC(_wrap_VVector3_swap), -1);
  rb_define_method(SwigClassVVector3.klass, "get_allocator", VALUEFUNC(_wrap_VVector3_get_allocator), -1);
  rb_define_method(SwigClassVVector3.klass, "begin", VALUEFUNC(_wrap_VVector3_begin), -1);
  rb_define_method(SwigClassVVector3.klass, "end", VALUEFUNC(_wrap_VVector3_end), -1);
  rb_define_method(SwigClassVVector3.klass, "rbegin", VALUEFUNC(_wrap_VVector3_rbegin), -1);
  rb_define_method(SwigClassVVector3.klass, "rend", VALUEFUNC(_wrap_VVector3_rend), -1);
  rb_define_method(SwigClassVVector3.klass, "erase", VALUEFUNC(_wrap_VVector3_erase), -1);
  rb_define_method(SwigClassVVector3.klass, "front", VALUEFUNC(_wrap_VVector3_front), -1);
  rb_define_method(SwigClassVVector3.klass, "back", VALUEFUNC(_wrap_VVector3_back), -1);
  rb_define_method(SwigClassVVector3.klass, "assign", VALUEFUNC(_wrap_VVector3_assign), -1);
  rb_define_method(SwigClassVVector3.klass, "resize", VALUEFUNC(_wrap_VVector3_resize), -1);
  rb_define_method(SwigClassVVector3.klass, "insert", VALUEFUNC(_wrap_VVector3_insert), -1);
  rb_define_method(SwigClassVVector3.klass, "reserve", VALUEFUNC(_wrap_VVector3_reserve), -1);
  rb_define_method(SwigClassVVector3.klass, "capacity", VALUEFUNC(_wrap_VVector3_capacity), -1);
  SwigClassVVector3.mark = 0;
  SwigClassVVector3.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_vector3_Sg_;
  SwigClassVVector3.trackObjects = 0;
  
  SwigClassVectorMol.klass = rb_define_class_under(mOpenBabel, "VectorMol", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__OBMol_std__allocatorT_OpenBabel__OBMol_t_t, (void *) &SwigClassVectorMol);
  rb_include_module(SwigClassVectorMol.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorMol.klass, _wrap_VectorMol_allocate);
  rb_define_method(SwigClassVectorMol.klass, "initialize", VALUEFUNC(_wrap_new_VectorMol), -1);
  rb_define_method(SwigClassVectorMol.klass, "dup", VALUEFUNC(_wrap_VectorMol_dup), -1);
  rb_define_method(SwigClassVectorMol.klass, "inspect", VALUEFUNC(_wrap_VectorMol_inspect), -1);
  rb_define_method(SwigClassVectorMol.klass, "to_a", VALUEFUNC(_wrap_VectorMol_to_a), -1);
  rb_define_method(SwigClassVectorMol.klass, "to_s", VALUEFUNC(_wrap_VectorMol_to_s), -1);
  rb_define_method(SwigClassVectorMol.klass, "slice", VALUEFUNC(_wrap_VectorMol_slice), -1);
  rb_define_method(SwigClassVectorMol.klass, "each", VALUEFUNC(_wrap_VectorMol_each), -1);
  rb_define_method(SwigClassVectorMol.klass, "select", VALUEFUNC(_wrap_VectorMol_select), -1);
  rb_define_method(SwigClassVectorMol.klass, "reject_bang", VALUEFUNC(_wrap_VectorMol_reject_bang), -1);
  rb_define_alias(SwigClassVectorMol.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorMol.klass, "delete_at", VALUEFUNC(_wrap_VectorMol_delete_at), -1);
  rb_define_method(SwigClassVectorMol.klass, "__delete_2__", VALUEFUNC(_wrap_VectorMol___delete_2__), -1);
  rb_define_method(SwigClassVectorMol.klass, "pop", VALUEFUNC(_wrap_VectorMol_pop), -1);
  rb_define_method(SwigClassVectorMol.klass, "push", VALUEFUNC(_wrap_VectorMol_push), -1);
  rb_define_alias(SwigClassVectorMol.klass, "<<", "push");
  rb_define_method(SwigClassVectorMol.klass, "reject", VALUEFUNC(_wrap_VectorMol_reject), -1);
  rb_define_method(SwigClassVectorMol.klass, "at", VALUEFUNC(_wrap_VectorMol_at), -1);
  rb_define_method(SwigClassVectorMol.klass, "[]", VALUEFUNC(_wrap_VectorMol___getitem__), -1);
  rb_define_method(SwigClassVectorMol.klass, "[]=", VALUEFUNC(_wrap_VectorMol___setitem__), -1);
  rb_define_method(SwigClassVectorMol.klass, "shift", VALUEFUNC(_wrap_VectorMol_shift), -1);
  rb_define_method(SwigClassVectorMol.klass, "unshift", VALUEFUNC(_wrap_VectorMol_unshift), -1);
  rb_define_method(SwigClassVectorMol.klass, "empty", VALUEFUNC(_wrap_VectorMol_empty), -1);
  rb_define_method(SwigClassVectorMol.klass, "size", VALUEFUNC(_wrap_VectorMol_size), -1);
  rb_define_method(SwigClassVectorMol.klass, "clear", VALUEFUNC(_wrap_VectorMol_clear), -1);
  rb_define_method(SwigClassVectorMol.klass, "swap", VALUEFUNC(_wrap_VectorMol_swap), -1);
  rb_define_method(SwigClassVectorMol.klass, "get_allocator", VALUEFUNC(_wrap_VectorMol_get_allocator), -1);
  rb_define_method(SwigClassVectorMol.klass, "begin", VALUEFUNC(_wrap_VectorMol_begin), -1);
  rb_define_method(SwigClassVectorMol.klass, "end", VALUEFUNC(_wrap_VectorMol_end), -1);
  rb_define_method(SwigClassVectorMol.klass, "rbegin", VALUEFUNC(_wrap_VectorMol_rbegin), -1);
  rb_define_method(SwigClassVectorMol.klass, "rend", VALUEFUNC(_wrap_VectorMol_rend), -1);
  rb_define_method(SwigClassVectorMol.klass, "erase", VALUEFUNC(_wrap_VectorMol_erase), -1);
  rb_define_method(SwigClassVectorMol.klass, "front", VALUEFUNC(_wrap_VectorMol_front), -1);
  rb_define_method(SwigClassVectorMol.klass, "back", VALUEFUNC(_wrap_VectorMol_back), -1);
  rb_define_method(SwigClassVectorMol.klass, "assign", VALUEFUNC(_wrap_VectorMol_assign), -1);
  rb_define_method(SwigClassVectorMol.klass, "resize", VALUEFUNC(_wrap_VectorMol_resize), -1);
  rb_define_method(SwigClassVectorMol.klass, "insert", VALUEFUNC(_wrap_VectorMol_insert), -1);
  rb_define_method(SwigClassVectorMol.klass, "reserve", VALUEFUNC(_wrap_VectorMol_reserve), -1);
  rb_define_method(SwigClassVectorMol.klass, "capacity", VALUEFUNC(_wrap_VectorMol_capacity), -1);
  SwigClassVectorMol.mark = 0;
  SwigClassVectorMol.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBMol_Sg_;
  SwigClassVectorMol.trackObjects = 0;
  
  SwigClassVectorBond.klass = rb_define_class_under(mOpenBabel, "VectorBond", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__OBBond_std__allocatorT_OpenBabel__OBBond_t_t, (void *) &SwigClassVectorBond);
  rb_include_module(SwigClassVectorBond.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorBond.klass, _wrap_VectorBond_allocate);
  rb_define_method(SwigClassVectorBond.klass, "initialize", VALUEFUNC(_wrap_new_VectorBond), -1);
  rb_define_method(SwigClassVectorBond.klass, "dup", VALUEFUNC(_wrap_VectorBond_dup), -1);
  rb_define_method(SwigClassVectorBond.klass, "inspect", VALUEFUNC(_wrap_VectorBond_inspect), -1);
  rb_define_method(SwigClassVectorBond.klass, "to_a", VALUEFUNC(_wrap_VectorBond_to_a), -1);
  rb_define_method(SwigClassVectorBond.klass, "to_s", VALUEFUNC(_wrap_VectorBond_to_s), -1);
  rb_define_method(SwigClassVectorBond.klass, "slice", VALUEFUNC(_wrap_VectorBond_slice), -1);
  rb_define_method(SwigClassVectorBond.klass, "each", VALUEFUNC(_wrap_VectorBond_each), -1);
  rb_define_method(SwigClassVectorBond.klass, "select", VALUEFUNC(_wrap_VectorBond_select), -1);
  rb_define_method(SwigClassVectorBond.klass, "reject_bang", VALUEFUNC(_wrap_VectorBond_reject_bang), -1);
  rb_define_alias(SwigClassVectorBond.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorBond.klass, "delete_at", VALUEFUNC(_wrap_VectorBond_delete_at), -1);
  rb_define_method(SwigClassVectorBond.klass, "__delete_2__", VALUEFUNC(_wrap_VectorBond___delete_2__), -1);
  rb_define_method(SwigClassVectorBond.klass, "pop", VALUEFUNC(_wrap_VectorBond_pop), -1);
  rb_define_method(SwigClassVectorBond.klass, "push", VALUEFUNC(_wrap_VectorBond_push), -1);
  rb_define_alias(SwigClassVectorBond.klass, "<<", "push");
  rb_define_method(SwigClassVectorBond.klass, "reject", VALUEFUNC(_wrap_VectorBond_reject), -1);
  rb_define_method(SwigClassVectorBond.klass, "at", VALUEFUNC(_wrap_VectorBond_at), -1);
  rb_define_method(SwigClassVectorBond.klass, "[]", VALUEFUNC(_wrap_VectorBond___getitem__), -1);
  rb_define_method(SwigClassVectorBond.klass, "[]=", VALUEFUNC(_wrap_VectorBond___setitem__), -1);
  rb_define_method(SwigClassVectorBond.klass, "shift", VALUEFUNC(_wrap_VectorBond_shift), -1);
  rb_define_method(SwigClassVectorBond.klass, "unshift", VALUEFUNC(_wrap_VectorBond_unshift), -1);
  rb_define_method(SwigClassVectorBond.klass, "empty", VALUEFUNC(_wrap_VectorBond_empty), -1);
  rb_define_method(SwigClassVectorBond.klass, "size", VALUEFUNC(_wrap_VectorBond_size), -1);
  rb_define_method(SwigClassVectorBond.klass, "clear", VALUEFUNC(_wrap_VectorBond_clear), -1);
  rb_define_method(SwigClassVectorBond.klass, "swap", VALUEFUNC(_wrap_VectorBond_swap), -1);
  rb_define_method(SwigClassVectorBond.klass, "get_allocator", VALUEFUNC(_wrap_VectorBond_get_allocator), -1);
  rb_define_method(SwigClassVectorBond.klass, "begin", VALUEFUNC(_wrap_VectorBond_begin), -1);
  rb_define_method(SwigClassVectorBond.klass, "end", VALUEFUNC(_wrap_VectorBond_end), -1);
  rb_define_method(SwigClassVectorBond.klass, "rbegin", VALUEFUNC(_wrap_VectorBond_rbegin), -1);
  rb_define_method(SwigClassVectorBond.klass, "rend", VALUEFUNC(_wrap_VectorBond_rend), -1);
  rb_define_method(SwigClassVectorBond.klass, "erase", VALUEFUNC(_wrap_VectorBond_erase), -1);
  rb_define_method(SwigClassVectorBond.klass, "front", VALUEFUNC(_wrap_VectorBond_front), -1);
  rb_define_method(SwigClassVectorBond.klass, "back", VALUEFUNC(_wrap_VectorBond_back), -1);
  rb_define_method(SwigClassVectorBond.klass, "assign", VALUEFUNC(_wrap_VectorBond_assign), -1);
  rb_define_method(SwigClassVectorBond.klass, "resize", VALUEFUNC(_wrap_VectorBond_resize), -1);
  rb_define_method(SwigClassVectorBond.klass, "insert", VALUEFUNC(_wrap_VectorBond_insert), -1);
  rb_define_method(SwigClassVectorBond.klass, "reserve", VALUEFUNC(_wrap_VectorBond_reserve), -1);
  rb_define_method(SwigClassVectorBond.klass, "capacity", VALUEFUNC(_wrap_VectorBond_capacity), -1);
  SwigClassVectorBond.mark = 0;
  SwigClassVectorBond.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBBond_Sg_;
  SwigClassVectorBond.trackObjects = 0;
  
  SwigClassVectorResidue.klass = rb_define_class_under(mOpenBabel, "VectorResidue", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__OBResidue_std__allocatorT_OpenBabel__OBResidue_t_t, (void *) &SwigClassVectorResidue);
  rb_include_module(SwigClassVectorResidue.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorResidue.klass, _wrap_VectorResidue_allocate);
  rb_define_method(SwigClassVectorResidue.klass, "initialize", VALUEFUNC(_wrap_new_VectorResidue), -1);
  rb_define_method(SwigClassVectorResidue.klass, "dup", VALUEFUNC(_wrap_VectorResidue_dup), -1);
  rb_define_method(SwigClassVectorResidue.klass, "inspect", VALUEFUNC(_wrap_VectorResidue_inspect), -1);
  rb_define_method(SwigClassVectorResidue.klass, "to_a", VALUEFUNC(_wrap_VectorResidue_to_a), -1);
  rb_define_method(SwigClassVectorResidue.klass, "to_s", VALUEFUNC(_wrap_VectorResidue_to_s), -1);
  rb_define_method(SwigClassVectorResidue.klass, "slice", VALUEFUNC(_wrap_VectorResidue_slice), -1);
  rb_define_method(SwigClassVectorResidue.klass, "each", VALUEFUNC(_wrap_VectorResidue_each), -1);
  rb_define_method(SwigClassVectorResidue.klass, "select", VALUEFUNC(_wrap_VectorResidue_select), -1);
  rb_define_method(SwigClassVectorResidue.klass, "reject_bang", VALUEFUNC(_wrap_VectorResidue_reject_bang), -1);
  rb_define_alias(SwigClassVectorResidue.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorResidue.klass, "delete_at", VALUEFUNC(_wrap_VectorResidue_delete_at), -1);
  rb_define_method(SwigClassVectorResidue.klass, "__delete_2__", VALUEFUNC(_wrap_VectorResidue___delete_2__), -1);
  rb_define_method(SwigClassVectorResidue.klass, "pop", VALUEFUNC(_wrap_VectorResidue_pop), -1);
  rb_define_method(SwigClassVectorResidue.klass, "push", VALUEFUNC(_wrap_VectorResidue_push), -1);
  rb_define_alias(SwigClassVectorResidue.klass, "<<", "push");
  rb_define_method(SwigClassVectorResidue.klass, "reject", VALUEFUNC(_wrap_VectorResidue_reject), -1);
  rb_define_method(SwigClassVectorResidue.klass, "at", VALUEFUNC(_wrap_VectorResidue_at), -1);
  rb_define_method(SwigClassVectorResidue.klass, "[]", VALUEFUNC(_wrap_VectorResidue___getitem__), -1);
  rb_define_method(SwigClassVectorResidue.klass, "[]=", VALUEFUNC(_wrap_VectorResidue___setitem__), -1);
  rb_define_method(SwigClassVectorResidue.klass, "shift", VALUEFUNC(_wrap_VectorResidue_shift), -1);
  rb_define_method(SwigClassVectorResidue.klass, "unshift", VALUEFUNC(_wrap_VectorResidue_unshift), -1);
  rb_define_method(SwigClassVectorResidue.klass, "empty", VALUEFUNC(_wrap_VectorResidue_empty), -1);
  rb_define_method(SwigClassVectorResidue.klass, "size", VALUEFUNC(_wrap_VectorResidue_size), -1);
  rb_define_method(SwigClassVectorResidue.klass, "clear", VALUEFUNC(_wrap_VectorResidue_clear), -1);
  rb_define_method(SwigClassVectorResidue.klass, "swap", VALUEFUNC(_wrap_VectorResidue_swap), -1);
  rb_define_method(SwigClassVectorResidue.klass, "get_allocator", VALUEFUNC(_wrap_VectorResidue_get_allocator), -1);
  rb_define_method(SwigClassVectorResidue.klass, "begin", VALUEFUNC(_wrap_VectorResidue_begin), -1);
  rb_define_method(SwigClassVectorResidue.klass, "end", VALUEFUNC(_wrap_VectorResidue_end), -1);
  rb_define_method(SwigClassVectorResidue.klass, "rbegin", VALUEFUNC(_wrap_VectorResidue_rbegin), -1);
  rb_define_method(SwigClassVectorResidue.klass, "rend", VALUEFUNC(_wrap_VectorResidue_rend), -1);
  rb_define_method(SwigClassVectorResidue.klass, "erase", VALUEFUNC(_wrap_VectorResidue_erase), -1);
  rb_define_method(SwigClassVectorResidue.klass, "front", VALUEFUNC(_wrap_VectorResidue_front), -1);
  rb_define_method(SwigClassVectorResidue.klass, "back", VALUEFUNC(_wrap_VectorResidue_back), -1);
  rb_define_method(SwigClassVectorResidue.klass, "assign", VALUEFUNC(_wrap_VectorResidue_assign), -1);
  rb_define_method(SwigClassVectorResidue.klass, "resize", VALUEFUNC(_wrap_VectorResidue_resize), -1);
  rb_define_method(SwigClassVectorResidue.klass, "insert", VALUEFUNC(_wrap_VectorResidue_insert), -1);
  rb_define_method(SwigClassVectorResidue.klass, "reserve", VALUEFUNC(_wrap_VectorResidue_reserve), -1);
  rb_define_method(SwigClassVectorResidue.klass, "capacity", VALUEFUNC(_wrap_VectorResidue_capacity), -1);
  SwigClassVectorResidue.mark = 0;
  SwigClassVectorResidue.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBResidue_Sg_;
  SwigClassVectorResidue.trackObjects = 0;
  
  SwigClassVectorRing.klass = rb_define_class_under(mOpenBabel, "VectorRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_std__allocatorT_OpenBabel__OBRing_t_t, (void *) &SwigClassVectorRing);
  rb_include_module(SwigClassVectorRing.klass, rb_eval_string("Enumerable"));
  rb_define_alloc_func(SwigClassVectorRing.klass, _wrap_VectorRing_allocate);
  rb_define_method(SwigClassVectorRing.klass, "initialize", VALUEFUNC(_wrap_new_VectorRing), -1);
  rb_define_method(SwigClassVectorRing.klass, "dup", VALUEFUNC(_wrap_VectorRing_dup), -1);
  rb_define_method(SwigClassVectorRing.klass, "inspect", VALUEFUNC(_wrap_VectorRing_inspect), -1);
  rb_define_method(SwigClassVectorRing.klass, "to_a", VALUEFUNC(_wrap_VectorRing_to_a), -1);
  rb_define_method(SwigClassVectorRing.klass, "to_s", VALUEFUNC(_wrap_VectorRing_to_s), -1);
  rb_define_method(SwigClassVectorRing.klass, "slice", VALUEFUNC(_wrap_VectorRing_slice), -1);
  rb_define_method(SwigClassVectorRing.klass, "each", VALUEFUNC(_wrap_VectorRing_each), -1);
  rb_define_method(SwigClassVectorRing.klass, "select", VALUEFUNC(_wrap_VectorRing_select), -1);
  rb_define_method(SwigClassVectorRing.klass, "reject_bang", VALUEFUNC(_wrap_VectorRing_reject_bang), -1);
  rb_define_alias(SwigClassVectorRing.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorRing.klass, "delete_at", VALUEFUNC(_wrap_VectorRing_delete_at), -1);
  rb_define_method(SwigClassVectorRing.klass, "__delete_2__", VALUEFUNC(_wrap_VectorRing___delete_2__), -1);
  rb_define_method(SwigClassVectorRing.klass, "pop", VALUEFUNC(_wrap_VectorRing_pop), -1);
  rb_define_method(SwigClassVectorRing.klass, "push", VALUEFUNC(_wrap_VectorRing_push), -1);
  rb_define_alias(SwigClassVectorRing.klass, "<<", "push");
  rb_define_method(SwigClassVectorRing.klass, "reject", VALUEFUNC(_wrap_VectorRing_reject), -1);
  rb_define_method(SwigClassVectorRing.klass, "at", VALUEFUNC(_wrap_VectorRing_at), -1);
  rb_define_method(SwigClassVectorRing.klass, "[]", VALUEFUNC(_wrap_VectorRing___getitem__), -1);
  rb_define_method(SwigClassVectorRing.klass, "[]=", VALUEFUNC(_wrap_VectorRing___setitem__), -1);
  rb_define_method(SwigClassVectorRing.klass, "shift", VALUEFUNC(_wrap_VectorRing_shift), -1);
  rb_define_method(SwigClassVectorRing.klass, "unshift", VALUEFUNC(_wrap_VectorRing_unshift), -1);
  rb_define_method(SwigClassVectorRing.klass, "empty", VALUEFUNC(_wrap_VectorRing_empty), -1);
  rb_define_method(SwigClassVectorRing.klass, "size", VALUEFUNC(_wrap_VectorRing_size), -1);
  rb_define_method(SwigClassVectorRing.klass, "clear", VALUEFUNC(_wrap_VectorRing_clear), -1);
  rb_define_method(SwigClassVectorRing.klass, "swap", VALUEFUNC(_wrap_VectorRing_swap), -1);
  rb_define_method(SwigClassVectorRing.klass, "get_allocator", VALUEFUNC(_wrap_VectorRing_get_allocator), -1);
  rb_define_method(SwigClassVectorRing.klass, "begin", VALUEFUNC(_wrap_VectorRing_begin), -1);
  rb_define_method(SwigClassVectorRing.klass, "end", VALUEFUNC(_wrap_VectorRing_end), -1);
  rb_define_method(SwigClassVectorRing.klass, "rbegin", VALUEFUNC(_wrap_VectorRing_rbegin), -1);
  rb_define_method(SwigClassVectorRing.klass, "rend", VALUEFUNC(_wrap_VectorRing_rend), -1);
  rb_define_method(SwigClassVectorRing.klass, "erase", VALUEFUNC(_wrap_VectorRing_erase), -1);
  rb_define_method(SwigClassVectorRing.klass, "front", VALUEFUNC(_wrap_VectorRing_front), -1);
  rb_define_method(SwigClassVectorRing.klass, "back", VALUEFUNC(_wrap_VectorRing_back), -1);
  rb_define_method(SwigClassVectorRing.klass, "assign", VALUEFUNC(_wrap_VectorRing_assign), -1);
  rb_define_method(SwigClassVectorRing.klass, "resize", VALUEFUNC(_wrap_VectorRing_resize), -1);
  rb_define_method(SwigClassVectorRing.klass, "insert", VALUEFUNC(_wrap_VectorRing_insert), -1);
  rb_define_method(SwigClassVectorRing.klass, "reserve", VALUEFUNC(_wrap_VectorRing_reserve), -1);
  rb_define_method(SwigClassVectorRing.klass, "capacity", VALUEFUNC(_wrap_VectorRing_capacity), -1);
  SwigClassVectorRing.mark = 0;
  SwigClassVectorRing.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBRing_Sg_;
  SwigClassVectorRing.trackObjects = 0;
  
  SwigClassVectorpRing.klass = rb_define_class_under(mOpenBabel, "VectorpRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__OBRing_p_std__allocatorT_OpenBabel__OBRing_p_t_t, (void *) &SwigClassVectorpRing);
  rb_define_alloc_func(SwigClassVectorpRing.klass, _wrap_VectorpRing_allocate);
  rb_define_method(SwigClassVectorpRing.klass, "initialize", VALUEFUNC(_wrap_new_VectorpRing), -1);
  rb_define_method(SwigClassVectorpRing.klass, "dup", VALUEFUNC(_wrap_VectorpRing_dup), -1);
  rb_define_method(SwigClassVectorpRing.klass, "inspect", VALUEFUNC(_wrap_VectorpRing_inspect), -1);
  rb_define_method(SwigClassVectorpRing.klass, "to_a", VALUEFUNC(_wrap_VectorpRing_to_a), -1);
  rb_define_method(SwigClassVectorpRing.klass, "to_s", VALUEFUNC(_wrap_VectorpRing_to_s), -1);
  rb_define_method(SwigClassVectorpRing.klass, "slice", VALUEFUNC(_wrap_VectorpRing_slice), -1);
  rb_define_method(SwigClassVectorpRing.klass, "each", VALUEFUNC(_wrap_VectorpRing_each), -1);
  rb_define_method(SwigClassVectorpRing.klass, "select", VALUEFUNC(_wrap_VectorpRing_select), -1);
  rb_define_method(SwigClassVectorpRing.klass, "reject_bang", VALUEFUNC(_wrap_VectorpRing_reject_bang), -1);
  rb_define_alias(SwigClassVectorpRing.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorpRing.klass, "delete_at", VALUEFUNC(_wrap_VectorpRing_delete_at), -1);
  rb_define_method(SwigClassVectorpRing.klass, "__delete_2__", VALUEFUNC(_wrap_VectorpRing___delete_2__), -1);
  rb_define_method(SwigClassVectorpRing.klass, "[]", VALUEFUNC(_wrap_VectorpRing___getitem__), -1);
  rb_define_method(SwigClassVectorpRing.klass, "[]=", VALUEFUNC(_wrap_VectorpRing___setitem__), -1);
  rb_define_method(SwigClassVectorpRing.klass, "shift", VALUEFUNC(_wrap_VectorpRing_shift), -1);
  rb_define_method(SwigClassVectorpRing.klass, "unshift", VALUEFUNC(_wrap_VectorpRing_unshift), -1);
  rb_define_method(SwigClassVectorpRing.klass, "empty", VALUEFUNC(_wrap_VectorpRing_empty), -1);
  rb_define_method(SwigClassVectorpRing.klass, "size", VALUEFUNC(_wrap_VectorpRing_size), -1);
  rb_define_method(SwigClassVectorpRing.klass, "clear", VALUEFUNC(_wrap_VectorpRing_clear), -1);
  rb_define_method(SwigClassVectorpRing.klass, "swap", VALUEFUNC(_wrap_VectorpRing_swap), -1);
  rb_define_method(SwigClassVectorpRing.klass, "get_allocator", VALUEFUNC(_wrap_VectorpRing_get_allocator), -1);
  rb_define_method(SwigClassVectorpRing.klass, "begin", VALUEFUNC(_wrap_VectorpRing_begin), -1);
  rb_define_method(SwigClassVectorpRing.klass, "end", VALUEFUNC(_wrap_VectorpRing_end), -1);
  rb_define_method(SwigClassVectorpRing.klass, "rbegin", VALUEFUNC(_wrap_VectorpRing_rbegin), -1);
  rb_define_method(SwigClassVectorpRing.klass, "rend", VALUEFUNC(_wrap_VectorpRing_rend), -1);
  rb_define_method(SwigClassVectorpRing.klass, "erase", VALUEFUNC(_wrap_VectorpRing_erase), -1);
  rb_define_method(SwigClassVectorpRing.klass, "front", VALUEFUNC(_wrap_VectorpRing_front), -1);
  rb_define_method(SwigClassVectorpRing.klass, "back", VALUEFUNC(_wrap_VectorpRing_back), -1);
  rb_define_method(SwigClassVectorpRing.klass, "assign", VALUEFUNC(_wrap_VectorpRing_assign), -1);
  rb_define_method(SwigClassVectorpRing.klass, "resize", VALUEFUNC(_wrap_VectorpRing_resize), -1);
  rb_define_method(SwigClassVectorpRing.klass, "insert", VALUEFUNC(_wrap_VectorpRing_insert), -1);
  rb_define_method(SwigClassVectorpRing.klass, "reserve", VALUEFUNC(_wrap_VectorpRing_reserve), -1);
  rb_define_method(SwigClassVectorpRing.klass, "capacity", VALUEFUNC(_wrap_VectorpRing_capacity), -1);
  SwigClassVectorpRing.mark = 0;
  SwigClassVectorpRing.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBRing_Sm__Sg_;
  SwigClassVectorpRing.trackObjects = 0;
  
  SwigClassVectorGenericData.klass = rb_define_class_under(mOpenBabel, "VectorGenericData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_std__vectorT_OpenBabel__OBGenericData_p_std__allocatorT_OpenBabel__OBGenericData_p_t_t, (void *) &SwigClassVectorGenericData);
  rb_define_alloc_func(SwigClassVectorGenericData.klass, _wrap_VectorGenericData_allocate);
  rb_define_method(SwigClassVectorGenericData.klass, "initialize", VALUEFUNC(_wrap_new_VectorGenericData), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "dup", VALUEFUNC(_wrap_VectorGenericData_dup), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "inspect", VALUEFUNC(_wrap_VectorGenericData_inspect), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "to_a", VALUEFUNC(_wrap_VectorGenericData_to_a), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "to_s", VALUEFUNC(_wrap_VectorGenericData_to_s), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "slice", VALUEFUNC(_wrap_VectorGenericData_slice), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "each", VALUEFUNC(_wrap_VectorGenericData_each), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "select", VALUEFUNC(_wrap_VectorGenericData_select), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "reject_bang", VALUEFUNC(_wrap_VectorGenericData_reject_bang), -1);
  rb_define_alias(SwigClassVectorGenericData.klass, "delete_if", "reject_bang");
  rb_define_method(SwigClassVectorGenericData.klass, "delete_at", VALUEFUNC(_wrap_VectorGenericData_delete_at), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "__delete_2__", VALUEFUNC(_wrap_VectorGenericData___delete_2__), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "[]", VALUEFUNC(_wrap_VectorGenericData___getitem__), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "[]=", VALUEFUNC(_wrap_VectorGenericData___setitem__), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "shift", VALUEFUNC(_wrap_VectorGenericData_shift), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "unshift", VALUEFUNC(_wrap_VectorGenericData_unshift), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "empty", VALUEFUNC(_wrap_VectorGenericData_empty), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "size", VALUEFUNC(_wrap_VectorGenericData_size), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "clear", VALUEFUNC(_wrap_VectorGenericData_clear), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "swap", VALUEFUNC(_wrap_VectorGenericData_swap), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "get_allocator", VALUEFUNC(_wrap_VectorGenericData_get_allocator), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "begin", VALUEFUNC(_wrap_VectorGenericData_begin), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "end", VALUEFUNC(_wrap_VectorGenericData_end), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "rbegin", VALUEFUNC(_wrap_VectorGenericData_rbegin), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "rend", VALUEFUNC(_wrap_VectorGenericData_rend), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "erase", VALUEFUNC(_wrap_VectorGenericData_erase), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "front", VALUEFUNC(_wrap_VectorGenericData_front), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "back", VALUEFUNC(_wrap_VectorGenericData_back), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "assign", VALUEFUNC(_wrap_VectorGenericData_assign), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "resize", VALUEFUNC(_wrap_VectorGenericData_resize), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "insert", VALUEFUNC(_wrap_VectorGenericData_insert), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "reserve", VALUEFUNC(_wrap_VectorGenericData_reserve), -1);
  rb_define_method(SwigClassVectorGenericData.klass, "capacity", VALUEFUNC(_wrap_VectorGenericData_capacity), -1);
  SwigClassVectorGenericData.mark = 0;
  SwigClassVectorGenericData.destroy = (void (*)(void *)) free_std_vector_Sl_OpenBabel_OBGenericData_Sm__Sg_;
  SwigClassVectorGenericData.trackObjects = 0;
  rb_define_module_function(mOpenBabel, "to_pair_data", VALUEFUNC(_wrap_to_pair_data), -1);
  rb_define_module_function(mOpenBabel, "to_unit_cell", VALUEFUNC(_wrap_to_unit_cell), -1);
  
  SwigClassOBGlobalDataBase.klass = rb_define_class_under(mOpenBabel, "OBGlobalDataBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGlobalDataBase, (void *) &SwigClassOBGlobalDataBase);
  rb_define_alloc_func(SwigClassOBGlobalDataBase.klass, _wrap_OBGlobalDataBase_allocate);
  rb_define_method(SwigClassOBGlobalDataBase.klass, "initialize", VALUEFUNC(_wrap_new_OBGlobalDataBase), -1);
  rb_define_method(SwigClassOBGlobalDataBase.klass, "init", VALUEFUNC(_wrap_OBGlobalDataBase_init), -1);
  rb_define_method(SwigClassOBGlobalDataBase.klass, "get_size", VALUEFUNC(_wrap_OBGlobalDataBase_get_size), -1);
  rb_define_method(SwigClassOBGlobalDataBase.klass, "set_read_directory", VALUEFUNC(_wrap_OBGlobalDataBase_set_read_directory), -1);
  rb_define_method(SwigClassOBGlobalDataBase.klass, "set_environment_variable", VALUEFUNC(_wrap_OBGlobalDataBase_set_environment_variable), -1);
  rb_define_method(SwigClassOBGlobalDataBase.klass, "parse_line", VALUEFUNC(_wrap_OBGlobalDataBase_parse_line), -1);
  SwigClassOBGlobalDataBase.mark = 0;
  SwigClassOBGlobalDataBase.destroy = (void (*)(void *)) free_OpenBabel_OBGlobalDataBase;
  SwigClassOBGlobalDataBase.trackObjects = 0;
  
  SwigClassOBElement.klass = rb_define_class_under(mOpenBabel, "OBElement", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBElement, (void *) &SwigClassOBElement);
  rb_define_alloc_func(SwigClassOBElement.klass, _wrap_OBElement_allocate);
  rb_define_method(SwigClassOBElement.klass, "initialize", VALUEFUNC(_wrap_new_OBElement), -1);
  rb_define_method(SwigClassOBElement.klass, "get_atomic_num", VALUEFUNC(_wrap_OBElement_get_atomic_num), -1);
  rb_define_method(SwigClassOBElement.klass, "get_symbol", VALUEFUNC(_wrap_OBElement_get_symbol), -1);
  rb_define_method(SwigClassOBElement.klass, "get_covalent_rad", VALUEFUNC(_wrap_OBElement_get_covalent_rad), -1);
  rb_define_method(SwigClassOBElement.klass, "get_vdw_rad", VALUEFUNC(_wrap_OBElement_get_vdw_rad), -1);
  rb_define_method(SwigClassOBElement.klass, "get_mass", VALUEFUNC(_wrap_OBElement_get_mass), -1);
  rb_define_method(SwigClassOBElement.klass, "get_max_bonds", VALUEFUNC(_wrap_OBElement_get_max_bonds), -1);
  rb_define_method(SwigClassOBElement.klass, "get_electro_neg", VALUEFUNC(_wrap_OBElement_get_electro_neg), -1);
  rb_define_method(SwigClassOBElement.klass, "get_allred_rochow_electro_neg", VALUEFUNC(_wrap_OBElement_get_allred_rochow_electro_neg), -1);
  rb_define_method(SwigClassOBElement.klass, "get_ionization", VALUEFUNC(_wrap_OBElement_get_ionization), -1);
  rb_define_method(SwigClassOBElement.klass, "get_electron_affinity", VALUEFUNC(_wrap_OBElement_get_electron_affinity), -1);
  rb_define_method(SwigClassOBElement.klass, "get_name", VALUEFUNC(_wrap_OBElement_get_name), -1);
  rb_define_method(SwigClassOBElement.klass, "get_red", VALUEFUNC(_wrap_OBElement_get_red), -1);
  rb_define_method(SwigClassOBElement.klass, "get_green", VALUEFUNC(_wrap_OBElement_get_green), -1);
  rb_define_method(SwigClassOBElement.klass, "get_blue", VALUEFUNC(_wrap_OBElement_get_blue), -1);
  SwigClassOBElement.mark = 0;
  SwigClassOBElement.destroy = (void (*)(void *)) free_OpenBabel_OBElement;
  SwigClassOBElement.trackObjects = 0;
  
  SwigClassOBElementTable.klass = rb_define_class_under(mOpenBabel, "OBElementTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBElementTable, (void *) &SwigClassOBElementTable);
  rb_define_alloc_func(SwigClassOBElementTable.klass, _wrap_OBElementTable_allocate);
  rb_define_method(SwigClassOBElementTable.klass, "initialize", VALUEFUNC(_wrap_new_OBElementTable), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_number_of_elements", VALUEFUNC(_wrap_OBElementTable_get_number_of_elements), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_atomic_num", VALUEFUNC(_wrap_OBElementTable_get_atomic_num), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_symbol", VALUEFUNC(_wrap_OBElementTable_get_symbol), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_vdw_rad", VALUEFUNC(_wrap_OBElementTable_get_vdw_rad), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_covalent_rad", VALUEFUNC(_wrap_OBElementTable_get_covalent_rad), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_mass", VALUEFUNC(_wrap_OBElementTable_get_mass), -1);
  rb_define_method(SwigClassOBElementTable.klass, "corrected_bond_rad", VALUEFUNC(_wrap_OBElementTable_corrected_bond_rad), -1);
  rb_define_method(SwigClassOBElementTable.klass, "corrected_vdw_rad", VALUEFUNC(_wrap_OBElementTable_corrected_vdw_rad), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_max_bonds", VALUEFUNC(_wrap_OBElementTable_get_max_bonds), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_electro_neg", VALUEFUNC(_wrap_OBElementTable_get_electro_neg), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_allred_rochow_electro_neg", VALUEFUNC(_wrap_OBElementTable_get_allred_rochow_electro_neg), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_ionization", VALUEFUNC(_wrap_OBElementTable_get_ionization), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_electron_affinity", VALUEFUNC(_wrap_OBElementTable_get_electron_affinity), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_rgb", VALUEFUNC(_wrap_OBElementTable_get_rgb), -1);
  rb_define_method(SwigClassOBElementTable.klass, "get_name", VALUEFUNC(_wrap_OBElementTable_get_name), -1);
  SwigClassOBElementTable.mark = 0;
  SwigClassOBElementTable.destroy = (void (*)(void *)) free_OpenBabel_OBElementTable;
  SwigClassOBElementTable.trackObjects = 0;
  
  SwigClassOBIsotopeTable.klass = rb_define_class_under(mOpenBabel, "OBIsotopeTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBIsotopeTable, (void *) &SwigClassOBIsotopeTable);
  rb_define_alloc_func(SwigClassOBIsotopeTable.klass, _wrap_OBIsotopeTable_allocate);
  rb_define_method(SwigClassOBIsotopeTable.klass, "initialize", VALUEFUNC(_wrap_new_OBIsotopeTable), -1);
  rb_define_method(SwigClassOBIsotopeTable.klass, "get_exact_mass", VALUEFUNC(_wrap_OBIsotopeTable_get_exact_mass), -1);
  SwigClassOBIsotopeTable.mark = 0;
  SwigClassOBIsotopeTable.destroy = (void (*)(void *)) free_OpenBabel_OBIsotopeTable;
  SwigClassOBIsotopeTable.trackObjects = 0;
  
  SwigClassOBTypeTable.klass = rb_define_class_under(mOpenBabel, "OBTypeTable", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTypeTable, (void *) &SwigClassOBTypeTable);
  rb_define_alloc_func(SwigClassOBTypeTable.klass, _wrap_OBTypeTable_allocate);
  rb_define_method(SwigClassOBTypeTable.klass, "initialize", VALUEFUNC(_wrap_new_OBTypeTable), -1);
  rb_define_method(SwigClassOBTypeTable.klass, "set_from_type", VALUEFUNC(_wrap_OBTypeTable_set_from_type), -1);
  rb_define_method(SwigClassOBTypeTable.klass, "set_to_type", VALUEFUNC(_wrap_OBTypeTable_set_to_type), -1);
  rb_define_method(SwigClassOBTypeTable.klass, "translate", VALUEFUNC(_wrap_OBTypeTable_translate), -1);
  rb_define_method(SwigClassOBTypeTable.klass, "get_from_type", VALUEFUNC(_wrap_OBTypeTable_get_from_type), -1);
  rb_define_method(SwigClassOBTypeTable.klass, "get_to_type", VALUEFUNC(_wrap_OBTypeTable_get_to_type), -1);
  SwigClassOBTypeTable.mark = 0;
  SwigClassOBTypeTable.destroy = (void (*)(void *)) free_OpenBabel_OBTypeTable;
  SwigClassOBTypeTable.trackObjects = 0;
  
  SwigClassOBResidueData.klass = rb_define_class_under(mOpenBabel, "OBResidueData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGlobalDataBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueData, (void *) &SwigClassOBResidueData);
  rb_define_alloc_func(SwigClassOBResidueData.klass, _wrap_OBResidueData_allocate);
  rb_define_method(SwigClassOBResidueData.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueData), -1);
  rb_define_method(SwigClassOBResidueData.klass, "set_res_name", VALUEFUNC(_wrap_OBResidueData_set_res_name), -1);
  rb_define_method(SwigClassOBResidueData.klass, "lookup_bo", VALUEFUNC(_wrap_OBResidueData_lookup_bo), -1);
  rb_define_method(SwigClassOBResidueData.klass, "lookup_type", VALUEFUNC(_wrap_OBResidueData_lookup_type), -1);
  rb_define_method(SwigClassOBResidueData.klass, "assign_bonds", VALUEFUNC(_wrap_OBResidueData_assign_bonds), -1);
  SwigClassOBResidueData.mark = 0;
  SwigClassOBResidueData.destroy = (void (*)(void *)) free_OpenBabel_OBResidueData;
  SwigClassOBResidueData.trackObjects = 0;
  
  SwigClassDoubleType.klass = rb_define_class_under(mOpenBabel, "DoubleType", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__DoubleType, (void *) &SwigClassDoubleType);
  rb_define_alloc_func(SwigClassDoubleType.klass, _wrap_DoubleType_allocate);
  rb_define_method(SwigClassDoubleType.klass, "initialize", VALUEFUNC(_wrap_new_DoubleType), -1);
  rb_define_method(SwigClassDoubleType.klass, "hi=", VALUEFUNC(_wrap_DoubleType_hi_set), -1);
  rb_define_method(SwigClassDoubleType.klass, "hi", VALUEFUNC(_wrap_DoubleType_hi_get), -1);
  rb_define_method(SwigClassDoubleType.klass, "lo=", VALUEFUNC(_wrap_DoubleType_lo_set), -1);
  rb_define_method(SwigClassDoubleType.klass, "lo", VALUEFUNC(_wrap_DoubleType_lo_get), -1);
  SwigClassDoubleType.mark = 0;
  SwigClassDoubleType.destroy = (void (*)(void *)) free_OpenBabel_DoubleType;
  SwigClassDoubleType.trackObjects = 0;
  rb_define_module_function(mOpenBabel, "double_multiply", VALUEFUNC(_wrap_double_multiply), -1);
  rb_define_module_function(mOpenBabel, "double_add", VALUEFUNC(_wrap_double_add), -1);
  rb_define_module_function(mOpenBabel, "double_modulus", VALUEFUNC(_wrap_double_modulus), -1);
  
  SwigClassOBRandom.klass = rb_define_class_under(mOpenBabel, "OBRandom", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRandom, (void *) &SwigClassOBRandom);
  rb_define_alloc_func(SwigClassOBRandom.klass, _wrap_OBRandom_allocate);
  rb_define_method(SwigClassOBRandom.klass, "initialize", VALUEFUNC(_wrap_new_OBRandom), -1);
  rb_define_method(SwigClassOBRandom.klass, "seed", VALUEFUNC(_wrap_OBRandom_seed), -1);
  rb_define_method(SwigClassOBRandom.klass, "time_seed", VALUEFUNC(_wrap_OBRandom_time_seed), -1);
  rb_define_method(SwigClassOBRandom.klass, "next_int", VALUEFUNC(_wrap_OBRandom_next_int), -1);
  rb_define_method(SwigClassOBRandom.klass, "next_float", VALUEFUNC(_wrap_OBRandom_next_float), -1);
  SwigClassOBRandom.mark = 0;
  SwigClassOBRandom.destroy = (void (*)(void *)) free_OpenBabel_OBRandom;
  SwigClassOBRandom.trackObjects = 0;
  rb_define_const(mOpenBabel, "M_PI", SWIG_From_double(static_cast< double >(3.14159265358979323846)));
  
  SwigClassOBStopwatch.klass = rb_define_class_under(mOpenBabel, "OBStopwatch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBStopwatch, (void *) &SwigClassOBStopwatch);
  rb_define_alloc_func(SwigClassOBStopwatch.klass, _wrap_OBStopwatch_allocate);
  rb_define_method(SwigClassOBStopwatch.klass, "initialize", VALUEFUNC(_wrap_new_OBStopwatch), -1);
  rb_define_method(SwigClassOBStopwatch.klass, "start", VALUEFUNC(_wrap_OBStopwatch_start), -1);
  rb_define_method(SwigClassOBStopwatch.klass, "lap", VALUEFUNC(_wrap_OBStopwatch_lap), -1);
  rb_define_method(SwigClassOBStopwatch.klass, "elapsed", VALUEFUNC(_wrap_OBStopwatch_elapsed), -1);
  SwigClassOBStopwatch.mark = 0;
  SwigClassOBStopwatch.destroy = (void (*)(void *)) free_OpenBabel_OBStopwatch;
  SwigClassOBStopwatch.trackObjects = 0;
  
  SwigClassOBSqrtTbl.klass = rb_define_class_under(mOpenBabel, "OBSqrtTbl", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSqrtTbl, (void *) &SwigClassOBSqrtTbl);
  rb_define_alloc_func(SwigClassOBSqrtTbl.klass, _wrap_OBSqrtTbl_allocate);
  rb_define_method(SwigClassOBSqrtTbl.klass, "initialize", VALUEFUNC(_wrap_new_OBSqrtTbl), -1);
  rb_define_method(SwigClassOBSqrtTbl.klass, "sqrt", VALUEFUNC(_wrap_OBSqrtTbl_sqrt), -1);
  rb_define_method(SwigClassOBSqrtTbl.klass, "init", VALUEFUNC(_wrap_OBSqrtTbl_init), -1);
  SwigClassOBSqrtTbl.mark = 0;
  SwigClassOBSqrtTbl.destroy = (void (*)(void *)) free_OpenBabel_OBSqrtTbl;
  SwigClassOBSqrtTbl.trackObjects = 0;
  rb_define_const(mOpenBabel, "RAD_TO_DEG", SWIG_From_double(static_cast< double >((180.0/3.14159265358979323846))));
  rb_define_const(mOpenBabel, "DEG_TO_RAD", SWIG_From_double(static_cast< double >((3.14159265358979323846/180.0))));
  
  SwigClassVector3.klass = rb_define_class_under(mOpenBabel, "Vector3", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__vector3, (void *) &SwigClassVector3);
  rb_define_alloc_func(SwigClassVector3.klass, _wrap_Vector3_allocate);
  rb_define_method(SwigClassVector3.klass, "initialize", VALUEFUNC(_wrap_new_Vector3), -1);
  rb_define_method(SwigClassVector3.klass, "set", VALUEFUNC(_wrap_Vector3_set), -1);
  rb_define_method(SwigClassVector3.klass, "set_x", VALUEFUNC(_wrap_Vector3_set_x), -1);
  rb_define_method(SwigClassVector3.klass, "set_y", VALUEFUNC(_wrap_Vector3_set_y), -1);
  rb_define_method(SwigClassVector3.klass, "set_z", VALUEFUNC(_wrap_Vector3_set_z), -1);
  rb_define_method(SwigClassVector3.klass, "get", VALUEFUNC(_wrap_Vector3_get), -1);
  rb_define_method(SwigClassVector3.klass, "as_array", VALUEFUNC(_wrap_Vector3_as_array), -1);
  rb_define_method(SwigClassVector3.klass, "random_unit_vector", VALUEFUNC(_wrap_Vector3_random_unit_vector), -1);
  rb_define_method(SwigClassVector3.klass, "normalize", VALUEFUNC(_wrap_Vector3_normalize), -1);
  rb_define_method(SwigClassVector3.klass, "can_be_normalized", VALUEFUNC(_wrap_Vector3_can_be_normalized), -1);
  rb_define_method(SwigClassVector3.klass, "length_2", VALUEFUNC(_wrap_Vector3_length_2), -1);
  rb_define_method(SwigClassVector3.klass, "length", VALUEFUNC(_wrap_Vector3_length), -1);
  rb_define_method(SwigClassVector3.klass, "x", VALUEFUNC(_wrap_Vector3_x), -1);
  rb_define_method(SwigClassVector3.klass, "y", VALUEFUNC(_wrap_Vector3_y), -1);
  rb_define_method(SwigClassVector3.klass, "z", VALUEFUNC(_wrap_Vector3_z), -1);
  rb_define_method(SwigClassVector3.klass, "==", VALUEFUNC(_wrap_Vector3___eq__), -1);
  rb_define_method(SwigClassVector3.klass, "is_approx", VALUEFUNC(_wrap_Vector3_is_approx), -1);
  rb_define_method(SwigClassVector3.klass, "dist_sq", VALUEFUNC(_wrap_Vector3_dist_sq), -1);
  rb_define_method(SwigClassVector3.klass, "create_ortho_vector", VALUEFUNC(_wrap_Vector3_create_ortho_vector), -1);
  SwigClassVector3.mark = 0;
  SwigClassVector3.destroy = (void (*)(void *)) free_OpenBabel_vector3;
  SwigClassVector3.trackObjects = 0;
  rb_define_module_function(mOpenBabel, "<<", VALUEFUNC(_wrap___lshift__), -1);
  rb_define_module_function(mOpenBabel, "+", VALUEFUNC(_wrap___add__), -1);
  rb_define_module_function(mOpenBabel, "-", VALUEFUNC(_wrap___sub__), -1);
  rb_define_module_function(mOpenBabel, "/", VALUEFUNC(_wrap___div__), -1);
  rb_define_module_function(mOpenBabel, "*", VALUEFUNC(_wrap___mul__), -1);
  rb_define_module_function(mOpenBabel, "dot", VALUEFUNC(_wrap_dot), -1);
  rb_define_module_function(mOpenBabel, "cross", VALUEFUNC(_wrap_cross), -1);
  rb_define_module_function(mOpenBabel, "vector_angle", VALUEFUNC(_wrap_vector_angle), -1);
  rb_define_module_function(mOpenBabel, "calc_torsion_angle", VALUEFUNC(_wrap_calc_torsion_angle), -1);
  rb_define_module_function(mOpenBabel, "point_2plane", VALUEFUNC(_wrap_point_2plane), -1);
  rb_define_module_function(mOpenBabel, "point_2plane_angle", VALUEFUNC(_wrap_point_2plane_angle), -1);
  rb_define_singleton_method(mOpenBabel, "VZero", VALUEFUNC(_wrap_VZero_get), 0);
  rb_define_singleton_method(mOpenBabel, "VX", VALUEFUNC(_wrap_VX_get), 0);
  rb_define_singleton_method(mOpenBabel, "VY", VALUEFUNC(_wrap_VY_get), 0);
  rb_define_singleton_method(mOpenBabel, "VZ", VALUEFUNC(_wrap_VZ_get), 0);
  rb_define_const(mOpenBabel, "UndefinedData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::UndefinedData)));
  rb_define_const(mOpenBabel, "PairData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::PairData)));
  rb_define_const(mOpenBabel, "EnergyData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::EnergyData)));
  rb_define_const(mOpenBabel, "CommentData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CommentData)));
  rb_define_const(mOpenBabel, "ConformerData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ConformerData)));
  rb_define_const(mOpenBabel, "ExternalBondData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ExternalBondData)));
  rb_define_const(mOpenBabel, "RotamerList", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RotamerList)));
  rb_define_const(mOpenBabel, "VirtualBondData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VirtualBondData)));
  rb_define_const(mOpenBabel, "RingData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RingData)));
  rb_define_const(mOpenBabel, "TorsionData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::TorsionData)));
  rb_define_const(mOpenBabel, "AngleData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::AngleData)));
  rb_define_const(mOpenBabel, "SerialNums", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SerialNums)));
  rb_define_const(mOpenBabel, "UnitCell", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::UnitCell)));
  rb_define_const(mOpenBabel, "SpinData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SpinData)));
  rb_define_const(mOpenBabel, "ChargeData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ChargeData)));
  rb_define_const(mOpenBabel, "SymmetryData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SymmetryData)));
  rb_define_const(mOpenBabel, "ChiralData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ChiralData)));
  rb_define_const(mOpenBabel, "OccupationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::OccupationData)));
  rb_define_const(mOpenBabel, "DensityData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::DensityData)));
  rb_define_const(mOpenBabel, "ElectronicData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::ElectronicData)));
  rb_define_const(mOpenBabel, "VibrationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VibrationData)));
  rb_define_const(mOpenBabel, "RotationData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::RotationData)));
  rb_define_const(mOpenBabel, "NuclearData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::NuclearData)));
  rb_define_const(mOpenBabel, "SetData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::SetData)));
  rb_define_const(mOpenBabel, "GridData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::GridData)));
  rb_define_const(mOpenBabel, "VectorData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::VectorData)));
  rb_define_const(mOpenBabel, "MatrixData", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::MatrixData)));
  rb_define_const(mOpenBabel, "CustomData0", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData0)));
  rb_define_const(mOpenBabel, "CustomData1", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData1)));
  rb_define_const(mOpenBabel, "CustomData2", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData2)));
  rb_define_const(mOpenBabel, "CustomData3", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData3)));
  rb_define_const(mOpenBabel, "CustomData4", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData4)));
  rb_define_const(mOpenBabel, "CustomData5", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData5)));
  rb_define_const(mOpenBabel, "CustomData6", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData6)));
  rb_define_const(mOpenBabel, "CustomData7", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData7)));
  rb_define_const(mOpenBabel, "CustomData8", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData8)));
  rb_define_const(mOpenBabel, "CustomData9", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData9)));
  rb_define_const(mOpenBabel, "CustomData10", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData10)));
  rb_define_const(mOpenBabel, "CustomData11", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData11)));
  rb_define_const(mOpenBabel, "CustomData12", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData12)));
  rb_define_const(mOpenBabel, "CustomData13", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData13)));
  rb_define_const(mOpenBabel, "CustomData14", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData14)));
  rb_define_const(mOpenBabel, "CustomData15", SWIG_From_int(static_cast< int >(OpenBabel::OBGenericDataType::CustomData15)));
  rb_define_const(mOpenBabel, "Any", SWIG_From_int(static_cast< int >(OpenBabel::any)));
  rb_define_const(mOpenBabel, "FileformatInput", SWIG_From_int(static_cast< int >(OpenBabel::fileformatInput)));
  rb_define_const(mOpenBabel, "UserInput", SWIG_From_int(static_cast< int >(OpenBabel::userInput)));
  rb_define_const(mOpenBabel, "Perceived", SWIG_From_int(static_cast< int >(OpenBabel::perceived)));
  rb_define_const(mOpenBabel, "External", SWIG_From_int(static_cast< int >(OpenBabel::external)));
  
  SwigClassOBGenericData.klass = rb_define_class_under(mOpenBabel, "OBGenericData", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGenericData, (void *) &SwigClassOBGenericData);
  rb_define_alloc_func(SwigClassOBGenericData.klass, _wrap_OBGenericData_allocate);
  rb_define_method(SwigClassOBGenericData.klass, "initialize", VALUEFUNC(_wrap_new_OBGenericData), -1);
  rb_define_method(SwigClassOBGenericData.klass, "clone", VALUEFUNC(_wrap_OBGenericData_clone), -1);
  rb_define_method(SwigClassOBGenericData.klass, "set_attribute", VALUEFUNC(_wrap_OBGenericData_set_attribute), -1);
  rb_define_method(SwigClassOBGenericData.klass, "set_origin", VALUEFUNC(_wrap_OBGenericData_set_origin), -1);
  rb_define_method(SwigClassOBGenericData.klass, "get_attribute", VALUEFUNC(_wrap_OBGenericData_get_attribute), -1);
  rb_define_method(SwigClassOBGenericData.klass, "get_data_type", VALUEFUNC(_wrap_OBGenericData_get_data_type), -1);
  rb_define_method(SwigClassOBGenericData.klass, "get_value", VALUEFUNC(_wrap_OBGenericData_get_value), -1);
  rb_define_method(SwigClassOBGenericData.klass, "get_origin", VALUEFUNC(_wrap_OBGenericData_get_origin), -1);
  SwigClassOBGenericData.mark = 0;
  SwigClassOBGenericData.destroy = (void (*)(void *)) free_OpenBabel_OBGenericData;
  SwigClassOBGenericData.trackObjects = 0;
  
  SwigClassOBBase.klass = rb_define_class_under(mOpenBabel, "OBBase", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBBase, (void *) &SwigClassOBBase);
  rb_define_alloc_func(SwigClassOBBase.klass, _wrap_OBBase_allocate);
  rb_define_method(SwigClassOBBase.klass, "initialize", VALUEFUNC(_wrap_new_OBBase), -1);
  rb_define_method(SwigClassOBBase.klass, "clear", VALUEFUNC(_wrap_OBBase_clear), -1);
  rb_define_method(SwigClassOBBase.klass, "do_transformations", VALUEFUNC(_wrap_OBBase_do_transformations), -1);
  rb_define_singleton_method(SwigClassOBBase.klass, "class_description", VALUEFUNC(_wrap_OBBase_class_description), -1);
  rb_define_method(SwigClassOBBase.klass, "has_data", VALUEFUNC(_wrap_OBBase_has_data), -1);
  rb_define_method(SwigClassOBBase.klass, "delete_data", VALUEFUNC(_wrap_OBBase_delete_data), -1);
  rb_define_method(SwigClassOBBase.klass, "set_data", VALUEFUNC(_wrap_OBBase_set_data), -1);
  rb_define_method(SwigClassOBBase.klass, "clone_data", VALUEFUNC(_wrap_OBBase_clone_data), -1);
  rb_define_method(SwigClassOBBase.klass, "data_size", VALUEFUNC(_wrap_OBBase_data_size), -1);
  rb_define_method(SwigClassOBBase.klass, "get_all_data", VALUEFUNC(_wrap_OBBase_get_all_data), -1);
  rb_define_method(SwigClassOBBase.klass, "get_data", VALUEFUNC(_wrap_OBBase_get_data), -1);
  rb_define_method(SwigClassOBBase.klass, "begin_data", VALUEFUNC(_wrap_OBBase_begin_data), -1);
  rb_define_method(SwigClassOBBase.klass, "end_data", VALUEFUNC(_wrap_OBBase_end_data), -1);
  SwigClassOBBase.mark = 0;
  SwigClassOBBase.destroy = (void (*)(void *)) free_OpenBabel_OBBase;
  SwigClassOBBase.trackObjects = 0;
  
  SwigClassOBCommentData.klass = rb_define_class_under(mOpenBabel, "OBCommentData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBCommentData, (void *) &SwigClassOBCommentData);
  rb_define_alloc_func(SwigClassOBCommentData.klass, _wrap_OBCommentData_allocate);
  rb_define_method(SwigClassOBCommentData.klass, "initialize", VALUEFUNC(_wrap_new_OBCommentData), -1);
  rb_define_method(SwigClassOBCommentData.klass, "set_data", VALUEFUNC(_wrap_OBCommentData_set_data), -1);
  rb_define_method(SwigClassOBCommentData.klass, "get_data", VALUEFUNC(_wrap_OBCommentData_get_data), -1);
  SwigClassOBCommentData.mark = 0;
  SwigClassOBCommentData.destroy = (void (*)(void *)) free_OpenBabel_OBCommentData;
  SwigClassOBCommentData.trackObjects = 0;
  
  SwigClassOBExternalBond.klass = rb_define_class_under(mOpenBabel, "OBExternalBond", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBExternalBond, (void *) &SwigClassOBExternalBond);
  rb_define_alloc_func(SwigClassOBExternalBond.klass, _wrap_OBExternalBond_allocate);
  rb_define_method(SwigClassOBExternalBond.klass, "initialize", VALUEFUNC(_wrap_new_OBExternalBond), -1);
  rb_define_method(SwigClassOBExternalBond.klass, "get_idx", VALUEFUNC(_wrap_OBExternalBond_get_idx), -1);
  rb_define_method(SwigClassOBExternalBond.klass, "get_atom", VALUEFUNC(_wrap_OBExternalBond_get_atom), -1);
  rb_define_method(SwigClassOBExternalBond.klass, "get_bond", VALUEFUNC(_wrap_OBExternalBond_get_bond), -1);
  rb_define_method(SwigClassOBExternalBond.klass, "set_idx", VALUEFUNC(_wrap_OBExternalBond_set_idx), -1);
  rb_define_method(SwigClassOBExternalBond.klass, "set_atom", VALUEFUNC(_wrap_OBExternalBond_set_atom), -1);
  rb_define_method(SwigClassOBExternalBond.klass, "set_bond", VALUEFUNC(_wrap_OBExternalBond_set_bond), -1);
  SwigClassOBExternalBond.mark = 0;
  SwigClassOBExternalBond.destroy = (void (*)(void *)) free_OpenBabel_OBExternalBond;
  SwigClassOBExternalBond.trackObjects = 0;
  
  SwigClassOBExternalBondData.klass = rb_define_class_under(mOpenBabel, "OBExternalBondData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBExternalBondData, (void *) &SwigClassOBExternalBondData);
  rb_define_alloc_func(SwigClassOBExternalBondData.klass, _wrap_OBExternalBondData_allocate);
  rb_define_method(SwigClassOBExternalBondData.klass, "initialize", VALUEFUNC(_wrap_new_OBExternalBondData), -1);
  rb_define_method(SwigClassOBExternalBondData.klass, "set_data", VALUEFUNC(_wrap_OBExternalBondData_set_data), -1);
  rb_define_method(SwigClassOBExternalBondData.klass, "get_data", VALUEFUNC(_wrap_OBExternalBondData_get_data), -1);
  SwigClassOBExternalBondData.mark = 0;
  SwigClassOBExternalBondData.destroy = (void (*)(void *)) free_OpenBabel_OBExternalBondData;
  SwigClassOBExternalBondData.trackObjects = 0;
  
  SwigClassOBPairData.klass = rb_define_class_under(mOpenBabel, "OBPairData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBPairData, (void *) &SwigClassOBPairData);
  rb_define_alloc_func(SwigClassOBPairData.klass, _wrap_OBPairData_allocate);
  rb_define_method(SwigClassOBPairData.klass, "initialize", VALUEFUNC(_wrap_new_OBPairData), -1);
  rb_define_method(SwigClassOBPairData.klass, "set_value", VALUEFUNC(_wrap_OBPairData_set_value), -1);
  SwigClassOBPairData.mark = 0;
  SwigClassOBPairData.destroy = (void (*)(void *)) free_OpenBabel_OBPairData;
  SwigClassOBPairData.trackObjects = 0;
  
  SwigClassOBSetData.klass = rb_define_class_under(mOpenBabel, "OBSetData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSetData, (void *) &SwigClassOBSetData);
  rb_define_alloc_func(SwigClassOBSetData.klass, _wrap_OBSetData_allocate);
  rb_define_method(SwigClassOBSetData.klass, "initialize", VALUEFUNC(_wrap_new_OBSetData), -1);
  rb_define_method(SwigClassOBSetData.klass, "add_data", VALUEFUNC(_wrap_OBSetData_add_data), -1);
  rb_define_method(SwigClassOBSetData.klass, "set_data", VALUEFUNC(_wrap_OBSetData_set_data), -1);
  rb_define_method(SwigClassOBSetData.klass, "get_data", VALUEFUNC(_wrap_OBSetData_get_data), -1);
  rb_define_method(SwigClassOBSetData.klass, "get_begin", VALUEFUNC(_wrap_OBSetData_get_begin), -1);
  rb_define_method(SwigClassOBSetData.klass, "get_end", VALUEFUNC(_wrap_OBSetData_get_end), -1);
  rb_define_method(SwigClassOBSetData.klass, "delete_data", VALUEFUNC(_wrap_OBSetData_delete_data), -1);
  SwigClassOBSetData.mark = 0;
  SwigClassOBSetData.destroy = (void (*)(void *)) free_OpenBabel_OBSetData;
  SwigClassOBSetData.trackObjects = 0;
  
  SwigClassOBVirtualBond.klass = rb_define_class_under(mOpenBabel, "OBVirtualBond", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVirtualBond, (void *) &SwigClassOBVirtualBond);
  rb_define_alloc_func(SwigClassOBVirtualBond.klass, _wrap_OBVirtualBond_allocate);
  rb_define_method(SwigClassOBVirtualBond.klass, "initialize", VALUEFUNC(_wrap_new_OBVirtualBond), -1);
  rb_define_method(SwigClassOBVirtualBond.klass, "get_bgn", VALUEFUNC(_wrap_OBVirtualBond_get_bgn), -1);
  rb_define_method(SwigClassOBVirtualBond.klass, "get_end", VALUEFUNC(_wrap_OBVirtualBond_get_end), -1);
  rb_define_method(SwigClassOBVirtualBond.klass, "get_order", VALUEFUNC(_wrap_OBVirtualBond_get_order), -1);
  rb_define_method(SwigClassOBVirtualBond.klass, "get_stereo", VALUEFUNC(_wrap_OBVirtualBond_get_stereo), -1);
  SwigClassOBVirtualBond.mark = 0;
  SwigClassOBVirtualBond.destroy = (void (*)(void *)) free_OpenBabel_OBVirtualBond;
  SwigClassOBVirtualBond.trackObjects = 0;
  
  SwigClassOBRingData.klass = rb_define_class_under(mOpenBabel, "OBRingData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRingData, (void *) &SwigClassOBRingData);
  rb_define_alloc_func(SwigClassOBRingData.klass, _wrap_OBRingData_allocate);
  rb_define_method(SwigClassOBRingData.klass, "initialize", VALUEFUNC(_wrap_new_OBRingData), -1);
  rb_define_method(SwigClassOBRingData.klass, "set_data", VALUEFUNC(_wrap_OBRingData_set_data), -1);
  rb_define_method(SwigClassOBRingData.klass, "push_back", VALUEFUNC(_wrap_OBRingData_push_back), -1);
  rb_define_method(SwigClassOBRingData.klass, "get_data", VALUEFUNC(_wrap_OBRingData_get_data), -1);
  rb_define_method(SwigClassOBRingData.klass, "begin_rings", VALUEFUNC(_wrap_OBRingData_begin_rings), -1);
  rb_define_method(SwigClassOBRingData.klass, "end_rings", VALUEFUNC(_wrap_OBRingData_end_rings), -1);
  rb_define_method(SwigClassOBRingData.klass, "begin_ring", VALUEFUNC(_wrap_OBRingData_begin_ring), -1);
  rb_define_method(SwigClassOBRingData.klass, "next_ring", VALUEFUNC(_wrap_OBRingData_next_ring), -1);
  SwigClassOBRingData.mark = 0;
  SwigClassOBRingData.destroy = (void (*)(void *)) free_OpenBabel_OBRingData;
  SwigClassOBRingData.trackObjects = 0;
  
  SwigClassOBUnitCell.klass = rb_define_class_under(mOpenBabel, "OBUnitCell", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBUnitCell, (void *) &SwigClassOBUnitCell);
  rb_define_alloc_func(SwigClassOBUnitCell.klass, _wrap_OBUnitCell_allocate);
  rb_define_method(SwigClassOBUnitCell.klass, "initialize", VALUEFUNC(_wrap_new_OBUnitCell), -1);
  rb_define_const(SwigClassOBUnitCell.klass, "Undefined", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Undefined)));
  rb_define_const(SwigClassOBUnitCell.klass, "Triclinic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Triclinic)));
  rb_define_const(SwigClassOBUnitCell.klass, "Monoclinic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Monoclinic)));
  rb_define_const(SwigClassOBUnitCell.klass, "Orthorhombic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Orthorhombic)));
  rb_define_const(SwigClassOBUnitCell.klass, "Tetragonal", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Tetragonal)));
  rb_define_const(SwigClassOBUnitCell.klass, "Rhombohedral", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Rhombohedral)));
  rb_define_const(SwigClassOBUnitCell.klass, "Hexagonal", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Hexagonal)));
  rb_define_const(SwigClassOBUnitCell.klass, "Cubic", SWIG_From_int(static_cast< int >(OpenBabel::OBUnitCell::Cubic)));
  rb_define_method(SwigClassOBUnitCell.klass, "set_data", VALUEFUNC(_wrap_OBUnitCell_set_data), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "set_offset", VALUEFUNC(_wrap_OBUnitCell_set_offset), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "set_space_group", VALUEFUNC(_wrap_OBUnitCell_set_space_group), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "set_lattice_type", VALUEFUNC(_wrap_OBUnitCell_set_lattice_type), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "fill_unit_cell", VALUEFUNC(_wrap_OBUnitCell_fill_unit_cell), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_a", VALUEFUNC(_wrap_OBUnitCell_get_a), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_b", VALUEFUNC(_wrap_OBUnitCell_get_b), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_c", VALUEFUNC(_wrap_OBUnitCell_get_c), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_alpha", VALUEFUNC(_wrap_OBUnitCell_get_alpha), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_beta", VALUEFUNC(_wrap_OBUnitCell_get_beta), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_gamma", VALUEFUNC(_wrap_OBUnitCell_get_gamma), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_offset", VALUEFUNC(_wrap_OBUnitCell_get_offset), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_space_group", VALUEFUNC(_wrap_OBUnitCell_get_space_group), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_space_group_name", VALUEFUNC(_wrap_OBUnitCell_get_space_group_name), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_lattice_type", VALUEFUNC(_wrap_OBUnitCell_get_lattice_type), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_cell_vectors", VALUEFUNC(_wrap_OBUnitCell_get_cell_vectors), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_cell_matrix", VALUEFUNC(_wrap_OBUnitCell_get_cell_matrix), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_ortho_matrix", VALUEFUNC(_wrap_OBUnitCell_get_ortho_matrix), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_fractional_matrix", VALUEFUNC(_wrap_OBUnitCell_get_fractional_matrix), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_space_group_number", VALUEFUNC(_wrap_OBUnitCell_get_space_group_number), -1);
  rb_define_method(SwigClassOBUnitCell.klass, "get_cell_volume", VALUEFUNC(_wrap_OBUnitCell_get_cell_volume), -1);
  SwigClassOBUnitCell.mark = 0;
  SwigClassOBUnitCell.destroy = (void (*)(void *)) free_OpenBabel_OBUnitCell;
  SwigClassOBUnitCell.trackObjects = 0;
  
  SwigClassOBConformerData.klass = rb_define_class_under(mOpenBabel, "OBConformerData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBConformerData, (void *) &SwigClassOBConformerData);
  rb_define_alloc_func(SwigClassOBConformerData.klass, _wrap_OBConformerData_allocate);
  rb_define_method(SwigClassOBConformerData.klass, "initialize", VALUEFUNC(_wrap_new_OBConformerData), -1);
  rb_define_method(SwigClassOBConformerData.klass, "set_dimension", VALUEFUNC(_wrap_OBConformerData_set_dimension), -1);
  rb_define_method(SwigClassOBConformerData.klass, "set_energies", VALUEFUNC(_wrap_OBConformerData_set_energies), -1);
  rb_define_method(SwigClassOBConformerData.klass, "set_forces", VALUEFUNC(_wrap_OBConformerData_set_forces), -1);
  rb_define_method(SwigClassOBConformerData.klass, "set_velocities", VALUEFUNC(_wrap_OBConformerData_set_velocities), -1);
  rb_define_method(SwigClassOBConformerData.klass, "set_displacements", VALUEFUNC(_wrap_OBConformerData_set_displacements), -1);
  rb_define_method(SwigClassOBConformerData.klass, "set_data", VALUEFUNC(_wrap_OBConformerData_set_data), -1);
  rb_define_method(SwigClassOBConformerData.klass, "get_dimension", VALUEFUNC(_wrap_OBConformerData_get_dimension), -1);
  rb_define_method(SwigClassOBConformerData.klass, "get_energies", VALUEFUNC(_wrap_OBConformerData_get_energies), -1);
  rb_define_method(SwigClassOBConformerData.klass, "get_forces", VALUEFUNC(_wrap_OBConformerData_get_forces), -1);
  rb_define_method(SwigClassOBConformerData.klass, "get_velocities", VALUEFUNC(_wrap_OBConformerData_get_velocities), -1);
  rb_define_method(SwigClassOBConformerData.klass, "get_displacements", VALUEFUNC(_wrap_OBConformerData_get_displacements), -1);
  rb_define_method(SwigClassOBConformerData.klass, "get_data", VALUEFUNC(_wrap_OBConformerData_get_data), -1);
  SwigClassOBConformerData.mark = 0;
  SwigClassOBConformerData.destroy = (void (*)(void *)) free_OpenBabel_OBConformerData;
  SwigClassOBConformerData.trackObjects = 0;
  
  SwigClassOBSymmetryData.klass = rb_define_class_under(mOpenBabel, "OBSymmetryData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSymmetryData, (void *) &SwigClassOBSymmetryData);
  rb_define_alloc_func(SwigClassOBSymmetryData.klass, _wrap_OBSymmetryData_allocate);
  rb_define_method(SwigClassOBSymmetryData.klass, "initialize", VALUEFUNC(_wrap_new_OBSymmetryData), -1);
  rb_define_method(SwigClassOBSymmetryData.klass, "set_data", VALUEFUNC(_wrap_OBSymmetryData_set_data), -1);
  rb_define_method(SwigClassOBSymmetryData.klass, "set_point_group", VALUEFUNC(_wrap_OBSymmetryData_set_point_group), -1);
  rb_define_method(SwigClassOBSymmetryData.klass, "set_space_group", VALUEFUNC(_wrap_OBSymmetryData_set_space_group), -1);
  rb_define_method(SwigClassOBSymmetryData.klass, "get_point_group", VALUEFUNC(_wrap_OBSymmetryData_get_point_group), -1);
  rb_define_method(SwigClassOBSymmetryData.klass, "get_space_group", VALUEFUNC(_wrap_OBSymmetryData_get_space_group), -1);
  SwigClassOBSymmetryData.mark = 0;
  SwigClassOBSymmetryData.destroy = (void (*)(void *)) free_OpenBabel_OBSymmetryData;
  SwigClassOBSymmetryData.trackObjects = 0;
  
  SwigClassOBTorsion.klass = rb_define_class_under(mOpenBabel, "OBTorsion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTorsion, (void *) &SwigClassOBTorsion);
  rb_define_alloc_func(SwigClassOBTorsion.klass, _wrap_OBTorsion_allocate);
  rb_define_method(SwigClassOBTorsion.klass, "initialize", VALUEFUNC(_wrap_new_OBTorsion), -1);
  rb_define_method(SwigClassOBTorsion.klass, "clear", VALUEFUNC(_wrap_OBTorsion_clear), -1);
  rb_define_method(SwigClassOBTorsion.klass, "empty", VALUEFUNC(_wrap_OBTorsion_empty), -1);
  rb_define_method(SwigClassOBTorsion.klass, "add_torsion", VALUEFUNC(_wrap_OBTorsion_add_torsion), -1);
  rb_define_method(SwigClassOBTorsion.klass, "set_angle", VALUEFUNC(_wrap_OBTorsion_set_angle), -1);
  rb_define_method(SwigClassOBTorsion.klass, "set_data", VALUEFUNC(_wrap_OBTorsion_set_data), -1);
  rb_define_method(SwigClassOBTorsion.klass, "get_angle", VALUEFUNC(_wrap_OBTorsion_get_angle), -1);
  rb_define_method(SwigClassOBTorsion.klass, "get_bond_idx", VALUEFUNC(_wrap_OBTorsion_get_bond_idx), -1);
  rb_define_method(SwigClassOBTorsion.klass, "get_size", VALUEFUNC(_wrap_OBTorsion_get_size), -1);
  rb_define_method(SwigClassOBTorsion.klass, "get_bc", VALUEFUNC(_wrap_OBTorsion_get_bc), -1);
  rb_define_method(SwigClassOBTorsion.klass, "get_ads", VALUEFUNC(_wrap_OBTorsion_get_ads), -1);
  rb_define_method(SwigClassOBTorsion.klass, "is_proton_rotor", VALUEFUNC(_wrap_OBTorsion_is_proton_rotor), -1);
  SwigClassOBTorsion.mark = 0;
  SwigClassOBTorsion.destroy = (void (*)(void *)) free_OpenBabel_OBTorsion;
  SwigClassOBTorsion.trackObjects = 0;
  
  SwigClassOBTorsionData.klass = rb_define_class_under(mOpenBabel, "OBTorsionData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBTorsionData, (void *) &SwigClassOBTorsionData);
  rb_undef_alloc_func(SwigClassOBTorsionData.klass);
  rb_define_method(SwigClassOBTorsionData.klass, "clear", VALUEFUNC(_wrap_OBTorsionData_clear), -1);
  rb_define_method(SwigClassOBTorsionData.klass, "get_data", VALUEFUNC(_wrap_OBTorsionData_get_data), -1);
  rb_define_method(SwigClassOBTorsionData.klass, "get_size", VALUEFUNC(_wrap_OBTorsionData_get_size), -1);
  rb_define_method(SwigClassOBTorsionData.klass, "set_data", VALUEFUNC(_wrap_OBTorsionData_set_data), -1);
  rb_define_method(SwigClassOBTorsionData.klass, "fill_torsion_array", VALUEFUNC(_wrap_OBTorsionData_fill_torsion_array), -1);
  SwigClassOBTorsionData.mark = 0;
  SwigClassOBTorsionData.destroy = (void (*)(void *)) free_OpenBabel_OBTorsionData;
  SwigClassOBTorsionData.trackObjects = 0;
  
  SwigClassOBAngle.klass = rb_define_class_under(mOpenBabel, "OBAngle", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAngle, (void *) &SwigClassOBAngle);
  rb_define_alloc_func(SwigClassOBAngle.klass, _wrap_OBAngle_allocate);
  rb_define_method(SwigClassOBAngle.klass, "initialize", VALUEFUNC(_wrap_new_OBAngle), -1);
  rb_define_method(SwigClassOBAngle.klass, "==", VALUEFUNC(_wrap_OBAngle___eq__), -1);
  rb_define_method(SwigClassOBAngle.klass, "clear", VALUEFUNC(_wrap_OBAngle_clear), -1);
  rb_define_method(SwigClassOBAngle.klass, "get_angle", VALUEFUNC(_wrap_OBAngle_get_angle), -1);
  rb_define_method(SwigClassOBAngle.klass, "set_angle", VALUEFUNC(_wrap_OBAngle_set_angle), -1);
  rb_define_method(SwigClassOBAngle.klass, "set_atoms", VALUEFUNC(_wrap_OBAngle_set_atoms), -1);
  SwigClassOBAngle.mark = 0;
  SwigClassOBAngle.destroy = (void (*)(void *)) free_OpenBabel_OBAngle;
  SwigClassOBAngle.trackObjects = 0;
  
  SwigClassOBAngleData.klass = rb_define_class_under(mOpenBabel, "OBAngleData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAngleData, (void *) &SwigClassOBAngleData);
  rb_undef_alloc_func(SwigClassOBAngleData.klass);
  rb_define_method(SwigClassOBAngleData.klass, "clear", VALUEFUNC(_wrap_OBAngleData_clear), -1);
  rb_define_method(SwigClassOBAngleData.klass, "fill_angle_array", VALUEFUNC(_wrap_OBAngleData_fill_angle_array), -1);
  rb_define_method(SwigClassOBAngleData.klass, "set_data", VALUEFUNC(_wrap_OBAngleData_set_data), -1);
  rb_define_method(SwigClassOBAngleData.klass, "get_size", VALUEFUNC(_wrap_OBAngleData_get_size), -1);
  SwigClassOBAngleData.mark = 0;
  SwigClassOBAngleData.destroy = (void (*)(void *)) free_OpenBabel_OBAngleData;
  SwigClassOBAngleData.trackObjects = 0;
  rb_define_const(mOpenBabel, "Output", SWIG_From_int(static_cast< int >(OpenBabel::output)));
  rb_define_const(mOpenBabel, "Input", SWIG_From_int(static_cast< int >(OpenBabel::input)));
  rb_define_const(mOpenBabel, "Calcvolume", SWIG_From_int(static_cast< int >(OpenBabel::calcvolume)));
  
  SwigClassOBChiralData.klass = rb_define_class_under(mOpenBabel, "OBChiralData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBChiralData, (void *) &SwigClassOBChiralData);
  rb_define_alloc_func(SwigClassOBChiralData.klass, _wrap_OBChiralData_allocate);
  rb_define_method(SwigClassOBChiralData.klass, "initialize", VALUEFUNC(_wrap_new_OBChiralData), -1);
  rb_define_method(SwigClassOBChiralData.klass, "clear", VALUEFUNC(_wrap_OBChiralData_clear), -1);
  rb_define_method(SwigClassOBChiralData.klass, "get_atom_4refs", VALUEFUNC(_wrap_OBChiralData_get_atom_4refs), -1);
  rb_define_method(SwigClassOBChiralData.klass, "get_atom_ref", VALUEFUNC(_wrap_OBChiralData_get_atom_ref), -1);
  rb_define_method(SwigClassOBChiralData.klass, "set_atom_4refs", VALUEFUNC(_wrap_OBChiralData_set_atom_4refs), -1);
  rb_define_method(SwigClassOBChiralData.klass, "add_atom_ref", VALUEFUNC(_wrap_OBChiralData_add_atom_ref), -1);
  rb_define_method(SwigClassOBChiralData.klass, "get_size", VALUEFUNC(_wrap_OBChiralData_get_size), -1);
  SwigClassOBChiralData.mark = 0;
  SwigClassOBChiralData.destroy = (void (*)(void *)) free_OpenBabel_OBChiralData;
  SwigClassOBChiralData.trackObjects = 0;
  
  SwigClassOBSerialNums.klass = rb_define_class_under(mOpenBabel, "OBSerialNums", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSerialNums, (void *) &SwigClassOBSerialNums);
  rb_define_alloc_func(SwigClassOBSerialNums.klass, _wrap_OBSerialNums_allocate);
  rb_define_method(SwigClassOBSerialNums.klass, "initialize", VALUEFUNC(_wrap_new_OBSerialNums), -1);
  rb_define_method(SwigClassOBSerialNums.klass, "get_data", VALUEFUNC(_wrap_OBSerialNums_get_data), -1);
  rb_define_method(SwigClassOBSerialNums.klass, "set_data", VALUEFUNC(_wrap_OBSerialNums_set_data), -1);
  SwigClassOBSerialNums.mark = 0;
  SwigClassOBSerialNums.destroy = (void (*)(void *)) free_OpenBabel_OBSerialNums;
  SwigClassOBSerialNums.trackObjects = 0;
  
  SwigClassOBVibrationData.klass = rb_define_class_under(mOpenBabel, "OBVibrationData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVibrationData, (void *) &SwigClassOBVibrationData);
  rb_define_alloc_func(SwigClassOBVibrationData.klass, _wrap_OBVibrationData_allocate);
  rb_define_method(SwigClassOBVibrationData.klass, "initialize", VALUEFUNC(_wrap_new_OBVibrationData), -1);
  rb_define_method(SwigClassOBVibrationData.klass, "set_data", VALUEFUNC(_wrap_OBVibrationData_set_data), -1);
  rb_define_method(SwigClassOBVibrationData.klass, "get_lx", VALUEFUNC(_wrap_OBVibrationData_get_lx), -1);
  rb_define_method(SwigClassOBVibrationData.klass, "get_frequencies", VALUEFUNC(_wrap_OBVibrationData_get_frequencies), -1);
  rb_define_method(SwigClassOBVibrationData.klass, "get_intensities", VALUEFUNC(_wrap_OBVibrationData_get_intensities), -1);
  rb_define_method(SwigClassOBVibrationData.klass, "get_number_of_frequencies", VALUEFUNC(_wrap_OBVibrationData_get_number_of_frequencies), -1);
  SwigClassOBVibrationData.mark = 0;
  SwigClassOBVibrationData.destroy = (void (*)(void *)) free_OpenBabel_OBVibrationData;
  SwigClassOBVibrationData.trackObjects = 0;
  
  SwigClassOBRotationData.klass = rb_define_class_under(mOpenBabel, "OBRotationData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRotationData, (void *) &SwigClassOBRotationData);
  rb_define_alloc_func(SwigClassOBRotationData.klass, _wrap_OBRotationData_allocate);
  rb_define_method(SwigClassOBRotationData.klass, "initialize", VALUEFUNC(_wrap_new_OBRotationData), -1);
  rb_define_const(SwigClassOBRotationData.klass, "UNKNOWN", SWIG_From_int(static_cast< int >(OpenBabel::OBRotationData::UNKNOWN)));
  rb_define_const(SwigClassOBRotationData.klass, "ASYMMETRIC", SWIG_From_int(static_cast< int >(OpenBabel::OBRotationData::ASYMMETRIC)));
  rb_define_const(SwigClassOBRotationData.klass, "SYMMETRIC", SWIG_From_int(static_cast< int >(OpenBabel::OBRotationData::SYMMETRIC)));
  rb_define_const(SwigClassOBRotationData.klass, "LINEAR", SWIG_From_int(static_cast< int >(OpenBabel::OBRotationData::LINEAR)));
  rb_define_method(SwigClassOBRotationData.klass, "set_data", VALUEFUNC(_wrap_OBRotationData_set_data), -1);
  rb_define_method(SwigClassOBRotationData.klass, "get_rot_consts", VALUEFUNC(_wrap_OBRotationData_get_rot_consts), -1);
  rb_define_method(SwigClassOBRotationData.klass, "get_symmetry_number", VALUEFUNC(_wrap_OBRotationData_get_symmetry_number), -1);
  rb_define_method(SwigClassOBRotationData.klass, "get_rotor_type", VALUEFUNC(_wrap_OBRotationData_get_rotor_type), -1);
  SwigClassOBRotationData.mark = 0;
  SwigClassOBRotationData.destroy = (void (*)(void *)) free_OpenBabel_OBRotationData;
  SwigClassOBRotationData.trackObjects = 0;
  
  SwigClassOBVectorData.klass = rb_define_class_under(mOpenBabel, "OBVectorData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBVectorData, (void *) &SwigClassOBVectorData);
  rb_define_alloc_func(SwigClassOBVectorData.klass, _wrap_OBVectorData_allocate);
  rb_define_method(SwigClassOBVectorData.klass, "initialize", VALUEFUNC(_wrap_new_OBVectorData), -1);
  rb_define_method(SwigClassOBVectorData.klass, "set_data", VALUEFUNC(_wrap_OBVectorData_set_data), -1);
  rb_define_method(SwigClassOBVectorData.klass, "get_data", VALUEFUNC(_wrap_OBVectorData_get_data), -1);
  SwigClassOBVectorData.mark = 0;
  SwigClassOBVectorData.destroy = (void (*)(void *)) free_OpenBabel_OBVectorData;
  SwigClassOBVectorData.trackObjects = 0;
  
  SwigClassOBMatrixData.klass = rb_define_class_under(mOpenBabel, "OBMatrixData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMatrixData, (void *) &SwigClassOBMatrixData);
  rb_define_alloc_func(SwigClassOBMatrixData.klass, _wrap_OBMatrixData_allocate);
  rb_define_method(SwigClassOBMatrixData.klass, "initialize", VALUEFUNC(_wrap_new_OBMatrixData), -1);
  rb_define_method(SwigClassOBMatrixData.klass, "set_data", VALUEFUNC(_wrap_OBMatrixData_set_data), -1);
  rb_define_method(SwigClassOBMatrixData.klass, "get_data", VALUEFUNC(_wrap_OBMatrixData_get_data), -1);
  SwigClassOBMatrixData.mark = 0;
  SwigClassOBMatrixData.destroy = (void (*)(void *)) free_OpenBabel_OBMatrixData;
  SwigClassOBMatrixData.trackObjects = 0;
  
  SwigClassOBGridData.klass = rb_define_class_under(mOpenBabel, "OBGridData", ((swig_class *) SWIGTYPE_p_OpenBabel__OBGenericData->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBGridData, (void *) &SwigClassOBGridData);
  rb_define_alloc_func(SwigClassOBGridData.klass, _wrap_OBGridData_allocate);
  rb_define_method(SwigClassOBGridData.klass, "initialize", VALUEFUNC(_wrap_new_OBGridData), -1);
  rb_define_const(SwigClassOBGridData.klass, "BOHR", SWIG_From_int(static_cast< int >(OpenBabel::OBGridData::BOHR)));
  rb_define_const(SwigClassOBGridData.klass, "ANGSTROM", SWIG_From_int(static_cast< int >(OpenBabel::OBGridData::ANGSTROM)));
  rb_define_const(SwigClassOBGridData.klass, "OTHER", SWIG_From_int(static_cast< int >(OpenBabel::OBGridData::OTHER)));
  rb_define_method(SwigClassOBGridData.klass, "get_xaxis", VALUEFUNC(_wrap_OBGridData_get_xaxis), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_yaxis", VALUEFUNC(_wrap_OBGridData_get_yaxis), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_zaxis", VALUEFUNC(_wrap_OBGridData_get_zaxis), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_axes", VALUEFUNC(_wrap_OBGridData_get_axes), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_number_of_points", VALUEFUNC(_wrap_OBGridData_get_number_of_points), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_number_of_steps", VALUEFUNC(_wrap_OBGridData_get_number_of_steps), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_values", VALUEFUNC(_wrap_OBGridData_get_values), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_value", VALUEFUNC(_wrap_OBGridData_get_value), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_unit", VALUEFUNC(_wrap_OBGridData_get_unit), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_min_value", VALUEFUNC(_wrap_OBGridData_get_min_value), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_max_value", VALUEFUNC(_wrap_OBGridData_get_max_value), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_origin_vector", VALUEFUNC(_wrap_OBGridData_get_origin_vector), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_max_vector", VALUEFUNC(_wrap_OBGridData_get_max_vector), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_unrestricted", VALUEFUNC(_wrap_OBGridData_get_unrestricted), -1);
  rb_define_method(SwigClassOBGridData.klass, "get_num_symmetries", VALUEFUNC(_wrap_OBGridData_get_num_symmetries), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_number_of_points", VALUEFUNC(_wrap_OBGridData_set_number_of_points), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_limits", VALUEFUNC(_wrap_OBGridData_set_limits), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_value", VALUEFUNC(_wrap_OBGridData_set_value), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_values", VALUEFUNC(_wrap_OBGridData_set_values), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_unit", VALUEFUNC(_wrap_OBGridData_set_unit), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_unrestricted", VALUEFUNC(_wrap_OBGridData_set_unrestricted), -1);
  rb_define_method(SwigClassOBGridData.klass, "set_num_symmetries", VALUEFUNC(_wrap_OBGridData_set_num_symmetries), -1);
  SwigClassOBGridData.mark = 0;
  SwigClassOBGridData.destroy = (void (*)(void *)) free_OpenBabel_OBGridData;
  SwigClassOBGridData.trackObjects = 0;
  
  SwigClassCharPtrLess.klass = rb_define_class_under(mOpenBabel, "CharPtrLess", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__CharPtrLess, (void *) &SwigClassCharPtrLess);
  rb_define_alloc_func(SwigClassCharPtrLess.klass, _wrap_CharPtrLess_allocate);
  rb_define_method(SwigClassCharPtrLess.klass, "initialize", VALUEFUNC(_wrap_new_CharPtrLess), -1);
  rb_define_method(SwigClassCharPtrLess.klass, "call", VALUEFUNC(_wrap_CharPtrLess___call__), -1);
  SwigClassCharPtrLess.mark = 0;
  SwigClassCharPtrLess.destroy = (void (*)(void *)) free_OpenBabel_CharPtrLess;
  SwigClassCharPtrLess.trackObjects = 0;
  
  SwigClassOBPlugin.klass = rb_define_class_under(mOpenBabel, "OBPlugin", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBPlugin, (void *) &SwigClassOBPlugin);
  rb_undef_alloc_func(SwigClassOBPlugin.klass);
  rb_define_method(SwigClassOBPlugin.klass, "description", VALUEFUNC(_wrap_OBPlugin_description), -1);
  rb_define_method(SwigClassOBPlugin.klass, "display", VALUEFUNC(_wrap_OBPlugin_display), -1);
  rb_define_method(SwigClassOBPlugin.klass, "make_instance", VALUEFUNC(_wrap_OBPlugin_make_instance), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "get_plugin", VALUEFUNC(_wrap_OBPlugin_get_plugin), -1);
  rb_define_method(SwigClassOBPlugin.klass, "get_id", VALUEFUNC(_wrap_OBPlugin_get_id), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "list_as_vector", VALUEFUNC(_wrap_OBPlugin_list_as_vector), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "list", VALUEFUNC(_wrap_OBPlugin_list), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "list_as_string", VALUEFUNC(_wrap_OBPlugin_list_as_string), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "first_line", VALUEFUNC(_wrap_OBPlugin_first_line), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "begin", VALUEFUNC(_wrap_OBPlugin_begin), -1);
  rb_define_singleton_method(SwigClassOBPlugin.klass, "end", VALUEFUNC(_wrap_OBPlugin_end), -1);
  rb_define_method(SwigClassOBPlugin.klass, "get_map", VALUEFUNC(_wrap_OBPlugin_get_map), -1);
  SwigClassOBPlugin.mark = 0;
  SwigClassOBPlugin.destroy = (void (*)(void *)) free_OpenBabel_OBPlugin;
  SwigClassOBPlugin.trackObjects = 0;
  rb_define_const(mOpenBabel, "ObError", SWIG_From_int(static_cast< int >(OpenBabel::obError)));
  rb_define_const(mOpenBabel, "ObWarning", SWIG_From_int(static_cast< int >(OpenBabel::obWarning)));
  rb_define_const(mOpenBabel, "ObInfo", SWIG_From_int(static_cast< int >(OpenBabel::obInfo)));
  rb_define_const(mOpenBabel, "ObAuditMsg", SWIG_From_int(static_cast< int >(OpenBabel::obAuditMsg)));
  rb_define_const(mOpenBabel, "ObDebug", SWIG_From_int(static_cast< int >(OpenBabel::obDebug)));
  rb_define_const(mOpenBabel, "Always", SWIG_From_int(static_cast< int >(OpenBabel::always)));
  rb_define_const(mOpenBabel, "OnceOnly", SWIG_From_int(static_cast< int >(OpenBabel::onceOnly)));
  
  SwigClassOBError.klass = rb_define_class_under(mOpenBabel, "OBError", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBError, (void *) &SwigClassOBError);
  rb_define_alloc_func(SwigClassOBError.klass, _wrap_OBError_allocate);
  rb_define_method(SwigClassOBError.klass, "initialize", VALUEFUNC(_wrap_new_OBError), -1);
  rb_define_method(SwigClassOBError.klass, "message", VALUEFUNC(_wrap_OBError_message), -1);
  rb_define_method(SwigClassOBError.klass, "get_method", VALUEFUNC(_wrap_OBError_get_method), -1);
  rb_define_method(SwigClassOBError.klass, "get_error", VALUEFUNC(_wrap_OBError_get_error), -1);
  rb_define_method(SwigClassOBError.klass, "get_explanation", VALUEFUNC(_wrap_OBError_get_explanation), -1);
  rb_define_method(SwigClassOBError.klass, "get_possible_cause", VALUEFUNC(_wrap_OBError_get_possible_cause), -1);
  rb_define_method(SwigClassOBError.klass, "get_suggested_remedy", VALUEFUNC(_wrap_OBError_get_suggested_remedy), -1);
  rb_define_method(SwigClassOBError.klass, "get_level", VALUEFUNC(_wrap_OBError_get_level), -1);
  rb_define_method(SwigClassOBError.klass, "==", VALUEFUNC(_wrap_OBError___eq__), -1);
  SwigClassOBError.mark = 0;
  SwigClassOBError.destroy = (void (*)(void *)) free_OpenBabel_OBError;
  SwigClassOBError.trackObjects = 0;
  
  SwigClassOBMessageHandler.klass = rb_define_class_under(mOpenBabel, "OBMessageHandler", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMessageHandler, (void *) &SwigClassOBMessageHandler);
  rb_define_alloc_func(SwigClassOBMessageHandler.klass, _wrap_OBMessageHandler_allocate);
  rb_define_method(SwigClassOBMessageHandler.klass, "initialize", VALUEFUNC(_wrap_new_OBMessageHandler), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "throw_error", VALUEFUNC(_wrap_OBMessageHandler_throw_error), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_messages_of_level", VALUEFUNC(_wrap_OBMessageHandler_get_messages_of_level), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "start_logging", VALUEFUNC(_wrap_OBMessageHandler_start_logging), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "stop_logging", VALUEFUNC(_wrap_OBMessageHandler_stop_logging), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "set_max_log_entries", VALUEFUNC(_wrap_OBMessageHandler_set_max_log_entries), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_max_log_entries", VALUEFUNC(_wrap_OBMessageHandler_get_max_log_entries), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "clear_log", VALUEFUNC(_wrap_OBMessageHandler_clear_log), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "set_output_level", VALUEFUNC(_wrap_OBMessageHandler_set_output_level), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_output_level", VALUEFUNC(_wrap_OBMessageHandler_get_output_level), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "set_output_stream", VALUEFUNC(_wrap_OBMessageHandler_set_output_stream), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_output_stream", VALUEFUNC(_wrap_OBMessageHandler_get_output_stream), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "start_error_wrap", VALUEFUNC(_wrap_OBMessageHandler_start_error_wrap), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "stop_error_wrap", VALUEFUNC(_wrap_OBMessageHandler_stop_error_wrap), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_error_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_error_message_count), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_warning_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_warning_message_count), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_info_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_info_message_count), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_audit_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_audit_message_count), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_debug_message_count", VALUEFUNC(_wrap_OBMessageHandler_get_debug_message_count), -1);
  rb_define_method(SwigClassOBMessageHandler.klass, "get_message_summary", VALUEFUNC(_wrap_OBMessageHandler_get_message_summary), -1);
  SwigClassOBMessageHandler.mark = 0;
  SwigClassOBMessageHandler.destroy = (void (*)(void *)) free_OpenBabel_OBMessageHandler;
  SwigClassOBMessageHandler.trackObjects = 0;
  rb_define_singleton_method(mOpenBabel, "obErrorLog", VALUEFUNC(_wrap_obErrorLog_get), 0);
  rb_define_singleton_method(mOpenBabel, "obErrorLog=", VALUEFUNC(_wrap_obErrorLog_set), 1);
  
  SwigClassObLogBuf.klass = rb_define_class_under(mOpenBabel, "ObLogBuf", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__obLogBuf, (void *) &SwigClassObLogBuf);
  rb_define_alloc_func(SwigClassObLogBuf.klass, _wrap_ObLogBuf_allocate);
  rb_define_method(SwigClassObLogBuf.klass, "initialize", VALUEFUNC(_wrap_new_ObLogBuf), -1);
  SwigClassObLogBuf.mark = 0;
  SwigClassObLogBuf.destroy = (void (*)(void *)) free_OpenBabel_obLogBuf;
  SwigClassObLogBuf.trackObjects = 0;
  rb_define_const(mOpenBabel, "NOTREADABLE", SWIG_From_int(static_cast< int >(0x01)));
  rb_define_const(mOpenBabel, "READONEONLY", SWIG_From_int(static_cast< int >(0x02)));
  rb_define_const(mOpenBabel, "READBINARY", SWIG_From_int(static_cast< int >(0x04)));
  rb_define_const(mOpenBabel, "ZEROATOMSOK", SWIG_From_int(static_cast< int >(0x08)));
  rb_define_const(mOpenBabel, "NOTWRITABLE", SWIG_From_int(static_cast< int >(0x10)));
  rb_define_const(mOpenBabel, "WRITEONEONLY", SWIG_From_int(static_cast< int >(0x20)));
  rb_define_const(mOpenBabel, "WRITEBINARY", SWIG_From_int(static_cast< int >(0x40)));
  rb_define_const(mOpenBabel, "READXML", SWIG_From_int(static_cast< int >(0x80)));
  rb_define_const(mOpenBabel, "DEFAULTFORMAT", SWIG_From_int(static_cast< int >(0x4000)));
  
  SwigClassOBFormat.klass = rb_define_class_under(mOpenBabel, "OBFormat", ((swig_class *) SWIGTYPE_p_OpenBabel__OBPlugin->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFormat, (void *) &SwigClassOBFormat);
  rb_undef_alloc_func(SwigClassOBFormat.klass);
  rb_define_singleton_method(SwigClassOBFormat.klass, "default", VALUEFUNC(_wrap_OBFormat_default), -1);
  rb_define_singleton_method(SwigClassOBFormat.klass, "find_type", VALUEFUNC(_wrap_OBFormat_find_type), -1);
  rb_define_method(SwigClassOBFormat.klass, "type_id", VALUEFUNC(_wrap_OBFormat_type_id), -1);
  rb_define_method(SwigClassOBFormat.klass, "read_molecule", VALUEFUNC(_wrap_OBFormat_read_molecule), -1);
  rb_define_method(SwigClassOBFormat.klass, "read_chem_object", VALUEFUNC(_wrap_OBFormat_read_chem_object), -1);
  rb_define_method(SwigClassOBFormat.klass, "write_molecule", VALUEFUNC(_wrap_OBFormat_write_molecule), -1);
  rb_define_method(SwigClassOBFormat.klass, "write_chem_object", VALUEFUNC(_wrap_OBFormat_write_chem_object), -1);
  rb_define_method(SwigClassOBFormat.klass, "target_class_description", VALUEFUNC(_wrap_OBFormat_target_class_description), -1);
  rb_define_method(SwigClassOBFormat.klass, "get_type", VALUEFUNC(_wrap_OBFormat_get_type), -1);
  rb_define_method(SwigClassOBFormat.klass, "specification_url", VALUEFUNC(_wrap_OBFormat_specification_url), -1);
  rb_define_method(SwigClassOBFormat.klass, "get_mimetype", VALUEFUNC(_wrap_OBFormat_get_mimetype), -1);
  rb_define_method(SwigClassOBFormat.klass, "flags", VALUEFUNC(_wrap_OBFormat_flags), -1);
  rb_define_method(SwigClassOBFormat.klass, "skip_objects", VALUEFUNC(_wrap_OBFormat_skip_objects), -1);
  rb_define_method(SwigClassOBFormat.klass, "make_new_instance", VALUEFUNC(_wrap_OBFormat_make_new_instance), -1);
  rb_define_method(SwigClassOBFormat.klass, "register_format", VALUEFUNC(_wrap_OBFormat_register_format), -1);
  rb_define_method(SwigClassOBFormat.klass, "display", VALUEFUNC(_wrap_OBFormat_display), -1);
  rb_define_singleton_method(SwigClassOBFormat.klass, "format_from_mime", VALUEFUNC(_wrap_OBFormat_format_from_mime), -1);
  SwigClassOBFormat.mark = 0;
  SwigClassOBFormat.destroy = (void (*)(void *)) free_OpenBabel_OBFormat;
  SwigClassOBFormat.trackObjects = 0;
  
  SwigClassOBConversion.klass = rb_define_class_under(mOpenBabel, "OBConversion", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBConversion, (void *) &SwigClassOBConversion);
  rb_define_alloc_func(SwigClassOBConversion.klass, _wrap_OBConversion_allocate);
  rb_define_method(SwigClassOBConversion.klass, "initialize", VALUEFUNC(_wrap_new_OBConversion), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "register_format", VALUEFUNC(_wrap_OBConversion_register_format), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "find_format", VALUEFUNC(_wrap_OBConversion_find_format), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "format_from_ext", VALUEFUNC(_wrap_OBConversion_format_from_ext), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "format_from_mime", VALUEFUNC(_wrap_OBConversion_format_from_mime), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "get_next_format", VALUEFUNC(_wrap_OBConversion_get_next_format), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "description", VALUEFUNC(_wrap_OBConversion_description), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_in_stream", VALUEFUNC(_wrap_OBConversion_get_in_stream), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_out_stream", VALUEFUNC(_wrap_OBConversion_get_out_stream), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_in_stream", VALUEFUNC(_wrap_OBConversion_set_in_stream), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_out_stream", VALUEFUNC(_wrap_OBConversion_set_out_stream), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_in_and_out_formats", VALUEFUNC(_wrap_OBConversion_set_in_and_out_formats), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_in_format", VALUEFUNC(_wrap_OBConversion_set_in_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_out_format", VALUEFUNC(_wrap_OBConversion_set_out_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_in_format", VALUEFUNC(_wrap_OBConversion_get_in_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_out_format", VALUEFUNC(_wrap_OBConversion_get_out_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_in_filename", VALUEFUNC(_wrap_OBConversion_get_in_filename), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_in_pos", VALUEFUNC(_wrap_OBConversion_get_in_pos), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_in_len", VALUEFUNC(_wrap_OBConversion_get_in_len), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_title", VALUEFUNC(_wrap_OBConversion_get_title), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_aux_conv", VALUEFUNC(_wrap_OBConversion_get_aux_conv), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_aux_conv", VALUEFUNC(_wrap_OBConversion_set_aux_conv), -1);
  rb_define_const(SwigClassOBConversion.klass, "INOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::INOPTIONS)));
  rb_define_const(SwigClassOBConversion.klass, "OUTOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::OUTOPTIONS)));
  rb_define_const(SwigClassOBConversion.klass, "GENOPTIONS", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::GENOPTIONS)));
  rb_define_const(SwigClassOBConversion.klass, "ALL", SWIG_From_int(static_cast< int >(OpenBabel::OBConversion::ALL)));
  rb_define_method(SwigClassOBConversion.klass, "is_option", VALUEFUNC(_wrap_OBConversion_is_option), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_options", VALUEFUNC(_wrap_OBConversion_get_options), -1);
  rb_define_method(SwigClassOBConversion.klass, "add_option", VALUEFUNC(_wrap_OBConversion_add_option), -1);
  rb_define_method(SwigClassOBConversion.klass, "remove_option", VALUEFUNC(_wrap_OBConversion_remove_option), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_options", VALUEFUNC(_wrap_OBConversion_set_options), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "register_option_param", VALUEFUNC(_wrap_OBConversion_register_option_param), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "get_option_params", VALUEFUNC(_wrap_OBConversion_get_option_params), -1);
  rb_define_method(SwigClassOBConversion.klass, "copy_options", VALUEFUNC(_wrap_OBConversion_copy_options), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_supported_input_format", VALUEFUNC(_wrap_OBConversion_get_supported_input_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_supported_output_format", VALUEFUNC(_wrap_OBConversion_get_supported_output_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "convert", VALUEFUNC(_wrap_OBConversion_convert), -1);
  rb_define_method(SwigClassOBConversion.klass, "full_convert", VALUEFUNC(_wrap_OBConversion_full_convert), -1);
  rb_define_method(SwigClassOBConversion.klass, "add_chem_object", VALUEFUNC(_wrap_OBConversion_add_chem_object), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_chem_object", VALUEFUNC(_wrap_OBConversion_get_chem_object), -1);
  rb_define_method(SwigClassOBConversion.klass, "is_last", VALUEFUNC(_wrap_OBConversion_is_last), -1);
  rb_define_method(SwigClassOBConversion.klass, "is_first_input", VALUEFUNC(_wrap_OBConversion_is_first_input), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_first_input", VALUEFUNC(_wrap_OBConversion_set_first_input), -1);
  rb_define_method(SwigClassOBConversion.klass, "get_output_index", VALUEFUNC(_wrap_OBConversion_get_output_index), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_output_index", VALUEFUNC(_wrap_OBConversion_set_output_index), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_more_files_to_come", VALUEFUNC(_wrap_OBConversion_set_more_files_to_come), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_one_object_only", VALUEFUNC(_wrap_OBConversion_set_one_object_only), -1);
  rb_define_method(SwigClassOBConversion.klass, "set_last", VALUEFUNC(_wrap_OBConversion_set_last), -1);
  rb_define_method(SwigClassOBConversion.klass, "is_last_file", VALUEFUNC(_wrap_OBConversion_is_last_file), -1);
  rb_define_singleton_method(SwigClassOBConversion.klass, "get_default_format", VALUEFUNC(_wrap_OBConversion_get_default_format), -1);
  rb_define_method(SwigClassOBConversion.klass, "write", VALUEFUNC(_wrap_OBConversion_write), -1);
  rb_define_method(SwigClassOBConversion.klass, "write_string", VALUEFUNC(_wrap_OBConversion_write_string), -1);
  rb_define_method(SwigClassOBConversion.klass, "write_file", VALUEFUNC(_wrap_OBConversion_write_file), -1);
  rb_define_method(SwigClassOBConversion.klass, "close_out_file", VALUEFUNC(_wrap_OBConversion_close_out_file), -1);
  rb_define_method(SwigClassOBConversion.klass, "read", VALUEFUNC(_wrap_OBConversion_read), -1);
  rb_define_method(SwigClassOBConversion.klass, "read_string", VALUEFUNC(_wrap_OBConversion_read_string), -1);
  rb_define_method(SwigClassOBConversion.klass, "read_file", VALUEFUNC(_wrap_OBConversion_read_file), -1);
  rb_define_method(SwigClassOBConversion.klass, "open_in_and_out_files", VALUEFUNC(_wrap_OBConversion_open_in_and_out_files), -1);
  rb_define_method(SwigClassOBConversion.klass, "report_number_converted", VALUEFUNC(_wrap_OBConversion_report_number_converted), -1);
  SwigClassOBConversion.mark = 0;
  SwigClassOBConversion.destroy = (void (*)(void *)) free_OpenBabel_OBConversion;
  SwigClassOBConversion.trackObjects = 0;
  
  SwigClassOBResidue.klass = rb_define_class_under(mOpenBabel, "OBResidue", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidue, (void *) &SwigClassOBResidue);
  rb_define_alloc_func(SwigClassOBResidue.klass, _wrap_OBResidue_allocate);
  rb_define_method(SwigClassOBResidue.klass, "initialize", VALUEFUNC(_wrap_new_OBResidue), -1);
  rb_define_method(SwigClassOBResidue.klass, "add_atom", VALUEFUNC(_wrap_OBResidue_add_atom), -1);
  rb_define_method(SwigClassOBResidue.klass, "insert_atom", VALUEFUNC(_wrap_OBResidue_insert_atom), -1);
  rb_define_method(SwigClassOBResidue.klass, "remove_atom", VALUEFUNC(_wrap_OBResidue_remove_atom), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_name", VALUEFUNC(_wrap_OBResidue_set_name), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_num", VALUEFUNC(_wrap_OBResidue_set_num), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_chain", VALUEFUNC(_wrap_OBResidue_set_chain), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_chain_num", VALUEFUNC(_wrap_OBResidue_set_chain_num), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_idx", VALUEFUNC(_wrap_OBResidue_set_idx), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_atom_id", VALUEFUNC(_wrap_OBResidue_set_atom_id), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_het_atom", VALUEFUNC(_wrap_OBResidue_set_het_atom), -1);
  rb_define_method(SwigClassOBResidue.klass, "set_serial_num", VALUEFUNC(_wrap_OBResidue_set_serial_num), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_name", VALUEFUNC(_wrap_OBResidue_get_name), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_num", VALUEFUNC(_wrap_OBResidue_get_num), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_num_string", VALUEFUNC(_wrap_OBResidue_get_num_string), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_num_atoms", VALUEFUNC(_wrap_OBResidue_get_num_atoms), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_chain", VALUEFUNC(_wrap_OBResidue_get_chain), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_chain_num", VALUEFUNC(_wrap_OBResidue_get_chain_num), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_idx", VALUEFUNC(_wrap_OBResidue_get_idx), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_res_key", VALUEFUNC(_wrap_OBResidue_get_res_key), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_atoms", VALUEFUNC(_wrap_OBResidue_get_atoms), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_bonds", VALUEFUNC(_wrap_OBResidue_get_bonds), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_atom_id", VALUEFUNC(_wrap_OBResidue_get_atom_id), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_serial_num", VALUEFUNC(_wrap_OBResidue_get_serial_num), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_amino_acid_property", VALUEFUNC(_wrap_OBResidue_get_amino_acid_property), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_atom_property", VALUEFUNC(_wrap_OBResidue_get_atom_property), -1);
  rb_define_method(SwigClassOBResidue.klass, "get_residue_property", VALUEFUNC(_wrap_OBResidue_get_residue_property), -1);
  rb_define_method(SwigClassOBResidue.klass, "is_het_atom", VALUEFUNC(_wrap_OBResidue_is_het_atom), -1);
  rb_define_method(SwigClassOBResidue.klass, "is_residue_type", VALUEFUNC(_wrap_OBResidue_is_residue_type), -1);
  rb_define_method(SwigClassOBResidue.klass, "begin_atoms", VALUEFUNC(_wrap_OBResidue_begin_atoms), -1);
  rb_define_method(SwigClassOBResidue.klass, "end_atoms", VALUEFUNC(_wrap_OBResidue_end_atoms), -1);
  rb_define_method(SwigClassOBResidue.klass, "begin_atom", VALUEFUNC(_wrap_OBResidue_begin_atom), -1);
  rb_define_method(SwigClassOBResidue.klass, "next_atom", VALUEFUNC(_wrap_OBResidue_next_atom), -1);
  SwigClassOBResidue.mark = 0;
  SwigClassOBResidue.destroy = (void (*)(void *)) free_OpenBabel_OBResidue;
  SwigClassOBResidue.trackObjects = 0;
  rb_define_const(mOpenBabel, "MAXSETNO", SWIG_From_int(static_cast< int >(40)));
  rb_define_const(mOpenBabel, "MAXELEM", SWIG_From_int(static_cast< int >(1024)));
  rb_define_const(mOpenBabel, "MINELEM", SWIG_From_int(static_cast< int >(29)));
  rb_define_const(mOpenBabel, "MAXRES", SWIG_From_int(static_cast< int >(100)));
  rb_define_const(mOpenBabel, "MINRES", SWIG_From_int(static_cast< int >(54)));
  rb_define_const(mOpenBabel, "AA_ALA", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "AA_GLY", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenBabel, "AA_LEU", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenBabel, "AA_SER", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenBabel, "AA_VAL", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenBabel, "AA_THR", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenBabel, "AA_LYS", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenBabel, "AA_ASP", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenBabel, "AA_ILE", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenBabel, "AA_ASN", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenBabel, "AA_GLU", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenBabel, "AA_PRO", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenBabel, "AA_ARG", SWIG_From_int(static_cast< int >((1 << 13))));
  rb_define_const(mOpenBabel, "AA_PHE", SWIG_From_int(static_cast< int >((1 << 14))));
  rb_define_const(mOpenBabel, "AA_GLN", SWIG_From_int(static_cast< int >((1 << 15))));
  rb_define_const(mOpenBabel, "AA_TYR", SWIG_From_int(static_cast< int >((1 << 16))));
  rb_define_const(mOpenBabel, "AA_HIS", SWIG_From_int(static_cast< int >((1 << 17))));
  rb_define_const(mOpenBabel, "AA_CYS", SWIG_From_int(static_cast< int >((1 << 18))));
  rb_define_const(mOpenBabel, "AA_MET", SWIG_From_int(static_cast< int >((1 << 19))));
  rb_define_const(mOpenBabel, "AA_TRP", SWIG_From_int(static_cast< int >((1 << 20))));
  rb_define_const(mOpenBabel, "ACIDIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ACIDIC)));
  rb_define_const(mOpenBabel, "ACYCLIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ACYCLIC)));
  rb_define_const(mOpenBabel, "ALIPHATIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::ALIPHATIC)));
  rb_define_const(mOpenBabel, "AROMATIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::AROMATIC)));
  rb_define_const(mOpenBabel, "BASIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::BASIC)));
  rb_define_const(mOpenBabel, "BURIED", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::BURIED)));
  rb_define_const(mOpenBabel, "CHARGED", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::CHARGED)));
  rb_define_const(mOpenBabel, "CYCLIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::CYCLIC)));
  rb_define_const(mOpenBabel, "HYDROPHOBIC", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::HYDROPHOBIC)));
  rb_define_const(mOpenBabel, "LARGE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::LARGE)));
  rb_define_const(mOpenBabel, "MEDIUM", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::MEDIUM)));
  rb_define_const(mOpenBabel, "NEGATIVE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::NEGATIVE)));
  rb_define_const(mOpenBabel, "NEUTRAL", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::NEUTRAL)));
  rb_define_const(mOpenBabel, "POLAR", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::POLAR)));
  rb_define_const(mOpenBabel, "POSITIVE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::POSITIVE)));
  rb_define_const(mOpenBabel, "SMALL", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::SMALL)));
  rb_define_const(mOpenBabel, "SURFACE", SWIG_From_int(static_cast< int >(OpenBabel::OBAminoAcidProperty::SURFACE)));
  rb_define_const(mOpenBabel, "ALPHA_CARBON", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::ALPHA_CARBON)));
  rb_define_const(mOpenBabel, "AMINO_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::AMINO_BACKBONE)));
  rb_define_const(mOpenBabel, "BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::BACKBONE)));
  rb_define_const(mOpenBabel, "CYSTEINE_SULPHUR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::CYSTEINE_SULPHUR)));
  rb_define_const(mOpenBabel, "LIGAND", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::LIGAND)));
  rb_define_const(mOpenBabel, "NUCLEIC_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::NUCLEIC_BACKBONE)));
  rb_define_const(mOpenBabel, "SHAPELY_BACKBONE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SHAPELY_BACKBONE)));
  rb_define_const(mOpenBabel, "SHAPELY_SPECIAL", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SHAPELY_SPECIAL)));
  rb_define_const(mOpenBabel, "SIDECHAIN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SIDECHAIN)));
  rb_define_const(mOpenBabel, "SUGAR_PHOSPHATE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueAtomProperty::SUGAR_PHOSPHATE)));
  rb_define_const(mOpenBabel, "ALA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ALA)));
  rb_define_const(mOpenBabel, "GLY", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLY)));
  rb_define_const(mOpenBabel, "LEU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::LEU)));
  rb_define_const(mOpenBabel, "SER", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::SER)));
  rb_define_const(mOpenBabel, "VAL", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::VAL)));
  rb_define_const(mOpenBabel, "THR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::THR)));
  rb_define_const(mOpenBabel, "LYS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::LYS)));
  rb_define_const(mOpenBabel, "ASP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASP)));
  rb_define_const(mOpenBabel, "ILE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ILE)));
  rb_define_const(mOpenBabel, "ASN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASN)));
  rb_define_const(mOpenBabel, "GLU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLU)));
  rb_define_const(mOpenBabel, "PRO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PRO)));
  rb_define_const(mOpenBabel, "ARG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ARG)));
  rb_define_const(mOpenBabel, "PHE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PHE)));
  rb_define_const(mOpenBabel, "GLN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLN)));
  rb_define_const(mOpenBabel, "TYR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::TYR)));
  rb_define_const(mOpenBabel, "HIS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HIS)));
  rb_define_const(mOpenBabel, "CYS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::CYS)));
  rb_define_const(mOpenBabel, "MET", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::MET)));
  rb_define_const(mOpenBabel, "TRP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::TRP)));
  rb_define_const(mOpenBabel, "ASX", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ASX)));
  rb_define_const(mOpenBabel, "GLX", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::GLX)));
  rb_define_const(mOpenBabel, "PCA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PCA)));
  rb_define_const(mOpenBabel, "HYP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HYP)));
  rb_define_const(mOpenBabel, "A", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::A)));
  rb_define_const(mOpenBabel, "C", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::C)));
  rb_define_const(mOpenBabel, "G", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::G)));
  rb_define_const(mOpenBabel, "T", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::T)));
  rb_define_const(mOpenBabel, "U", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::U)));
  rb_define_const(mOpenBabel, "UPLUS", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::UPLUS)));
  rb_define_const(mOpenBabel, "I", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::I)));
  rb_define_const(mOpenBabel, "U1MA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_1MA)));
  rb_define_const(mOpenBabel, "U5MC", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_5MC)));
  rb_define_const(mOpenBabel, "OMC", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::OMC)));
  rb_define_const(mOpenBabel, "U1MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_1MG)));
  rb_define_const(mOpenBabel, "U2MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_2MG)));
  rb_define_const(mOpenBabel, "M2G", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::M2G)));
  rb_define_const(mOpenBabel, "U7MG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_7MG)));
  rb_define_const(mOpenBabel, "OMG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::OMG)));
  rb_define_const(mOpenBabel, "YG", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::YG)));
  rb_define_const(mOpenBabel, "H2U", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::H2U)));
  rb_define_const(mOpenBabel, "U5MU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::_5MU)));
  rb_define_const(mOpenBabel, "PSU", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PSU)));
  rb_define_const(mOpenBabel, "UNK", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::UNK)));
  rb_define_const(mOpenBabel, "ACE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::ACE)));
  rb_define_const(mOpenBabel, "FOR", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::FOR)));
  rb_define_const(mOpenBabel, "HOH", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::HOH)));
  rb_define_const(mOpenBabel, "DOD", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::DOD)));
  rb_define_const(mOpenBabel, "SO4", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::SO4)));
  rb_define_const(mOpenBabel, "PO4", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::PO4)));
  rb_define_const(mOpenBabel, "NAD", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NAD)));
  rb_define_const(mOpenBabel, "COA", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::COA)));
  rb_define_const(mOpenBabel, "NAP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NAP)));
  rb_define_const(mOpenBabel, "NDP", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueIndex::NDP)));
  rb_define_const(mOpenBabel, "AMINO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::AMINO)));
  rb_define_const(mOpenBabel, "AMINO_NUCLEO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::AMINO_NUCLEO)));
  rb_define_const(mOpenBabel, "COENZYME", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::COENZYME)));
  rb_define_const(mOpenBabel, "ION", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::ION)));
  rb_define_const(mOpenBabel, "NUCLEO", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::NUCLEO)));
  rb_define_const(mOpenBabel, "PROTEIN", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PROTEIN)));
  rb_define_const(mOpenBabel, "PURINE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PURINE)));
  rb_define_const(mOpenBabel, "PYRIMIDINE", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::PYRIMIDINE)));
  rb_define_const(mOpenBabel, "SOLVENT", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::SOLVENT)));
  rb_define_const(mOpenBabel, "WATER", SWIG_From_int(static_cast< int >(OpenBabel::OBResidueProperty::WATER)));
  rb_define_singleton_method(mOpenBabel, "Residue", VALUEFUNC(_wrap_Residue_get), 0);
  rb_define_singleton_method(mOpenBabel, "Residue=", VALUEFUNC(_wrap_Residue_set), 1);
  rb_define_singleton_method(mOpenBabel, "ElemDesc", VALUEFUNC(_wrap_ElemDesc_get), 0);
  rb_define_singleton_method(mOpenBabel, "ElemDesc=", VALUEFUNC(_wrap_ElemDesc_set), 1);
  rb_define_singleton_method(mOpenBabel, "ResNo", VALUEFUNC(_wrap_ResNo_get), 0);
  rb_define_singleton_method(mOpenBabel, "ResNo=", VALUEFUNC(_wrap_ResNo_set), 1);
  rb_define_singleton_method(mOpenBabel, "ElemNo", VALUEFUNC(_wrap_ElemNo_get), 0);
  rb_define_singleton_method(mOpenBabel, "ElemNo=", VALUEFUNC(_wrap_ElemNo_set), 1);
  
  SwigClassOBInternalCoord.klass = rb_define_class_under(mOpenBabel, "OBInternalCoord", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBInternalCoord, (void *) &SwigClassOBInternalCoord);
  rb_define_alloc_func(SwigClassOBInternalCoord.klass, _wrap_OBInternalCoord_allocate);
  rb_define_method(SwigClassOBInternalCoord.klass, "initialize", VALUEFUNC(_wrap_new_OBInternalCoord), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_a=", VALUEFUNC(_wrap_OBInternalCoord__a_set), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_a", VALUEFUNC(_wrap_OBInternalCoord__a_get), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_b=", VALUEFUNC(_wrap_OBInternalCoord__b_set), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_b", VALUEFUNC(_wrap_OBInternalCoord__b_get), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_c=", VALUEFUNC(_wrap_OBInternalCoord__c_set), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_c", VALUEFUNC(_wrap_OBInternalCoord__c_get), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_dst=", VALUEFUNC(_wrap_OBInternalCoord__dst_set), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_dst", VALUEFUNC(_wrap_OBInternalCoord__dst_get), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_ang=", VALUEFUNC(_wrap_OBInternalCoord__ang_set), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_ang", VALUEFUNC(_wrap_OBInternalCoord__ang_get), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_tor=", VALUEFUNC(_wrap_OBInternalCoord__tor_set), -1);
  rb_define_method(SwigClassOBInternalCoord.klass, "_tor", VALUEFUNC(_wrap_OBInternalCoord__tor_get), -1);
  SwigClassOBInternalCoord.mark = 0;
  SwigClassOBInternalCoord.destroy = (void (*)(void *)) free_OpenBabel_OBInternalCoord;
  SwigClassOBInternalCoord.trackObjects = 0;
  rb_define_const(mOpenBabel, "OB_4RING_ATOM", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "OB_3RING_ATOM", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenBabel, "OB_AROMATIC_ATOM", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenBabel, "OB_RING_ATOM", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenBabel, "OB_CSTEREO_ATOM", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenBabel, "OB_ACSTEREO_ATOM", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenBabel, "OB_DONOR_ATOM", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenBabel, "OB_ACCEPTOR_ATOM", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenBabel, "OB_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenBabel, "OB_POS_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenBabel, "OB_NEG_CHIRAL_ATOM", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenBabel, "OB_ATOM_HAS_NO_H", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenBabel, "OB_ATOM_NOT_H_DEFICIENT", SWIG_From_int(static_cast< int >((1 << 13))));
  
  SwigClassOBAtom.klass = rb_define_class_under(mOpenBabel, "OBAtom", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtom, (void *) &SwigClassOBAtom);
  rb_define_alloc_func(SwigClassOBAtom.klass, _wrap_OBAtom_allocate);
  rb_define_method(SwigClassOBAtom.klass, "initialize", VALUEFUNC(_wrap_new_OBAtom), -1);
  rb_define_method(SwigClassOBAtom.klass, "Visit=", VALUEFUNC(_wrap_OBAtom_Visit_set), -1);
  rb_define_method(SwigClassOBAtom.klass, "Visit", VALUEFUNC(_wrap_OBAtom_Visit_get), -1);
  rb_define_method(SwigClassOBAtom.klass, "duplicate", VALUEFUNC(_wrap_OBAtom_duplicate), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_idx", VALUEFUNC(_wrap_OBAtom_set_idx), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_hyb", VALUEFUNC(_wrap_OBAtom_set_hyb), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_atomic_num", VALUEFUNC(_wrap_OBAtom_set_atomic_num), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_isotope", VALUEFUNC(_wrap_OBAtom_set_isotope), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBAtom_set_implicit_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBAtom_increment_implicit_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBAtom_decrement_implicit_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_formal_charge", VALUEFUNC(_wrap_OBAtom_set_formal_charge), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBAtom_set_spin_multiplicity), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_type", VALUEFUNC(_wrap_OBAtom_set_type), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_partial_charge", VALUEFUNC(_wrap_OBAtom_set_partial_charge), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBAtom_set_coord_ptr), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_vector", VALUEFUNC(_wrap_OBAtom_set_vector), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_residue", VALUEFUNC(_wrap_OBAtom_set_residue), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_parent", VALUEFUNC(_wrap_OBAtom_set_parent), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_aromatic", VALUEFUNC(_wrap_OBAtom_set_aromatic), -1);
  rb_define_method(SwigClassOBAtom.klass, "unset_aromatic", VALUEFUNC(_wrap_OBAtom_unset_aromatic), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBAtom_set_clockwise_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBAtom_set_anti_clockwise_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBAtom_set_positive_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBAtom_set_negative_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "unset_stereo", VALUEFUNC(_wrap_OBAtom_unset_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_in_ring", VALUEFUNC(_wrap_OBAtom_set_in_ring), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_chiral", VALUEFUNC(_wrap_OBAtom_set_chiral), -1);
  rb_define_method(SwigClassOBAtom.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBAtom_clear_coord_ptr), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_formal_charge", VALUEFUNC(_wrap_OBAtom_get_formal_charge), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_atomic_num", VALUEFUNC(_wrap_OBAtom_get_atomic_num), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_isotope", VALUEFUNC(_wrap_OBAtom_get_isotope), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBAtom_get_spin_multiplicity), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBAtom_get_atomic_mass), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_exact_mass", VALUEFUNC(_wrap_OBAtom_get_exact_mass), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_idx", VALUEFUNC(_wrap_OBAtom_get_idx), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBAtom_get_coordinate_idx), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_cidx", VALUEFUNC(_wrap_OBAtom_get_cidx), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_valence", VALUEFUNC(_wrap_OBAtom_get_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_hyb", VALUEFUNC(_wrap_OBAtom_get_hyb), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBAtom_get_implicit_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBAtom_get_hvy_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBAtom_get_hetero_valence), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_type", VALUEFUNC(_wrap_OBAtom_get_type), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_x", VALUEFUNC(_wrap_OBAtom_get_x), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_y", VALUEFUNC(_wrap_OBAtom_get_y), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_z", VALUEFUNC(_wrap_OBAtom_get_z), -1);
  rb_define_method(SwigClassOBAtom.klass, "x", VALUEFUNC(_wrap_OBAtom_x), -1);
  rb_define_method(SwigClassOBAtom.klass, "y", VALUEFUNC(_wrap_OBAtom_y), -1);
  rb_define_method(SwigClassOBAtom.klass, "z", VALUEFUNC(_wrap_OBAtom_z), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_coordinate", VALUEFUNC(_wrap_OBAtom_get_coordinate), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_vector", VALUEFUNC(_wrap_OBAtom_get_vector), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_partial_charge", VALUEFUNC(_wrap_OBAtom_get_partial_charge), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_residue", VALUEFUNC(_wrap_OBAtom_get_residue), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_parent", VALUEFUNC(_wrap_OBAtom_get_parent), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBAtom_get_new_bond_vector), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_bond", VALUEFUNC(_wrap_OBAtom_get_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_next_atom", VALUEFUNC(_wrap_OBAtom_get_next_atom), -1);
  rb_define_method(SwigClassOBAtom.klass, "begin_bonds", VALUEFUNC(_wrap_OBAtom_begin_bonds), -1);
  rb_define_method(SwigClassOBAtom.klass, "end_bonds", VALUEFUNC(_wrap_OBAtom_end_bonds), -1);
  rb_define_method(SwigClassOBAtom.klass, "begin_bond", VALUEFUNC(_wrap_OBAtom_begin_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "next_bond", VALUEFUNC(_wrap_OBAtom_next_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBAtom_begin_nbr_atom), -1);
  rb_define_method(SwigClassOBAtom.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBAtom_next_nbr_atom), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_distance", VALUEFUNC(_wrap_OBAtom_get_distance), -1);
  rb_define_method(SwigClassOBAtom.klass, "get_angle", VALUEFUNC(_wrap_OBAtom_get_angle), -1);
  rb_define_method(SwigClassOBAtom.klass, "new_residue", VALUEFUNC(_wrap_OBAtom_new_residue), -1);
  rb_define_method(SwigClassOBAtom.klass, "add_residue", VALUEFUNC(_wrap_OBAtom_add_residue), -1);
  rb_define_method(SwigClassOBAtom.klass, "delete_residue", VALUEFUNC(_wrap_OBAtom_delete_residue), -1);
  rb_define_method(SwigClassOBAtom.klass, "add_bond", VALUEFUNC(_wrap_OBAtom_add_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "insert_bond", VALUEFUNC(_wrap_OBAtom_insert_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "delete_bond", VALUEFUNC(_wrap_OBAtom_delete_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "clear_bond", VALUEFUNC(_wrap_OBAtom_clear_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "hto_methyl", VALUEFUNC(_wrap_OBAtom_hto_methyl), -1);
  rb_define_method(SwigClassOBAtom.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBAtom_set_hyb_and_geom), -1);
  rb_define_method(SwigClassOBAtom.klass, "force_no_h", VALUEFUNC(_wrap_OBAtom_force_no_h), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_no_hforced", VALUEFUNC(_wrap_OBAtom_has_no_hforced), -1);
  rb_define_method(SwigClassOBAtom.klass, "force_impl_h", VALUEFUNC(_wrap_OBAtom_force_impl_h), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_impl_hforced", VALUEFUNC(_wrap_OBAtom_has_impl_hforced), -1);
  rb_define_method(SwigClassOBAtom.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBAtom_count_free_oxygens), -1);
  rb_define_method(SwigClassOBAtom.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBAtom_implicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBAtom.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBAtom_explicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBAtom.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBAtom_member_of_ring_count), -1);
  rb_define_method(SwigClassOBAtom.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBAtom_member_of_ring_size), -1);
  rb_define_method(SwigClassOBAtom.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBAtom_count_ring_bonds), -1);
  rb_define_method(SwigClassOBAtom.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBAtom_smallest_bond_angle), -1);
  rb_define_method(SwigClassOBAtom.klass, "average_bond_angle", VALUEFUNC(_wrap_OBAtom_average_bond_angle), -1);
  rb_define_method(SwigClassOBAtom.klass, "bosum", VALUEFUNC(_wrap_OBAtom_bosum), -1);
  rb_define_method(SwigClassOBAtom.klass, "kbosum", VALUEFUNC(_wrap_OBAtom_kbosum), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_residue", VALUEFUNC(_wrap_OBAtom_has_residue), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_hydrogen", VALUEFUNC(_wrap_OBAtom_is_hydrogen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_carbon", VALUEFUNC(_wrap_OBAtom_is_carbon), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_nitrogen", VALUEFUNC(_wrap_OBAtom_is_nitrogen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_oxygen", VALUEFUNC(_wrap_OBAtom_is_oxygen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_sulfur", VALUEFUNC(_wrap_OBAtom_is_sulfur), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_phosphorus", VALUEFUNC(_wrap_OBAtom_is_phosphorus), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_aromatic", VALUEFUNC(_wrap_OBAtom_is_aromatic), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_in_ring", VALUEFUNC(_wrap_OBAtom_is_in_ring), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBAtom_is_in_ring_size), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_heteroatom", VALUEFUNC(_wrap_OBAtom_is_heteroatom), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBAtom_is_not_cor_h), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_connected", VALUEFUNC(_wrap_OBAtom_is_connected), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_one_three", VALUEFUNC(_wrap_OBAtom_is_one_three), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_one_four", VALUEFUNC(_wrap_OBAtom_is_one_four), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBAtom_is_carboxyl_oxygen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBAtom_is_phosphate_oxygen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBAtom_is_sulfate_oxygen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBAtom_is_nitro_oxygen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBAtom_is_amide_nitrogen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBAtom_is_polar_hydrogen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBAtom_is_non_polar_hydrogen), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBAtom_is_aromatic_noxide), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_chiral", VALUEFUNC(_wrap_OBAtom_is_chiral), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_axial", VALUEFUNC(_wrap_OBAtom_is_axial), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_clockwise", VALUEFUNC(_wrap_OBAtom_is_clockwise), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBAtom_is_anti_clockwise), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBAtom_is_positive_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBAtom_is_negative_stereo), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBAtom_has_chirality_specified), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBAtom_has_chiral_volume), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBAtom_is_hbond_acceptor), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBAtom_is_hbond_donor), -1);
  rb_define_method(SwigClassOBAtom.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBAtom_is_hbond_donor_h), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBAtom_has_alpha_beta_unsat), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBAtom_has_bond_of_order), -1);
  rb_define_method(SwigClassOBAtom.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBAtom_count_bonds_of_order), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBAtom_has_non_single_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_single_bond", VALUEFUNC(_wrap_OBAtom_has_single_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_double_bond", VALUEFUNC(_wrap_OBAtom_has_double_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBAtom_has_aromatic_bond), -1);
  rb_define_method(SwigClassOBAtom.klass, "matches_smarts", VALUEFUNC(_wrap_OBAtom_matches_smarts), -1);
  SwigClassOBAtom.mark = 0;
  SwigClassOBAtom.destroy = (void (*)(void *)) free_OpenBabel_OBAtom;
  SwigClassOBAtom.trackObjects = 0;
  rb_define_const(mOpenBabel, "OB_AROMATIC_BOND", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "OB_WEDGE_BOND", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenBabel, "OB_HASH_BOND", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenBabel, "OB_RING_BOND", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenBabel, "OB_TORUP_BOND", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenBabel, "OB_TORDOWN_BOND", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenBabel, "OB_KSINGLE_BOND", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenBabel, "OB_KDOUBLE_BOND", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenBabel, "OB_KTRIPLE_BOND", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenBabel, "OB_CLOSURE_BOND", SWIG_From_int(static_cast< int >((1 << 10))));
  
  SwigClassOBBond.klass = rb_define_class_under(mOpenBabel, "OBBond", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBBond, (void *) &SwigClassOBBond);
  rb_define_alloc_func(SwigClassOBBond.klass, _wrap_OBBond_allocate);
  rb_define_method(SwigClassOBBond.klass, "initialize", VALUEFUNC(_wrap_new_OBBond), -1);
  rb_define_method(SwigClassOBBond.klass, "Visit=", VALUEFUNC(_wrap_OBBond_Visit_set), -1);
  rb_define_method(SwigClassOBBond.klass, "Visit", VALUEFUNC(_wrap_OBBond_Visit_get), -1);
  rb_define_method(SwigClassOBBond.klass, "set_idx", VALUEFUNC(_wrap_OBBond_set_idx), -1);
  rb_define_method(SwigClassOBBond.klass, "set_bo", VALUEFUNC(_wrap_OBBond_set_bo), -1);
  rb_define_method(SwigClassOBBond.klass, "set_bond_order", VALUEFUNC(_wrap_OBBond_set_bond_order), -1);
  rb_define_method(SwigClassOBBond.klass, "set_begin", VALUEFUNC(_wrap_OBBond_set_begin), -1);
  rb_define_method(SwigClassOBBond.klass, "set_end", VALUEFUNC(_wrap_OBBond_set_end), -1);
  rb_define_method(SwigClassOBBond.klass, "set_parent", VALUEFUNC(_wrap_OBBond_set_parent), -1);
  rb_define_method(SwigClassOBBond.klass, "set_length", VALUEFUNC(_wrap_OBBond_set_length), -1);
  rb_define_method(SwigClassOBBond.klass, "set", VALUEFUNC(_wrap_OBBond_set), -1);
  rb_define_method(SwigClassOBBond.klass, "set_ksingle", VALUEFUNC(_wrap_OBBond_set_ksingle), -1);
  rb_define_method(SwigClassOBBond.klass, "set_kdouble", VALUEFUNC(_wrap_OBBond_set_kdouble), -1);
  rb_define_method(SwigClassOBBond.klass, "set_ktriple", VALUEFUNC(_wrap_OBBond_set_ktriple), -1);
  rb_define_method(SwigClassOBBond.klass, "set_aromatic", VALUEFUNC(_wrap_OBBond_set_aromatic), -1);
  rb_define_method(SwigClassOBBond.klass, "set_hash", VALUEFUNC(_wrap_OBBond_set_hash), -1);
  rb_define_method(SwigClassOBBond.klass, "set_wedge", VALUEFUNC(_wrap_OBBond_set_wedge), -1);
  rb_define_method(SwigClassOBBond.klass, "set_up", VALUEFUNC(_wrap_OBBond_set_up), -1);
  rb_define_method(SwigClassOBBond.klass, "set_down", VALUEFUNC(_wrap_OBBond_set_down), -1);
  rb_define_method(SwigClassOBBond.klass, "set_in_ring", VALUEFUNC(_wrap_OBBond_set_in_ring), -1);
  rb_define_method(SwigClassOBBond.klass, "set_closure", VALUEFUNC(_wrap_OBBond_set_closure), -1);
  rb_define_method(SwigClassOBBond.klass, "unset_hash", VALUEFUNC(_wrap_OBBond_unset_hash), -1);
  rb_define_method(SwigClassOBBond.klass, "unset_wedge", VALUEFUNC(_wrap_OBBond_unset_wedge), -1);
  rb_define_method(SwigClassOBBond.klass, "unset_up", VALUEFUNC(_wrap_OBBond_unset_up), -1);
  rb_define_method(SwigClassOBBond.klass, "unset_down", VALUEFUNC(_wrap_OBBond_unset_down), -1);
  rb_define_method(SwigClassOBBond.klass, "unset_aromatic", VALUEFUNC(_wrap_OBBond_unset_aromatic), -1);
  rb_define_method(SwigClassOBBond.klass, "unset_kekule", VALUEFUNC(_wrap_OBBond_unset_kekule), -1);
  rb_define_method(SwigClassOBBond.klass, "get_idx", VALUEFUNC(_wrap_OBBond_get_idx), -1);
  rb_define_method(SwigClassOBBond.klass, "get_bo", VALUEFUNC(_wrap_OBBond_get_bo), -1);
  rb_define_method(SwigClassOBBond.klass, "get_bond_order", VALUEFUNC(_wrap_OBBond_get_bond_order), -1);
  rb_define_method(SwigClassOBBond.klass, "get_flags", VALUEFUNC(_wrap_OBBond_get_flags), -1);
  rb_define_method(SwigClassOBBond.klass, "get_begin_atom_idx", VALUEFUNC(_wrap_OBBond_get_begin_atom_idx), -1);
  rb_define_method(SwigClassOBBond.klass, "get_end_atom_idx", VALUEFUNC(_wrap_OBBond_get_end_atom_idx), -1);
  rb_define_method(SwigClassOBBond.klass, "get_begin_atom", VALUEFUNC(_wrap_OBBond_get_begin_atom), -1);
  rb_define_method(SwigClassOBBond.klass, "get_end_atom", VALUEFUNC(_wrap_OBBond_get_end_atom), -1);
  rb_define_method(SwigClassOBBond.klass, "get_nbr_atom", VALUEFUNC(_wrap_OBBond_get_nbr_atom), -1);
  rb_define_method(SwigClassOBBond.klass, "get_parent", VALUEFUNC(_wrap_OBBond_get_parent), -1);
  rb_define_method(SwigClassOBBond.klass, "get_equib_length", VALUEFUNC(_wrap_OBBond_get_equib_length), -1);
  rb_define_method(SwigClassOBBond.klass, "get_length", VALUEFUNC(_wrap_OBBond_get_length), -1);
  rb_define_method(SwigClassOBBond.klass, "get_nbr_atom_idx", VALUEFUNC(_wrap_OBBond_get_nbr_atom_idx), -1);
  rb_define_method(SwigClassOBBond.klass, "is_aromatic", VALUEFUNC(_wrap_OBBond_is_aromatic), -1);
  rb_define_method(SwigClassOBBond.klass, "is_in_ring", VALUEFUNC(_wrap_OBBond_is_in_ring), -1);
  rb_define_method(SwigClassOBBond.klass, "is_rotor", VALUEFUNC(_wrap_OBBond_is_rotor), -1);
  rb_define_method(SwigClassOBBond.klass, "is_amide", VALUEFUNC(_wrap_OBBond_is_amide), -1);
  rb_define_method(SwigClassOBBond.klass, "is_primary_amide", VALUEFUNC(_wrap_OBBond_is_primary_amide), -1);
  rb_define_method(SwigClassOBBond.klass, "is_secondary_amide", VALUEFUNC(_wrap_OBBond_is_secondary_amide), -1);
  rb_define_method(SwigClassOBBond.klass, "is_ester", VALUEFUNC(_wrap_OBBond_is_ester), -1);
  rb_define_method(SwigClassOBBond.klass, "is_carbonyl", VALUEFUNC(_wrap_OBBond_is_carbonyl), -1);
  rb_define_method(SwigClassOBBond.klass, "is_single", VALUEFUNC(_wrap_OBBond_is_single), -1);
  rb_define_method(SwigClassOBBond.klass, "is_double", VALUEFUNC(_wrap_OBBond_is_double), -1);
  rb_define_method(SwigClassOBBond.klass, "is_triple", VALUEFUNC(_wrap_OBBond_is_triple), -1);
  rb_define_method(SwigClassOBBond.klass, "is_ksingle", VALUEFUNC(_wrap_OBBond_is_ksingle), -1);
  rb_define_method(SwigClassOBBond.klass, "is_kdouble", VALUEFUNC(_wrap_OBBond_is_kdouble), -1);
  rb_define_method(SwigClassOBBond.klass, "is_ktriple", VALUEFUNC(_wrap_OBBond_is_ktriple), -1);
  rb_define_method(SwigClassOBBond.klass, "is_closure", VALUEFUNC(_wrap_OBBond_is_closure), -1);
  rb_define_method(SwigClassOBBond.klass, "is_up", VALUEFUNC(_wrap_OBBond_is_up), -1);
  rb_define_method(SwigClassOBBond.klass, "is_down", VALUEFUNC(_wrap_OBBond_is_down), -1);
  rb_define_method(SwigClassOBBond.klass, "is_wedge", VALUEFUNC(_wrap_OBBond_is_wedge), -1);
  rb_define_method(SwigClassOBBond.klass, "is_hash", VALUEFUNC(_wrap_OBBond_is_hash), -1);
  rb_define_method(SwigClassOBBond.klass, "is_double_bond_geometry", VALUEFUNC(_wrap_OBBond_is_double_bond_geometry), -1);
  SwigClassOBBond.mark = 0;
  SwigClassOBBond.destroy = (void (*)(void *)) free_OpenBabel_OBBond;
  SwigClassOBBond.trackObjects = 0;
  rb_define_const(mOpenBabel, "OB_SSSR_MOL", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "OB_RINGFLAGS_MOL", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenBabel, "OB_AROMATIC_MOL", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenBabel, "OB_ATOMTYPES_MOL", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenBabel, "OB_CHIRALITY_MOL", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenBabel, "OB_PCHARGE_MOL", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenBabel, "OB_HYBRID_MOL", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenBabel, "OB_IMPVAL_MOL", SWIG_From_int(static_cast< int >((1 << 9))));
  rb_define_const(mOpenBabel, "OB_KEKULE_MOL", SWIG_From_int(static_cast< int >((1 << 10))));
  rb_define_const(mOpenBabel, "OB_CLOSURE_MOL", SWIG_From_int(static_cast< int >((1 << 11))));
  rb_define_const(mOpenBabel, "OB_H_ADDED_MOL", SWIG_From_int(static_cast< int >((1 << 12))));
  rb_define_const(mOpenBabel, "OB_PH_CORRECTED_MOL", SWIG_From_int(static_cast< int >((1 << 13))));
  rb_define_const(mOpenBabel, "OB_AROM_CORRECTED_MOL", SWIG_From_int(static_cast< int >((1 << 14))));
  rb_define_const(mOpenBabel, "OB_CHAINS_MOL", SWIG_From_int(static_cast< int >((1 << 15))));
  rb_define_const(mOpenBabel, "OB_TCHARGE_MOL", SWIG_From_int(static_cast< int >((1 << 16))));
  rb_define_const(mOpenBabel, "OB_TSPIN_MOL", SWIG_From_int(static_cast< int >((1 << 17))));
  rb_define_const(mOpenBabel, "OB_RINGTYPES_MOL", SWIG_From_int(static_cast< int >((1 << 18))));
  rb_define_const(mOpenBabel, "OB_CURRENT_CONFORMER", SWIG_From_int(static_cast< int >(-1)));
  
  SwigClassOBMol.klass = rb_define_class_under(mOpenBabel, "OBMol", ((swig_class *) SWIGTYPE_p_OpenBabel__OBBase->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMol, (void *) &SwigClassOBMol);
  rb_define_alloc_func(SwigClassOBMol.klass, _wrap_OBMol_allocate);
  rb_define_method(SwigClassOBMol.klass, "initialize", VALUEFUNC(_wrap_new_OBMol), -1);
  rb_define_method(SwigClassOBMol.klass, "reserve_atoms", VALUEFUNC(_wrap_OBMol_reserve_atoms), -1);
  rb_define_method(SwigClassOBMol.klass, "create_atom", VALUEFUNC(_wrap_OBMol_create_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "create_bond", VALUEFUNC(_wrap_OBMol_create_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "create_residue", VALUEFUNC(_wrap_OBMol_create_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "destroy_atom", VALUEFUNC(_wrap_OBMol_destroy_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "destroy_bond", VALUEFUNC(_wrap_OBMol_destroy_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "destroy_residue", VALUEFUNC(_wrap_OBMol_destroy_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "add_atom", VALUEFUNC(_wrap_OBMol_add_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "insert_atom", VALUEFUNC(_wrap_OBMol_insert_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "add_bond", VALUEFUNC(_wrap_OBMol_add_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "add_residue", VALUEFUNC(_wrap_OBMol_add_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "new_atom", VALUEFUNC(_wrap_OBMol_new_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "new_bond", VALUEFUNC(_wrap_OBMol_new_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "new_residue", VALUEFUNC(_wrap_OBMol_new_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_atom", VALUEFUNC(_wrap_OBMol_delete_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_bond", VALUEFUNC(_wrap_OBMol_delete_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_residue", VALUEFUNC(_wrap_OBMol_delete_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_modify", VALUEFUNC(_wrap_OBMol_begin_modify), -1);
  rb_define_method(SwigClassOBMol.klass, "end_modify", VALUEFUNC(_wrap_OBMol_end_modify), -1);
  rb_define_method(SwigClassOBMol.klass, "get_mod", VALUEFUNC(_wrap_OBMol_get_mod), -1);
  rb_define_method(SwigClassOBMol.klass, "increment_mod", VALUEFUNC(_wrap_OBMol_increment_mod), -1);
  rb_define_method(SwigClassOBMol.klass, "decrement_mod", VALUEFUNC(_wrap_OBMol_decrement_mod), -1);
  rb_define_method(SwigClassOBMol.klass, "get_flags", VALUEFUNC(_wrap_OBMol_get_flags), -1);
  rb_define_method(SwigClassOBMol.klass, "get_title", VALUEFUNC(_wrap_OBMol_get_title), -1);
  rb_define_method(SwigClassOBMol.klass, "num_atoms", VALUEFUNC(_wrap_OBMol_num_atoms), -1);
  rb_define_method(SwigClassOBMol.klass, "num_bonds", VALUEFUNC(_wrap_OBMol_num_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "num_hvy_atoms", VALUEFUNC(_wrap_OBMol_num_hvy_atoms), -1);
  rb_define_method(SwigClassOBMol.klass, "num_residues", VALUEFUNC(_wrap_OBMol_num_residues), -1);
  rb_define_method(SwigClassOBMol.klass, "num_rotors", VALUEFUNC(_wrap_OBMol_num_rotors), -1);
  rb_define_method(SwigClassOBMol.klass, "get_atom", VALUEFUNC(_wrap_OBMol_get_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "get_first_atom", VALUEFUNC(_wrap_OBMol_get_first_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "get_bond", VALUEFUNC(_wrap_OBMol_get_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "get_residue", VALUEFUNC(_wrap_OBMol_get_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "get_internal_coord", VALUEFUNC(_wrap_OBMol_get_internal_coord), -1);
  rb_define_method(SwigClassOBMol.klass, "get_torsion", VALUEFUNC(_wrap_OBMol_get_torsion), -1);
  rb_define_method(SwigClassOBMol.klass, "get_angle", VALUEFUNC(_wrap_OBMol_get_angle), -1);
  rb_define_method(SwigClassOBMol.klass, "get_formula", VALUEFUNC(_wrap_OBMol_get_formula), -1);
  rb_define_method(SwigClassOBMol.klass, "get_spaced_formula", VALUEFUNC(_wrap_OBMol_get_spaced_formula), -1);
  rb_define_method(SwigClassOBMol.klass, "get_mol_wt", VALUEFUNC(_wrap_OBMol_get_mol_wt), -1);
  rb_define_method(SwigClassOBMol.klass, "get_exact_mass", VALUEFUNC(_wrap_OBMol_get_exact_mass), -1);
  rb_define_method(SwigClassOBMol.klass, "get_total_charge", VALUEFUNC(_wrap_OBMol_get_total_charge), -1);
  rb_define_method(SwigClassOBMol.klass, "get_total_spin_multiplicity", VALUEFUNC(_wrap_OBMol_get_total_spin_multiplicity), -1);
  rb_define_method(SwigClassOBMol.klass, "get_dimension", VALUEFUNC(_wrap_OBMol_get_dimension), -1);
  rb_define_method(SwigClassOBMol.klass, "get_coordinates", VALUEFUNC(_wrap_OBMol_get_coordinates), -1);
  rb_define_method(SwigClassOBMol.klass, "get_sssr", VALUEFUNC(_wrap_OBMol_get_sssr), -1);
  rb_define_method(SwigClassOBMol.klass, "automatic_formal_charge", VALUEFUNC(_wrap_OBMol_automatic_formal_charge), -1);
  rb_define_method(SwigClassOBMol.klass, "automatic_partial_charge", VALUEFUNC(_wrap_OBMol_automatic_partial_charge), -1);
  rb_define_method(SwigClassOBMol.klass, "set_title", VALUEFUNC(_wrap_OBMol_set_title), -1);
  rb_define_method(SwigClassOBMol.klass, "set_formula", VALUEFUNC(_wrap_OBMol_set_formula), -1);
  rb_define_method(SwigClassOBMol.klass, "set_energy", VALUEFUNC(_wrap_OBMol_set_energy), -1);
  rb_define_method(SwigClassOBMol.klass, "set_dimension", VALUEFUNC(_wrap_OBMol_set_dimension), -1);
  rb_define_method(SwigClassOBMol.klass, "set_total_charge", VALUEFUNC(_wrap_OBMol_set_total_charge), -1);
  rb_define_method(SwigClassOBMol.klass, "set_total_spin_multiplicity", VALUEFUNC(_wrap_OBMol_set_total_spin_multiplicity), -1);
  rb_define_method(SwigClassOBMol.klass, "set_internal_coord", VALUEFUNC(_wrap_OBMol_set_internal_coord), -1);
  rb_define_method(SwigClassOBMol.klass, "set_automatic_formal_charge", VALUEFUNC(_wrap_OBMol_set_automatic_formal_charge), -1);
  rb_define_method(SwigClassOBMol.klass, "set_automatic_partial_charge", VALUEFUNC(_wrap_OBMol_set_automatic_partial_charge), -1);
  rb_define_method(SwigClassOBMol.klass, "set_aromatic_perceived", VALUEFUNC(_wrap_OBMol_set_aromatic_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_sssrperceived", VALUEFUNC(_wrap_OBMol_set_sssrperceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_ring_atoms_and_bonds_perceived", VALUEFUNC(_wrap_OBMol_set_ring_atoms_and_bonds_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_atom_types_perceived", VALUEFUNC(_wrap_OBMol_set_atom_types_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_ring_types_perceived", VALUEFUNC(_wrap_OBMol_set_ring_types_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_chains_perceived", VALUEFUNC(_wrap_OBMol_set_chains_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_chirality_perceived", VALUEFUNC(_wrap_OBMol_set_chirality_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_partial_charges_perceived", VALUEFUNC(_wrap_OBMol_set_partial_charges_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_hybridization_perceived", VALUEFUNC(_wrap_OBMol_set_hybridization_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_implicit_valence_perceived", VALUEFUNC(_wrap_OBMol_set_implicit_valence_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_kekule_perceived", VALUEFUNC(_wrap_OBMol_set_kekule_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_closure_bonds_perceived", VALUEFUNC(_wrap_OBMol_set_closure_bonds_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "set_hydrogens_added", VALUEFUNC(_wrap_OBMol_set_hydrogens_added), -1);
  rb_define_method(SwigClassOBMol.klass, "set_corrected_for_ph", VALUEFUNC(_wrap_OBMol_set_corrected_for_ph), -1);
  rb_define_method(SwigClassOBMol.klass, "set_aromatic_corrected", VALUEFUNC(_wrap_OBMol_set_aromatic_corrected), -1);
  rb_define_method(SwigClassOBMol.klass, "set_spin_multiplicity_assigned", VALUEFUNC(_wrap_OBMol_set_spin_multiplicity_assigned), -1);
  rb_define_method(SwigClassOBMol.klass, "set_flags", VALUEFUNC(_wrap_OBMol_set_flags), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_aromatic_perceived", VALUEFUNC(_wrap_OBMol_unset_aromatic_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_sssrperceived", VALUEFUNC(_wrap_OBMol_unset_sssrperceived), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_ring_types_perceived", VALUEFUNC(_wrap_OBMol_unset_ring_types_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_partial_charges_perceived", VALUEFUNC(_wrap_OBMol_unset_partial_charges_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_implicit_valence_perceived", VALUEFUNC(_wrap_OBMol_unset_implicit_valence_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_hydrogens_added", VALUEFUNC(_wrap_OBMol_unset_hydrogens_added), -1);
  rb_define_method(SwigClassOBMol.klass, "unset_flag", VALUEFUNC(_wrap_OBMol_unset_flag), -1);
  rb_define_singleton_method(SwigClassOBMol.klass, "class_description", VALUEFUNC(_wrap_OBMol_class_description), -1);
  rb_define_method(SwigClassOBMol.klass, "renumber_atoms", VALUEFUNC(_wrap_OBMol_renumber_atoms), -1);
  rb_define_method(SwigClassOBMol.klass, "set_coordinates", VALUEFUNC(_wrap_OBMol_set_coordinates), -1);
  rb_define_method(SwigClassOBMol.klass, "to_inertial_frame", VALUEFUNC(_wrap_OBMol_to_inertial_frame), -1);
  rb_define_method(SwigClassOBMol.klass, "translate", VALUEFUNC(_wrap_OBMol_translate), -1);
  rb_define_method(SwigClassOBMol.klass, "rotate", VALUEFUNC(_wrap_OBMol_rotate), -1);
  rb_define_method(SwigClassOBMol.klass, "kekulize", VALUEFUNC(_wrap_OBMol_kekulize), -1);
  rb_define_method(SwigClassOBMol.klass, "perceive_kekule_bonds", VALUEFUNC(_wrap_OBMol_perceive_kekule_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "new_perceive_kekule_bonds", VALUEFUNC(_wrap_OBMol_new_perceive_kekule_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_hydrogens", VALUEFUNC(_wrap_OBMol_delete_hydrogens), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_non_polar_hydrogens", VALUEFUNC(_wrap_OBMol_delete_non_polar_hydrogens), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_hydrogen", VALUEFUNC(_wrap_OBMol_delete_hydrogen), -1);
  rb_define_method(SwigClassOBMol.klass, "add_hydrogens", VALUEFUNC(_wrap_OBMol_add_hydrogens), -1);
  rb_define_method(SwigClassOBMol.klass, "add_polar_hydrogens", VALUEFUNC(_wrap_OBMol_add_polar_hydrogens), -1);
  rb_define_method(SwigClassOBMol.klass, "strip_salts", VALUEFUNC(_wrap_OBMol_strip_salts), -1);
  rb_define_method(SwigClassOBMol.klass, "separate", VALUEFUNC(_wrap_OBMol_separate), -1);
  rb_define_method(SwigClassOBMol.klass, "get_next_fragment", VALUEFUNC(_wrap_OBMol_get_next_fragment), -1);
  rb_define_method(SwigClassOBMol.klass, "convert_dative_bonds", VALUEFUNC(_wrap_OBMol_convert_dative_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "correct_for_ph", VALUEFUNC(_wrap_OBMol_correct_for_ph), -1);
  rb_define_method(SwigClassOBMol.klass, "assign_spin_multiplicity", VALUEFUNC(_wrap_OBMol_assign_spin_multiplicity), -1);
  rb_define_method(SwigClassOBMol.klass, "center", VALUEFUNC(_wrap_OBMol_center), -1);
  rb_define_method(SwigClassOBMol.klass, "set_torsion", VALUEFUNC(_wrap_OBMol_set_torsion), -1);
  rb_define_method(SwigClassOBMol.klass, "find_sssr", VALUEFUNC(_wrap_OBMol_find_sssr), -1);
  rb_define_method(SwigClassOBMol.klass, "find_ring_atoms_and_bonds", VALUEFUNC(_wrap_OBMol_find_ring_atoms_and_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "find_chiral_centers", VALUEFUNC(_wrap_OBMol_find_chiral_centers), -1);
  rb_define_method(SwigClassOBMol.klass, "find_children", VALUEFUNC(_wrap_OBMol_find_children), -1);
  rb_define_method(SwigClassOBMol.klass, "find_largest_fragment", VALUEFUNC(_wrap_OBMol_find_largest_fragment), -1);
  rb_define_method(SwigClassOBMol.klass, "contig_frag_list", VALUEFUNC(_wrap_OBMol_contig_frag_list), -1);
  rb_define_method(SwigClassOBMol.klass, "align", VALUEFUNC(_wrap_OBMol_align), -1);
  rb_define_method(SwigClassOBMol.klass, "connect_the_dots", VALUEFUNC(_wrap_OBMol_connect_the_dots), -1);
  rb_define_method(SwigClassOBMol.klass, "perceive_bond_orders", VALUEFUNC(_wrap_OBMol_perceive_bond_orders), -1);
  rb_define_method(SwigClassOBMol.klass, "find_angles", VALUEFUNC(_wrap_OBMol_find_angles), -1);
  rb_define_method(SwigClassOBMol.klass, "find_torsions", VALUEFUNC(_wrap_OBMol_find_torsions), -1);
  rb_define_method(SwigClassOBMol.klass, "get_gtdvector", VALUEFUNC(_wrap_OBMol_get_gtdvector), -1);
  rb_define_method(SwigClassOBMol.klass, "get_givector", VALUEFUNC(_wrap_OBMol_get_givector), -1);
  rb_define_method(SwigClassOBMol.klass, "get_gidvector", VALUEFUNC(_wrap_OBMol_get_gidvector), -1);
  rb_define_method(SwigClassOBMol.klass, "has_2d", VALUEFUNC(_wrap_OBMol_has_2d), -1);
  rb_define_method(SwigClassOBMol.klass, "has_3d", VALUEFUNC(_wrap_OBMol_has_3d), -1);
  rb_define_method(SwigClassOBMol.klass, "has_non_zero_coords", VALUEFUNC(_wrap_OBMol_has_non_zero_coords), -1);
  rb_define_method(SwigClassOBMol.klass, "has_aromatic_perceived", VALUEFUNC(_wrap_OBMol_has_aromatic_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_sssrperceived", VALUEFUNC(_wrap_OBMol_has_sssrperceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_ring_atoms_and_bonds_perceived", VALUEFUNC(_wrap_OBMol_has_ring_atoms_and_bonds_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_atom_types_perceived", VALUEFUNC(_wrap_OBMol_has_atom_types_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_ring_types_perceived", VALUEFUNC(_wrap_OBMol_has_ring_types_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_chirality_perceived", VALUEFUNC(_wrap_OBMol_has_chirality_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_partial_charges_perceived", VALUEFUNC(_wrap_OBMol_has_partial_charges_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_hybridization_perceived", VALUEFUNC(_wrap_OBMol_has_hybridization_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_implicit_valence_perceived", VALUEFUNC(_wrap_OBMol_has_implicit_valence_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_kekule_perceived", VALUEFUNC(_wrap_OBMol_has_kekule_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_closure_bonds_perceived", VALUEFUNC(_wrap_OBMol_has_closure_bonds_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_chains_perceived", VALUEFUNC(_wrap_OBMol_has_chains_perceived), -1);
  rb_define_method(SwigClassOBMol.klass, "has_hydrogens_added", VALUEFUNC(_wrap_OBMol_has_hydrogens_added), -1);
  rb_define_method(SwigClassOBMol.klass, "has_aromatic_corrected", VALUEFUNC(_wrap_OBMol_has_aromatic_corrected), -1);
  rb_define_method(SwigClassOBMol.klass, "is_corrected_for_ph", VALUEFUNC(_wrap_OBMol_is_corrected_for_ph), -1);
  rb_define_method(SwigClassOBMol.klass, "has_spin_multiplicity_assigned", VALUEFUNC(_wrap_OBMol_has_spin_multiplicity_assigned), -1);
  rb_define_method(SwigClassOBMol.klass, "is_chiral", VALUEFUNC(_wrap_OBMol_is_chiral), -1);
  rb_define_method(SwigClassOBMol.klass, "empty", VALUEFUNC(_wrap_OBMol_empty), -1);
  rb_define_method(SwigClassOBMol.klass, "num_conformers", VALUEFUNC(_wrap_OBMol_num_conformers), -1);
  rb_define_method(SwigClassOBMol.klass, "set_conformers", VALUEFUNC(_wrap_OBMol_set_conformers), -1);
  rb_define_method(SwigClassOBMol.klass, "add_conformer", VALUEFUNC(_wrap_OBMol_add_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "set_conformer", VALUEFUNC(_wrap_OBMol_set_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "copy_conformer", VALUEFUNC(_wrap_OBMol_copy_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "delete_conformer", VALUEFUNC(_wrap_OBMol_delete_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "get_conformer", VALUEFUNC(_wrap_OBMol_get_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "set_energies", VALUEFUNC(_wrap_OBMol_set_energies), -1);
  rb_define_method(SwigClassOBMol.klass, "get_energies", VALUEFUNC(_wrap_OBMol_get_energies), -1);
  rb_define_method(SwigClassOBMol.klass, "get_energy", VALUEFUNC(_wrap_OBMol_get_energy), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_conformer", VALUEFUNC(_wrap_OBMol_begin_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "next_conformer", VALUEFUNC(_wrap_OBMol_next_conformer), -1);
  rb_define_method(SwigClassOBMol.klass, "get_conformers", VALUEFUNC(_wrap_OBMol_get_conformers), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_atoms", VALUEFUNC(_wrap_OBMol_begin_atoms), -1);
  rb_define_method(SwigClassOBMol.klass, "end_atoms", VALUEFUNC(_wrap_OBMol_end_atoms), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_bonds", VALUEFUNC(_wrap_OBMol_begin_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "end_bonds", VALUEFUNC(_wrap_OBMol_end_bonds), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_residues", VALUEFUNC(_wrap_OBMol_begin_residues), -1);
  rb_define_method(SwigClassOBMol.klass, "end_residues", VALUEFUNC(_wrap_OBMol_end_residues), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_atom", VALUEFUNC(_wrap_OBMol_begin_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "next_atom", VALUEFUNC(_wrap_OBMol_next_atom), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_bond", VALUEFUNC(_wrap_OBMol_begin_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "next_bond", VALUEFUNC(_wrap_OBMol_next_bond), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_residue", VALUEFUNC(_wrap_OBMol_begin_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "next_residue", VALUEFUNC(_wrap_OBMol_next_residue), -1);
  rb_define_method(SwigClassOBMol.klass, "begin_internal_coord", VALUEFUNC(_wrap_OBMol_begin_internal_coord), -1);
  rb_define_method(SwigClassOBMol.klass, "next_internal_coord", VALUEFUNC(_wrap_OBMol_next_internal_coord), -1);
  SwigClassOBMol.mark = 0;
  SwigClassOBMol.destroy = (void (*)(void *)) free_OpenBabel_OBMol;
  SwigClassOBMol.trackObjects = 0;
  rb_define_module_function(mOpenBabel, "throw_error", VALUEFUNC(_wrap_throw_error), -1);
  rb_define_module_function(mOpenBabel, "cartesian_to_internal", VALUEFUNC(_wrap_cartesian_to_internal), -1);
  rb_define_module_function(mOpenBabel, "internal_to_cartesian", VALUEFUNC(_wrap_internal_to_cartesian), -1);
  rb_define_module_function(mOpenBabel, "new_extension", VALUEFUNC(_wrap_new_extension), -1);
  rb_define_singleton_method(mOpenBabel, "etab", VALUEFUNC(_wrap_etab_get), 0);
  rb_define_singleton_method(mOpenBabel, "etab=", VALUEFUNC(_wrap_etab_set), 1);
  rb_define_singleton_method(mOpenBabel, "ttab", VALUEFUNC(_wrap_ttab_get), 0);
  rb_define_singleton_method(mOpenBabel, "ttab=", VALUEFUNC(_wrap_ttab_set), 1);
  rb_define_singleton_method(mOpenBabel, "isotab", VALUEFUNC(_wrap_isotab_get), 0);
  rb_define_singleton_method(mOpenBabel, "isotab=", VALUEFUNC(_wrap_isotab_set), 1);
  rb_define_singleton_method(mOpenBabel, "aromtyper", VALUEFUNC(_wrap_aromtyper_get), 0);
  rb_define_singleton_method(mOpenBabel, "aromtyper=", VALUEFUNC(_wrap_aromtyper_set), 1);
  rb_define_singleton_method(mOpenBabel, "atomtyper", VALUEFUNC(_wrap_atomtyper_get), 0);
  rb_define_singleton_method(mOpenBabel, "atomtyper=", VALUEFUNC(_wrap_atomtyper_set), 1);
  rb_define_singleton_method(mOpenBabel, "chainsparser", VALUEFUNC(_wrap_chainsparser_get), 0);
  rb_define_singleton_method(mOpenBabel, "chainsparser=", VALUEFUNC(_wrap_chainsparser_set), 1);
  rb_define_singleton_method(mOpenBabel, "resdat", VALUEFUNC(_wrap_resdat_get), 0);
  rb_define_singleton_method(mOpenBabel, "resdat=", VALUEFUNC(_wrap_resdat_set), 1);
  rb_define_const(mOpenBabel, "BUFF_SIZE", SWIG_From_int(static_cast< int >(32768)));
  rb_define_module_function(mOpenBabel, "get_rmat", VALUEFUNC(_wrap_get_rmat), -1);
  rb_define_module_function(mOpenBabel, "ob_make_rmat", VALUEFUNC(_wrap_ob_make_rmat), -1);
  rb_define_module_function(mOpenBabel, "qtrfit", VALUEFUNC(_wrap_qtrfit), -1);
  rb_define_module_function(mOpenBabel, "superimpose", VALUEFUNC(_wrap_superimpose), -1);
  
  SwigClassOBRing.klass = rb_define_class_under(mOpenBabel, "OBRing", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRing, (void *) &SwigClassOBRing);
  rb_define_alloc_func(SwigClassOBRing.klass, _wrap_OBRing_allocate);
  rb_define_method(SwigClassOBRing.klass, "initialize", VALUEFUNC(_wrap_new_OBRing), -1);
  rb_define_method(SwigClassOBRing.klass, "_path=", VALUEFUNC(_wrap_OBRing__path_set), -1);
  rb_define_method(SwigClassOBRing.klass, "_path", VALUEFUNC(_wrap_OBRing__path_get), -1);
  rb_define_method(SwigClassOBRing.klass, "_pathset=", VALUEFUNC(_wrap_OBRing__pathset_set), -1);
  rb_define_method(SwigClassOBRing.klass, "_pathset", VALUEFUNC(_wrap_OBRing__pathset_get), -1);
  rb_define_method(SwigClassOBRing.klass, "size", VALUEFUNC(_wrap_OBRing_size), -1);
  rb_define_method(SwigClassOBRing.klass, "path_size", VALUEFUNC(_wrap_OBRing_path_size), -1);
  rb_define_method(SwigClassOBRing.klass, "is_aromatic", VALUEFUNC(_wrap_OBRing_is_aromatic), -1);
  rb_define_method(SwigClassOBRing.klass, "set_type", VALUEFUNC(_wrap_OBRing_set_type), -1);
  rb_define_method(SwigClassOBRing.klass, "get_type", VALUEFUNC(_wrap_OBRing_get_type), -1);
  rb_define_method(SwigClassOBRing.klass, "get_root_atom", VALUEFUNC(_wrap_OBRing_get_root_atom), -1);
  rb_define_method(SwigClassOBRing.klass, "is_member", VALUEFUNC(_wrap_OBRing_is_member), -1);
  rb_define_method(SwigClassOBRing.klass, "is_in_ring", VALUEFUNC(_wrap_OBRing_is_in_ring), -1);
  rb_define_method(SwigClassOBRing.klass, "set_parent", VALUEFUNC(_wrap_OBRing_set_parent), -1);
  rb_define_method(SwigClassOBRing.klass, "get_parent", VALUEFUNC(_wrap_OBRing_get_parent), -1);
  rb_define_method(SwigClassOBRing.klass, "find_center_and_normal", VALUEFUNC(_wrap_OBRing_find_center_and_normal), -1);
  SwigClassOBRing.mark = 0;
  SwigClassOBRing.destroy = (void (*)(void *)) free_OpenBabel_OBRing;
  SwigClassOBRing.trackObjects = 0;
  rb_define_module_function(mOpenBabel, "compare_ring_size", VALUEFUNC(_wrap_compare_ring_size), -1);
  
  SwigClassOBRingSearch.klass = rb_define_class_under(mOpenBabel, "OBRingSearch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRingSearch, (void *) &SwigClassOBRingSearch);
  rb_define_alloc_func(SwigClassOBRingSearch.klass, _wrap_OBRingSearch_allocate);
  rb_define_method(SwigClassOBRingSearch.klass, "initialize", VALUEFUNC(_wrap_new_OBRingSearch), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "sort_rings", VALUEFUNC(_wrap_OBRingSearch_sort_rings), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "remove_redundant", VALUEFUNC(_wrap_OBRingSearch_remove_redundant), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "add_ring_from_closure", VALUEFUNC(_wrap_OBRingSearch_add_ring_from_closure), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "save_unique_ring", VALUEFUNC(_wrap_OBRingSearch_save_unique_ring), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "write_rings", VALUEFUNC(_wrap_OBRingSearch_write_rings), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "begin_rings", VALUEFUNC(_wrap_OBRingSearch_begin_rings), -1);
  rb_define_method(SwigClassOBRingSearch.klass, "end_rings", VALUEFUNC(_wrap_OBRingSearch_end_rings), -1);
  SwigClassOBRingSearch.mark = 0;
  SwigClassOBRingSearch.destroy = (void (*)(void *)) free_OpenBabel_OBRingSearch;
  SwigClassOBRingSearch.trackObjects = 0;
  
  SwigClassOBRTree.klass = rb_define_class_under(mOpenBabel, "OBRTree", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBRTree, (void *) &SwigClassOBRTree);
  rb_define_alloc_func(SwigClassOBRTree.klass, _wrap_OBRTree_allocate);
  rb_define_method(SwigClassOBRTree.klass, "initialize", VALUEFUNC(_wrap_new_OBRTree), -1);
  rb_define_method(SwigClassOBRTree.klass, "get_atom_idx", VALUEFUNC(_wrap_OBRTree_get_atom_idx), -1);
  rb_define_method(SwigClassOBRTree.klass, "path_to_root", VALUEFUNC(_wrap_OBRTree_path_to_root), -1);
  SwigClassOBRTree.mark = 0;
  SwigClassOBRTree.destroy = (void (*)(void *)) free_OpenBabel_OBRTree;
  SwigClassOBRTree.trackObjects = 0;
  
  SwigClassOBSmartsPattern.klass = rb_define_class_under(mOpenBabel, "OBSmartsPattern", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSmartsPattern, (void *) &SwigClassOBSmartsPattern);
  rb_define_alloc_func(SwigClassOBSmartsPattern.klass, _wrap_OBSmartsPattern_allocate);
  rb_define_method(SwigClassOBSmartsPattern.klass, "initialize", VALUEFUNC(_wrap_new_OBSmartsPattern), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "init", VALUEFUNC(_wrap_OBSmartsPattern_init), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_smarts", VALUEFUNC(_wrap_OBSmartsPattern_get_smarts), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "empty", VALUEFUNC(_wrap_OBSmartsPattern_empty), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "is_valid", VALUEFUNC(_wrap_OBSmartsPattern_is_valid), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "num_atoms", VALUEFUNC(_wrap_OBSmartsPattern_num_atoms), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "num_bonds", VALUEFUNC(_wrap_OBSmartsPattern_num_bonds), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_bond", VALUEFUNC(_wrap_OBSmartsPattern_get_bond), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_atomic_num", VALUEFUNC(_wrap_OBSmartsPattern_get_atomic_num), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_charge", VALUEFUNC(_wrap_OBSmartsPattern_get_charge), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_vector_binding", VALUEFUNC(_wrap_OBSmartsPattern_get_vector_binding), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "match", VALUEFUNC(_wrap_OBSmartsPattern_match), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "restricted_match", VALUEFUNC(_wrap_OBSmartsPattern_restricted_match), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "num_matches", VALUEFUNC(_wrap_OBSmartsPattern_num_matches), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_map_list", VALUEFUNC(_wrap_OBSmartsPattern_get_map_list), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "begin_mlist", VALUEFUNC(_wrap_OBSmartsPattern_begin_mlist), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "end_mlist", VALUEFUNC(_wrap_OBSmartsPattern_end_mlist), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "get_umap_list", VALUEFUNC(_wrap_OBSmartsPattern_get_umap_list), -1);
  rb_define_method(SwigClassOBSmartsPattern.klass, "write_map_list", VALUEFUNC(_wrap_OBSmartsPattern_write_map_list), -1);
  SwigClassOBSmartsPattern.mark = 0;
  SwigClassOBSmartsPattern.destroy = (void (*)(void *)) free_OpenBabel_OBSmartsPattern;
  SwigClassOBSmartsPattern.trackObjects = 0;
  
  SwigClassOBSSMatch.klass = rb_define_class_under(mOpenBabel, "OBSSMatch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBSSMatch, (void *) &SwigClassOBSSMatch);
  rb_define_alloc_func(SwigClassOBSSMatch.klass, _wrap_OBSSMatch_allocate);
  rb_define_method(SwigClassOBSSMatch.klass, "initialize", VALUEFUNC(_wrap_new_OBSSMatch), -1);
  rb_define_method(SwigClassOBSSMatch.klass, "match", VALUEFUNC(_wrap_OBSSMatch_match), -1);
  SwigClassOBSSMatch.mark = 0;
  SwigClassOBSSMatch.destroy = (void (*)(void *)) free_OpenBabel_OBSSMatch;
  SwigClassOBSSMatch.trackObjects = 0;
  rb_define_module_function(mOpenBabel, "smarts_lex_replace", VALUEFUNC(_wrap_smarts_lex_replace), -1);
  
  SwigClassOBFingerprint.klass = rb_define_class_under(mOpenBabel, "OBFingerprint", ((swig_class *) SWIGTYPE_p_OpenBabel__OBPlugin->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFingerprint, (void *) &SwigClassOBFingerprint);
  rb_undef_alloc_func(SwigClassOBFingerprint.klass);
  rb_define_singleton_method(SwigClassOBFingerprint.klass, "default", VALUEFUNC(_wrap_OBFingerprint_default), -1);
  rb_define_singleton_method(SwigClassOBFingerprint.klass, "find_type", VALUEFUNC(_wrap_OBFingerprint_find_type), -1);
  rb_define_method(SwigClassOBFingerprint.klass, "type_id", VALUEFUNC(_wrap_OBFingerprint_type_id), -1);
  rb_define_method(SwigClassOBFingerprint.klass, "set_bit", VALUEFUNC(_wrap_OBFingerprint_set_bit), -1);
  rb_define_method(SwigClassOBFingerprint.klass, "get_bit", VALUEFUNC(_wrap_OBFingerprint_get_bit), -1);
  rb_define_method(SwigClassOBFingerprint.klass, "fold", VALUEFUNC(_wrap_OBFingerprint_fold), -1);
  rb_define_method(SwigClassOBFingerprint.klass, "get_fingerprint", VALUEFUNC(_wrap_OBFingerprint_get_fingerprint), -1);
  rb_define_const(SwigClassOBFingerprint.klass, "FPT_UNIQUEBITS", SWIG_From_int(static_cast< int >(OpenBabel::OBFingerprint::FPT_UNIQUEBITS)));
  rb_define_method(SwigClassOBFingerprint.klass, "flags", VALUEFUNC(_wrap_OBFingerprint_flags), -1);
  rb_define_singleton_method(SwigClassOBFingerprint.klass, "tanimoto", VALUEFUNC(_wrap_OBFingerprint_tanimoto), -1);
  rb_define_singleton_method(SwigClassOBFingerprint.klass, "getbitsperint", VALUEFUNC(_wrap_OBFingerprint_getbitsperint), -1);
  rb_define_singleton_method(SwigClassOBFingerprint.klass, "find_fingerprint", VALUEFUNC(_wrap_OBFingerprint_find_fingerprint), -1);
  SwigClassOBFingerprint.mark = 0;
  SwigClassOBFingerprint.destroy = (void (*)(void *)) free_OpenBabel_OBFingerprint;
  SwigClassOBFingerprint.trackObjects = 0;
  
  SwigClassFptIndexHeader.klass = rb_define_class_under(mOpenBabel, "FptIndexHeader", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FptIndexHeader, (void *) &SwigClassFptIndexHeader);
  rb_define_alloc_func(SwigClassFptIndexHeader.klass, _wrap_FptIndexHeader_allocate);
  rb_define_method(SwigClassFptIndexHeader.klass, "initialize", VALUEFUNC(_wrap_new_FptIndexHeader), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "headerlength=", VALUEFUNC(_wrap_FptIndexHeader_headerlength_set), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "headerlength", VALUEFUNC(_wrap_FptIndexHeader_headerlength_get), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "nEntries=", VALUEFUNC(_wrap_FptIndexHeader_nEntries_set), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "nEntries", VALUEFUNC(_wrap_FptIndexHeader_nEntries_get), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "words=", VALUEFUNC(_wrap_FptIndexHeader_words_set), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "words", VALUEFUNC(_wrap_FptIndexHeader_words_get), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "fpid=", VALUEFUNC(_wrap_FptIndexHeader_fpid_set), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "fpid", VALUEFUNC(_wrap_FptIndexHeader_fpid_get), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "datafilename=", VALUEFUNC(_wrap_FptIndexHeader_datafilename_set), -1);
  rb_define_method(SwigClassFptIndexHeader.klass, "datafilename", VALUEFUNC(_wrap_FptIndexHeader_datafilename_get), -1);
  SwigClassFptIndexHeader.mark = 0;
  SwigClassFptIndexHeader.destroy = (void (*)(void *)) free_OpenBabel_FptIndexHeader;
  SwigClassFptIndexHeader.trackObjects = 0;
  
  SwigClassFptIndex.klass = rb_define_class_under(mOpenBabel, "FptIndex", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FptIndex, (void *) &SwigClassFptIndex);
  rb_define_alloc_func(SwigClassFptIndex.klass, _wrap_FptIndex_allocate);
  rb_define_method(SwigClassFptIndex.klass, "initialize", VALUEFUNC(_wrap_new_FptIndex), -1);
  rb_define_method(SwigClassFptIndex.klass, "header=", VALUEFUNC(_wrap_FptIndex_header_set), -1);
  rb_define_method(SwigClassFptIndex.klass, "header", VALUEFUNC(_wrap_FptIndex_header_get), -1);
  rb_define_method(SwigClassFptIndex.klass, "fptdata=", VALUEFUNC(_wrap_FptIndex_fptdata_set), -1);
  rb_define_method(SwigClassFptIndex.klass, "fptdata", VALUEFUNC(_wrap_FptIndex_fptdata_get), -1);
  rb_define_method(SwigClassFptIndex.klass, "seekdata=", VALUEFUNC(_wrap_FptIndex_seekdata_set), -1);
  rb_define_method(SwigClassFptIndex.klass, "seekdata", VALUEFUNC(_wrap_FptIndex_seekdata_get), -1);
  rb_define_method(SwigClassFptIndex.klass, "read", VALUEFUNC(_wrap_FptIndex_read), -1);
  rb_define_method(SwigClassFptIndex.klass, "check_fp", VALUEFUNC(_wrap_FptIndex_check_fp), -1);
  SwigClassFptIndex.mark = 0;
  SwigClassFptIndex.destroy = (void (*)(void *)) free_OpenBabel_FptIndex;
  SwigClassFptIndex.trackObjects = 0;
  
  SwigClassFastSearch.klass = rb_define_class_under(mOpenBabel, "FastSearch", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FastSearch, (void *) &SwigClassFastSearch);
  rb_define_alloc_func(SwigClassFastSearch.klass, _wrap_FastSearch_allocate);
  rb_define_method(SwigClassFastSearch.klass, "initialize", VALUEFUNC(_wrap_new_FastSearch), -1);
  rb_define_method(SwigClassFastSearch.klass, "read_index_file", VALUEFUNC(_wrap_FastSearch_read_index_file), -1);
  rb_define_method(SwigClassFastSearch.klass, "read_index", VALUEFUNC(_wrap_FastSearch_read_index), -1);
  rb_define_method(SwigClassFastSearch.klass, "find", VALUEFUNC(_wrap_FastSearch_find), -1);
  rb_define_method(SwigClassFastSearch.klass, "find_match", VALUEFUNC(_wrap_FastSearch_find_match), -1);
  rb_define_method(SwigClassFastSearch.klass, "find_similar", VALUEFUNC(_wrap_FastSearch_find_similar), -1);
  rb_define_method(SwigClassFastSearch.klass, "get_fingerprint", VALUEFUNC(_wrap_FastSearch_get_fingerprint), -1);
  rb_define_method(SwigClassFastSearch.klass, "get_index_header", VALUEFUNC(_wrap_FastSearch_get_index_header), -1);
  SwigClassFastSearch.mark = 0;
  SwigClassFastSearch.destroy = (void (*)(void *)) free_OpenBabel_FastSearch;
  SwigClassFastSearch.trackObjects = 0;
  
  SwigClassFastSearchIndexer.klass = rb_define_class_under(mOpenBabel, "FastSearchIndexer", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__FastSearchIndexer, (void *) &SwigClassFastSearchIndexer);
  rb_define_alloc_func(SwigClassFastSearchIndexer.klass, _wrap_FastSearchIndexer_allocate);
  rb_define_method(SwigClassFastSearchIndexer.klass, "initialize", VALUEFUNC(_wrap_new_FastSearchIndexer), -1);
  rb_define_method(SwigClassFastSearchIndexer.klass, "add", VALUEFUNC(_wrap_FastSearchIndexer_add), -1);
  SwigClassFastSearchIndexer.mark = 0;
  SwigClassFastSearchIndexer.destroy = (void (*)(void *)) free_OpenBabel_FastSearchIndexer;
  SwigClassFastSearchIndexer.trackObjects = 0;
  
  SwigClassOBDescriptor.klass = rb_define_class_under(mOpenBabel, "OBDescriptor", ((swig_class *) SWIGTYPE_p_OpenBabel__OBPlugin->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBDescriptor, (void *) &SwigClassOBDescriptor);
  rb_define_alloc_func(SwigClassOBDescriptor.klass, _wrap_OBDescriptor_allocate);
  rb_define_method(SwigClassOBDescriptor.klass, "initialize", VALUEFUNC(_wrap_new_OBDescriptor), -1);
  rb_define_singleton_method(SwigClassOBDescriptor.klass, "default", VALUEFUNC(_wrap_OBDescriptor_default), -1);
  rb_define_singleton_method(SwigClassOBDescriptor.klass, "find_type", VALUEFUNC(_wrap_OBDescriptor_find_type), -1);
  rb_define_method(SwigClassOBDescriptor.klass, "type_id", VALUEFUNC(_wrap_OBDescriptor_type_id), -1);
  rb_define_method(SwigClassOBDescriptor.klass, "predict", VALUEFUNC(_wrap_OBDescriptor_predict), -1);
  rb_define_method(SwigClassOBDescriptor.klass, "predict_and_save", VALUEFUNC(_wrap_OBDescriptor_predict_and_save), -1);
  rb_define_method(SwigClassOBDescriptor.klass, "get_string_value", VALUEFUNC(_wrap_OBDescriptor_get_string_value), -1);
  rb_define_method(SwigClassOBDescriptor.klass, "compare", VALUEFUNC(_wrap_OBDescriptor_compare), -1);
  rb_define_method(SwigClassOBDescriptor.klass, "display", VALUEFUNC(_wrap_OBDescriptor_display), -1);
  rb_define_singleton_method(SwigClassOBDescriptor.klass, "filter_compare", VALUEFUNC(_wrap_OBDescriptor_filter_compare), -1);
  rb_define_singleton_method(SwigClassOBDescriptor.klass, "add_properties", VALUEFUNC(_wrap_OBDescriptor_add_properties), -1);
  rb_define_singleton_method(SwigClassOBDescriptor.klass, "delete_properties", VALUEFUNC(_wrap_OBDescriptor_delete_properties), -1);
  rb_define_singleton_method(SwigClassOBDescriptor.klass, "get_values", VALUEFUNC(_wrap_OBDescriptor_get_values), -1);
  SwigClassOBDescriptor.mark = 0;
  SwigClassOBDescriptor.destroy = (void (*)(void *)) free_OpenBabel_OBDescriptor;
  SwigClassOBDescriptor.trackObjects = 0;
  rb_define_const(mOpenBabel, "OBFF_LOGLVL_NONE", SWIG_From_int(static_cast< int >(0)));
  rb_define_const(mOpenBabel, "OBFF_LOGLVL_LOW", SWIG_From_int(static_cast< int >(1)));
  rb_define_const(mOpenBabel, "OBFF_LOGLVL_MEDIUM", SWIG_From_int(static_cast< int >(2)));
  rb_define_const(mOpenBabel, "OBFF_LOGLVL_HIGH", SWIG_From_int(static_cast< int >(3)));
  rb_define_const(mOpenBabel, "OBFF_ENERGY", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenBabel, "OBFF_EBOND", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "OBFF_EANGLE", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenBabel, "OBFF_ESTRBND", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenBabel, "OBFF_ETORSION", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenBabel, "OBFF_EOOP", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenBabel, "OBFF_EVDW", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenBabel, "OBFF_EELECTROSTATIC", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenBabel, "OBFF_CONST_IGNORE", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenBabel, "OBFF_CONST_ATOM", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "OBFF_CONST_ATOM_X", SWIG_From_int(static_cast< int >((1 << 2))));
  rb_define_const(mOpenBabel, "OBFF_CONST_ATOM_Y", SWIG_From_int(static_cast< int >((1 << 3))));
  rb_define_const(mOpenBabel, "OBFF_CONST_ATOM_Z", SWIG_From_int(static_cast< int >((1 << 4))));
  rb_define_const(mOpenBabel, "OBFF_CONST_DISTANCE", SWIG_From_int(static_cast< int >((1 << 5))));
  rb_define_const(mOpenBabel, "OBFF_CONST_ANGLE", SWIG_From_int(static_cast< int >((1 << 6))));
  rb_define_const(mOpenBabel, "OBFF_CONST_TORSION", SWIG_From_int(static_cast< int >((1 << 7))));
  rb_define_const(mOpenBabel, "OBFF_CONST_CHIRAL", SWIG_From_int(static_cast< int >((1 << 8))));
  rb_define_const(mOpenBabel, "OBFF_NUMERICAL_GRADIENT", SWIG_From_int(static_cast< int >((1 << 0))));
  rb_define_const(mOpenBabel, "OBFF_ANALYTICAL_GRADIENT", SWIG_From_int(static_cast< int >((1 << 1))));
  rb_define_const(mOpenBabel, "KCAL_TO_KJ", SWIG_From_double(static_cast< double >(4.1868)));
  
  SwigClassLineSearchType.klass = rb_define_class_under(mOpenBabel, "LineSearchType", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__LineSearchType, (void *) &SwigClassLineSearchType);
  rb_define_alloc_func(SwigClassLineSearchType.klass, _wrap_LineSearchType_allocate);
  rb_define_method(SwigClassLineSearchType.klass, "initialize", VALUEFUNC(_wrap_new_LineSearchType), -1);
  rb_define_const(SwigClassLineSearchType.klass, "Simple", SWIG_From_int(static_cast< int >(OpenBabel::LineSearchType::Simple)));
  rb_define_const(SwigClassLineSearchType.klass, "Newton2Num", SWIG_From_int(static_cast< int >(OpenBabel::LineSearchType::Newton2Num)));
  SwigClassLineSearchType.mark = 0;
  SwigClassLineSearchType.destroy = (void (*)(void *)) free_OpenBabel_LineSearchType;
  SwigClassLineSearchType.trackObjects = 0;
  
  SwigClassOBFFParameter.klass = rb_define_class_under(mOpenBabel, "OBFFParameter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFParameter, (void *) &SwigClassOBFFParameter);
  rb_define_alloc_func(SwigClassOBFFParameter.klass, _wrap_OBFFParameter_allocate);
  rb_define_method(SwigClassOBFFParameter.klass, "initialize", VALUEFUNC(_wrap_new_OBFFParameter), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "a=", VALUEFUNC(_wrap_OBFFParameter_a_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "a", VALUEFUNC(_wrap_OBFFParameter_a_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "b=", VALUEFUNC(_wrap_OBFFParameter_b_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "b", VALUEFUNC(_wrap_OBFFParameter_b_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "c=", VALUEFUNC(_wrap_OBFFParameter_c_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "c", VALUEFUNC(_wrap_OBFFParameter_c_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "d=", VALUEFUNC(_wrap_OBFFParameter_d_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "d", VALUEFUNC(_wrap_OBFFParameter_d_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_a=", VALUEFUNC(_wrap_OBFFParameter__a_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_a", VALUEFUNC(_wrap_OBFFParameter__a_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_b=", VALUEFUNC(_wrap_OBFFParameter__b_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_b", VALUEFUNC(_wrap_OBFFParameter__b_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_c=", VALUEFUNC(_wrap_OBFFParameter__c_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_c", VALUEFUNC(_wrap_OBFFParameter__c_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_d=", VALUEFUNC(_wrap_OBFFParameter__d_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_d", VALUEFUNC(_wrap_OBFFParameter__d_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_ipar=", VALUEFUNC(_wrap_OBFFParameter__ipar_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_ipar", VALUEFUNC(_wrap_OBFFParameter__ipar_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_dpar=", VALUEFUNC(_wrap_OBFFParameter__dpar_set), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "_dpar", VALUEFUNC(_wrap_OBFFParameter__dpar_get), -1);
  rb_define_method(SwigClassOBFFParameter.klass, "clear", VALUEFUNC(_wrap_OBFFParameter_clear), -1);
  SwigClassOBFFParameter.mark = 0;
  SwigClassOBFFParameter.destroy = (void (*)(void *)) free_OpenBabel_OBFFParameter;
  SwigClassOBFFParameter.trackObjects = 0;
  
  SwigClassOBFFCalculation2.klass = rb_define_class_under(mOpenBabel, "OBFFCalculation2", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFCalculation2, (void *) &SwigClassOBFFCalculation2);
  rb_define_alloc_func(SwigClassOBFFCalculation2.klass, _wrap_OBFFCalculation2_allocate);
  rb_define_method(SwigClassOBFFCalculation2.klass, "initialize", VALUEFUNC(_wrap_new_OBFFCalculation2), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "energy=", VALUEFUNC(_wrap_OBFFCalculation2_energy_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "energy", VALUEFUNC(_wrap_OBFFCalculation2_energy_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "a=", VALUEFUNC(_wrap_OBFFCalculation2_a_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "a", VALUEFUNC(_wrap_OBFFCalculation2_a_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "b=", VALUEFUNC(_wrap_OBFFCalculation2_b_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "b", VALUEFUNC(_wrap_OBFFCalculation2_b_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "idx_a=", VALUEFUNC(_wrap_OBFFCalculation2_idx_a_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "idx_a", VALUEFUNC(_wrap_OBFFCalculation2_idx_a_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "idx_b=", VALUEFUNC(_wrap_OBFFCalculation2_idx_b_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "idx_b", VALUEFUNC(_wrap_OBFFCalculation2_idx_b_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "pos_a=", VALUEFUNC(_wrap_OBFFCalculation2_pos_a_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "pos_a", VALUEFUNC(_wrap_OBFFCalculation2_pos_a_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "pos_b=", VALUEFUNC(_wrap_OBFFCalculation2_pos_b_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "pos_b", VALUEFUNC(_wrap_OBFFCalculation2_pos_b_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "force_a=", VALUEFUNC(_wrap_OBFFCalculation2_force_a_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "force_a", VALUEFUNC(_wrap_OBFFCalculation2_force_a_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "force_b=", VALUEFUNC(_wrap_OBFFCalculation2_force_b_set), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "force_b", VALUEFUNC(_wrap_OBFFCalculation2_force_b_get), -1);
  rb_define_method(SwigClassOBFFCalculation2.klass, "setup_pointers", VALUEFUNC(_wrap_OBFFCalculation2_setup_pointers), -1);
  SwigClassOBFFCalculation2.mark = 0;
  SwigClassOBFFCalculation2.destroy = (void (*)(void *)) free_OpenBabel_OBFFCalculation2;
  SwigClassOBFFCalculation2.trackObjects = 0;
  
  SwigClassOBFFCalculation3.klass = rb_define_class_under(mOpenBabel, "OBFFCalculation3", ((swig_class *) SWIGTYPE_p_OpenBabel__OBFFCalculation2->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFCalculation3, (void *) &SwigClassOBFFCalculation3);
  rb_define_alloc_func(SwigClassOBFFCalculation3.klass, _wrap_OBFFCalculation3_allocate);
  rb_define_method(SwigClassOBFFCalculation3.klass, "initialize", VALUEFUNC(_wrap_new_OBFFCalculation3), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "c=", VALUEFUNC(_wrap_OBFFCalculation3_c_set), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "c", VALUEFUNC(_wrap_OBFFCalculation3_c_get), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "idx_c=", VALUEFUNC(_wrap_OBFFCalculation3_idx_c_set), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "idx_c", VALUEFUNC(_wrap_OBFFCalculation3_idx_c_get), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "pos_c=", VALUEFUNC(_wrap_OBFFCalculation3_pos_c_set), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "pos_c", VALUEFUNC(_wrap_OBFFCalculation3_pos_c_get), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "force_c=", VALUEFUNC(_wrap_OBFFCalculation3_force_c_set), -1);
  rb_define_method(SwigClassOBFFCalculation3.klass, "force_c", VALUEFUNC(_wrap_OBFFCalculation3_force_c_get), -1);
  SwigClassOBFFCalculation3.mark = 0;
  SwigClassOBFFCalculation3.destroy = (void (*)(void *)) free_OpenBabel_OBFFCalculation3;
  SwigClassOBFFCalculation3.trackObjects = 0;
  
  SwigClassOBFFCalculation4.klass = rb_define_class_under(mOpenBabel, "OBFFCalculation4", ((swig_class *) SWIGTYPE_p_OpenBabel__OBFFCalculation3->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFCalculation4, (void *) &SwigClassOBFFCalculation4);
  rb_define_alloc_func(SwigClassOBFFCalculation4.klass, _wrap_OBFFCalculation4_allocate);
  rb_define_method(SwigClassOBFFCalculation4.klass, "initialize", VALUEFUNC(_wrap_new_OBFFCalculation4), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "d=", VALUEFUNC(_wrap_OBFFCalculation4_d_set), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "d", VALUEFUNC(_wrap_OBFFCalculation4_d_get), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "idx_d=", VALUEFUNC(_wrap_OBFFCalculation4_idx_d_set), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "idx_d", VALUEFUNC(_wrap_OBFFCalculation4_idx_d_get), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "pos_d=", VALUEFUNC(_wrap_OBFFCalculation4_pos_d_set), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "pos_d", VALUEFUNC(_wrap_OBFFCalculation4_pos_d_get), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "force_d=", VALUEFUNC(_wrap_OBFFCalculation4_force_d_set), -1);
  rb_define_method(SwigClassOBFFCalculation4.klass, "force_d", VALUEFUNC(_wrap_OBFFCalculation4_force_d_get), -1);
  SwigClassOBFFCalculation4.mark = 0;
  SwigClassOBFFCalculation4.destroy = (void (*)(void *)) free_OpenBabel_OBFFCalculation4;
  SwigClassOBFFCalculation4.trackObjects = 0;
  
  SwigClassOBFFConstraint.klass = rb_define_class_under(mOpenBabel, "OBFFConstraint", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFConstraint, (void *) &SwigClassOBFFConstraint);
  rb_define_alloc_func(SwigClassOBFFConstraint.klass, _wrap_OBFFConstraint_allocate);
  rb_define_method(SwigClassOBFFConstraint.klass, "initialize", VALUEFUNC(_wrap_new_OBFFConstraint), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "factor=", VALUEFUNC(_wrap_OBFFConstraint_factor_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "factor", VALUEFUNC(_wrap_OBFFConstraint_factor_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "constraint_value=", VALUEFUNC(_wrap_OBFFConstraint_constraint_value_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "constraint_value", VALUEFUNC(_wrap_OBFFConstraint_constraint_value_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "rab0=", VALUEFUNC(_wrap_OBFFConstraint_rab0_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "rab0", VALUEFUNC(_wrap_OBFFConstraint_rab0_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "rbc0=", VALUEFUNC(_wrap_OBFFConstraint_rbc0_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "rbc0", VALUEFUNC(_wrap_OBFFConstraint_rbc0_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "type=", VALUEFUNC(_wrap_OBFFConstraint_type_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "type", VALUEFUNC(_wrap_OBFFConstraint_type_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "ia=", VALUEFUNC(_wrap_OBFFConstraint_ia_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "ia", VALUEFUNC(_wrap_OBFFConstraint_ia_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "ib=", VALUEFUNC(_wrap_OBFFConstraint_ib_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "ib", VALUEFUNC(_wrap_OBFFConstraint_ib_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "ic=", VALUEFUNC(_wrap_OBFFConstraint_ic_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "ic", VALUEFUNC(_wrap_OBFFConstraint_ic_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "id=", VALUEFUNC(_wrap_OBFFConstraint_id_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "id", VALUEFUNC(_wrap_OBFFConstraint_id_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "a=", VALUEFUNC(_wrap_OBFFConstraint_a_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "a", VALUEFUNC(_wrap_OBFFConstraint_a_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "b=", VALUEFUNC(_wrap_OBFFConstraint_b_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "b", VALUEFUNC(_wrap_OBFFConstraint_b_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "c=", VALUEFUNC(_wrap_OBFFConstraint_c_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "c", VALUEFUNC(_wrap_OBFFConstraint_c_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "d=", VALUEFUNC(_wrap_OBFFConstraint_d_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "d", VALUEFUNC(_wrap_OBFFConstraint_d_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "grada=", VALUEFUNC(_wrap_OBFFConstraint_grada_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "grada", VALUEFUNC(_wrap_OBFFConstraint_grada_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "gradb=", VALUEFUNC(_wrap_OBFFConstraint_gradb_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "gradb", VALUEFUNC(_wrap_OBFFConstraint_gradb_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "gradc=", VALUEFUNC(_wrap_OBFFConstraint_gradc_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "gradc", VALUEFUNC(_wrap_OBFFConstraint_gradc_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "gradd=", VALUEFUNC(_wrap_OBFFConstraint_gradd_set), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "gradd", VALUEFUNC(_wrap_OBFFConstraint_gradd_get), -1);
  rb_define_method(SwigClassOBFFConstraint.klass, "get_gradient", VALUEFUNC(_wrap_OBFFConstraint_get_gradient), -1);
  SwigClassOBFFConstraint.mark = 0;
  SwigClassOBFFConstraint.destroy = (void (*)(void *)) free_OpenBabel_OBFFConstraint;
  SwigClassOBFFConstraint.trackObjects = 0;
  
  SwigClassOBFFConstraints.klass = rb_define_class_under(mOpenBabel, "OBFFConstraints", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBFFConstraints, (void *) &SwigClassOBFFConstraints);
  rb_define_alloc_func(SwigClassOBFFConstraints.klass, _wrap_OBFFConstraints_allocate);
  rb_define_method(SwigClassOBFFConstraints.klass, "initialize", VALUEFUNC(_wrap_new_OBFFConstraints), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "clear", VALUEFUNC(_wrap_OBFFConstraints_clear), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_energy", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_energy), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_gradient", VALUEFUNC(_wrap_OBFFConstraints_get_gradient), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "setup", VALUEFUNC(_wrap_OBFFConstraints_setup), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "set_factor", VALUEFUNC(_wrap_OBFFConstraints_set_factor), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_ignore", VALUEFUNC(_wrap_OBFFConstraints_add_ignore), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_atom_constraint", VALUEFUNC(_wrap_OBFFConstraints_add_atom_constraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_atom_xconstraint", VALUEFUNC(_wrap_OBFFConstraints_add_atom_xconstraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_atom_yconstraint", VALUEFUNC(_wrap_OBFFConstraints_add_atom_yconstraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_atom_zconstraint", VALUEFUNC(_wrap_OBFFConstraints_add_atom_zconstraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_distance_constraint", VALUEFUNC(_wrap_OBFFConstraints_add_distance_constraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_angle_constraint", VALUEFUNC(_wrap_OBFFConstraints_add_angle_constraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "add_torsion_constraint", VALUEFUNC(_wrap_OBFFConstraints_add_torsion_constraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "delete_constraint", VALUEFUNC(_wrap_OBFFConstraints_delete_constraint), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_factor", VALUEFUNC(_wrap_OBFFConstraints_get_factor), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "size", VALUEFUNC(_wrap_OBFFConstraints_size), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_type", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_type), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_value", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_value), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_atom_a", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_atom_a), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_atom_b", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_atom_b), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_atom_c", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_atom_c), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_constraint_atom_d", VALUEFUNC(_wrap_OBFFConstraints_get_constraint_atom_d), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "is_ignored", VALUEFUNC(_wrap_OBFFConstraints_is_ignored), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "is_fixed", VALUEFUNC(_wrap_OBFFConstraints_is_fixed), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "is_xfixed", VALUEFUNC(_wrap_OBFFConstraints_is_xfixed), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "is_yfixed", VALUEFUNC(_wrap_OBFFConstraints_is_yfixed), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "is_zfixed", VALUEFUNC(_wrap_OBFFConstraints_is_zfixed), -1);
  rb_define_method(SwigClassOBFFConstraints.klass, "get_ignored_bit_vec", VALUEFUNC(_wrap_OBFFConstraints_get_ignored_bit_vec), -1);
  SwigClassOBFFConstraints.mark = 0;
  SwigClassOBFFConstraints.destroy = (void (*)(void *)) free_OpenBabel_OBFFConstraints;
  SwigClassOBFFConstraints.trackObjects = 0;
  
  SwigClassOBForceField.klass = rb_define_class_under(mOpenBabel, "OBForceField", ((swig_class *) SWIGTYPE_p_OpenBabel__OBPlugin->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBForceField, (void *) &SwigClassOBForceField);
  rb_undef_alloc_func(SwigClassOBForceField.klass);
  rb_define_singleton_method(SwigClassOBForceField.klass, "default", VALUEFUNC(_wrap_OBForceField_default), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "find_type", VALUEFUNC(_wrap_OBForceField_find_type), -1);
  rb_define_method(SwigClassOBForceField.klass, "make_new_instance", VALUEFUNC(_wrap_OBForceField_make_new_instance), -1);
  rb_define_method(SwigClassOBForceField.klass, "type_id", VALUEFUNC(_wrap_OBForceField_type_id), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "find_force_field", VALUEFUNC(_wrap_OBForceField_find_force_field), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_parameter_file", VALUEFUNC(_wrap_OBForceField_set_parameter_file), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_unit", VALUEFUNC(_wrap_OBForceField_get_unit), -1);
  rb_define_method(SwigClassOBForceField.klass, "has_analytical_gradients", VALUEFUNC(_wrap_OBForceField_has_analytical_gradients), -1);
  rb_define_method(SwigClassOBForceField.klass, "setup", VALUEFUNC(_wrap_OBForceField_setup), -1);
  rb_define_method(SwigClassOBForceField.klass, "parse_param_file", VALUEFUNC(_wrap_OBForceField_parse_param_file), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_types", VALUEFUNC(_wrap_OBForceField_set_types), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_formal_charges", VALUEFUNC(_wrap_OBForceField_set_formal_charges), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_partial_charges", VALUEFUNC(_wrap_OBForceField_set_partial_charges), -1);
  rb_define_method(SwigClassOBForceField.klass, "setup_calculations", VALUEFUNC(_wrap_OBForceField_setup_calculations), -1);
  rb_define_method(SwigClassOBForceField.klass, "setup_pointers", VALUEFUNC(_wrap_OBForceField_setup_pointers), -1);
  rb_define_method(SwigClassOBForceField.klass, "is_setup_needed", VALUEFUNC(_wrap_OBForceField_is_setup_needed), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_atom_types", VALUEFUNC(_wrap_OBForceField_get_atom_types), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_partial_charges", VALUEFUNC(_wrap_OBForceField_get_partial_charges), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_coordinates", VALUEFUNC(_wrap_OBForceField_get_coordinates), -1);
  rb_define_method(SwigClassOBForceField.klass, "update_coordinates", VALUEFUNC(_wrap_OBForceField_update_coordinates), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_conformers", VALUEFUNC(_wrap_OBForceField_get_conformers), -1);
  rb_define_method(SwigClassOBForceField.klass, "update_conformers", VALUEFUNC(_wrap_OBForceField_update_conformers), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_coordinates", VALUEFUNC(_wrap_OBForceField_set_coordinates), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_conformers", VALUEFUNC(_wrap_OBForceField_set_conformers), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_grid", VALUEFUNC(_wrap_OBForceField_get_grid), -1);
  rb_define_method(SwigClassOBForceField.klass, "add_intra_group", VALUEFUNC(_wrap_OBForceField_add_intra_group), -1);
  rb_define_method(SwigClassOBForceField.klass, "add_inter_group", VALUEFUNC(_wrap_OBForceField_add_inter_group), -1);
  rb_define_method(SwigClassOBForceField.klass, "add_inter_groups", VALUEFUNC(_wrap_OBForceField_add_inter_groups), -1);
  rb_define_method(SwigClassOBForceField.klass, "clear_groups", VALUEFUNC(_wrap_OBForceField_clear_groups), -1);
  rb_define_method(SwigClassOBForceField.klass, "has_groups", VALUEFUNC(_wrap_OBForceField_has_groups), -1);
  rb_define_method(SwigClassOBForceField.klass, "enable_cut_off", VALUEFUNC(_wrap_OBForceField_enable_cut_off), -1);
  rb_define_method(SwigClassOBForceField.klass, "is_cut_off_enabled", VALUEFUNC(_wrap_OBForceField_is_cut_off_enabled), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_vdwcut_off", VALUEFUNC(_wrap_OBForceField_set_vdwcut_off), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_vdwcut_off", VALUEFUNC(_wrap_OBForceField_get_vdwcut_off), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_electrostatic_cut_off", VALUEFUNC(_wrap_OBForceField_set_electrostatic_cut_off), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_electrostatic_cut_off", VALUEFUNC(_wrap_OBForceField_get_electrostatic_cut_off), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_update_frequency", VALUEFUNC(_wrap_OBForceField_set_update_frequency), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_update_frequency", VALUEFUNC(_wrap_OBForceField_get_update_frequency), -1);
  rb_define_method(SwigClassOBForceField.klass, "update_pairs_simple", VALUEFUNC(_wrap_OBForceField_update_pairs_simple), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_num_pairs", VALUEFUNC(_wrap_OBForceField_get_num_pairs), -1);
  rb_define_method(SwigClassOBForceField.klass, "enable_all_pairs", VALUEFUNC(_wrap_OBForceField_enable_all_pairs), -1);
  rb_define_method(SwigClassOBForceField.klass, "energy", VALUEFUNC(_wrap_OBForceField_energy), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_bond", VALUEFUNC(_wrap_OBForceField_e_bond), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_angle", VALUEFUNC(_wrap_OBForceField_e_angle), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_str_bnd", VALUEFUNC(_wrap_OBForceField_e_str_bnd), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_torsion", VALUEFUNC(_wrap_OBForceField_e_torsion), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_oop", VALUEFUNC(_wrap_OBForceField_e_oop), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_vdw", VALUEFUNC(_wrap_OBForceField_e_vdw), -1);
  rb_define_method(SwigClassOBForceField.klass, "e_electrostatic", VALUEFUNC(_wrap_OBForceField_e_electrostatic), -1);
  rb_define_method(SwigClassOBForceField.klass, "print_types", VALUEFUNC(_wrap_OBForceField_print_types), -1);
  rb_define_method(SwigClassOBForceField.klass, "print_formal_charges", VALUEFUNC(_wrap_OBForceField_print_formal_charges), -1);
  rb_define_method(SwigClassOBForceField.klass, "print_partial_charges", VALUEFUNC(_wrap_OBForceField_print_partial_charges), -1);
  rb_define_method(SwigClassOBForceField.klass, "print_velocities", VALUEFUNC(_wrap_OBForceField_print_velocities), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_log_file", VALUEFUNC(_wrap_OBForceField_set_log_file), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_log_level", VALUEFUNC(_wrap_OBForceField_set_log_level), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_log_level", VALUEFUNC(_wrap_OBForceField_get_log_level), -1);
  rb_define_method(SwigClassOBForceField.klass, "obfflog", VALUEFUNC(_wrap_OBForceField_obfflog), -1);
  rb_define_method(SwigClassOBForceField.klass, "distance_geometry", VALUEFUNC(_wrap_OBForceField_distance_geometry), -1);
  rb_define_method(SwigClassOBForceField.klass, "systematic_rotor_search", VALUEFUNC(_wrap_OBForceField_systematic_rotor_search), -1);
  rb_define_method(SwigClassOBForceField.klass, "systematic_rotor_search_initialize", VALUEFUNC(_wrap_OBForceField_systematic_rotor_search_initialize), -1);
  rb_define_method(SwigClassOBForceField.klass, "systematic_rotor_search_next_conformer", VALUEFUNC(_wrap_OBForceField_systematic_rotor_search_next_conformer), -1);
  rb_define_method(SwigClassOBForceField.klass, "random_rotor_search", VALUEFUNC(_wrap_OBForceField_random_rotor_search), -1);
  rb_define_method(SwigClassOBForceField.klass, "random_rotor_search_initialize", VALUEFUNC(_wrap_OBForceField_random_rotor_search_initialize), -1);
  rb_define_method(SwigClassOBForceField.klass, "random_rotor_search_next_conformer", VALUEFUNC(_wrap_OBForceField_random_rotor_search_next_conformer), -1);
  rb_define_method(SwigClassOBForceField.klass, "weighted_rotor_search", VALUEFUNC(_wrap_OBForceField_weighted_rotor_search), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_line_search_type", VALUEFUNC(_wrap_OBForceField_set_line_search_type), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_line_search_type", VALUEFUNC(_wrap_OBForceField_get_line_search_type), -1);
  rb_define_method(SwigClassOBForceField.klass, "line_search", VALUEFUNC(_wrap_OBForceField_line_search), -1);
  rb_define_method(SwigClassOBForceField.klass, "newton_2num_line_search", VALUEFUNC(_wrap_OBForceField_newton_2num_line_search), -1);
  rb_define_method(SwigClassOBForceField.klass, "line_search_take_step", VALUEFUNC(_wrap_OBForceField_line_search_take_step), -1);
  rb_define_method(SwigClassOBForceField.klass, "steepest_descent", VALUEFUNC(_wrap_OBForceField_steepest_descent), -1);
  rb_define_method(SwigClassOBForceField.klass, "steepest_descent_initialize", VALUEFUNC(_wrap_OBForceField_steepest_descent_initialize), -1);
  rb_define_method(SwigClassOBForceField.klass, "steepest_descent_take_nsteps", VALUEFUNC(_wrap_OBForceField_steepest_descent_take_nsteps), -1);
  rb_define_method(SwigClassOBForceField.klass, "conjugate_gradients", VALUEFUNC(_wrap_OBForceField_conjugate_gradients), -1);
  rb_define_method(SwigClassOBForceField.klass, "conjugate_gradients_initialize", VALUEFUNC(_wrap_OBForceField_conjugate_gradients_initialize), -1);
  rb_define_method(SwigClassOBForceField.klass, "conjugate_gradients_take_nsteps", VALUEFUNC(_wrap_OBForceField_conjugate_gradients_take_nsteps), -1);
  rb_define_method(SwigClassOBForceField.klass, "generate_velocities", VALUEFUNC(_wrap_OBForceField_generate_velocities), -1);
  rb_define_method(SwigClassOBForceField.klass, "correct_velocities", VALUEFUNC(_wrap_OBForceField_correct_velocities), -1);
  rb_define_method(SwigClassOBForceField.klass, "molecular_dynamics_take_nsteps", VALUEFUNC(_wrap_OBForceField_molecular_dynamics_take_nsteps), -1);
  rb_define_method(SwigClassOBForceField.klass, "get_constraints", VALUEFUNC(_wrap_OBForceField_get_constraints), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_constraints", VALUEFUNC(_wrap_OBForceField_set_constraints), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_fix_atom", VALUEFUNC(_wrap_OBForceField_set_fix_atom), -1);
  rb_define_method(SwigClassOBForceField.klass, "unset_fix_atom", VALUEFUNC(_wrap_OBForceField_unset_fix_atom), -1);
  rb_define_method(SwigClassOBForceField.klass, "set_ignore_atom", VALUEFUNC(_wrap_OBForceField_set_ignore_atom), -1);
  rb_define_method(SwigClassOBForceField.klass, "unset_ignore_atom", VALUEFUNC(_wrap_OBForceField_unset_ignore_atom), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "ignore_calculation", VALUEFUNC(_wrap_OBForceField_ignore_calculation), -1);
  rb_define_method(SwigClassOBForceField.klass, "detect_explosion", VALUEFUNC(_wrap_OBForceField_detect_explosion), -1);
  rb_define_method(SwigClassOBForceField.klass, "validate_line_search", VALUEFUNC(_wrap_OBForceField_validate_line_search), -1);
  rb_define_method(SwigClassOBForceField.klass, "validate_steepest_descent", VALUEFUNC(_wrap_OBForceField_validate_steepest_descent), -1);
  rb_define_method(SwigClassOBForceField.klass, "validate_conjugate_gradients", VALUEFUNC(_wrap_OBForceField_validate_conjugate_gradients), -1);
  rb_define_method(SwigClassOBForceField.klass, "validate", VALUEFUNC(_wrap_OBForceField_validate), -1);
  rb_define_method(SwigClassOBForceField.klass, "validate_gradients", VALUEFUNC(_wrap_OBForceField_validate_gradients), -1);
  rb_define_method(SwigClassOBForceField.klass, "validate_gradient_error", VALUEFUNC(_wrap_OBForceField_validate_gradient_error), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_bond_derivative", VALUEFUNC(_wrap_OBForceField_vector_bond_derivative), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_distance_derivative", VALUEFUNC(_wrap_OBForceField_vector_distance_derivative), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_length_derivative", VALUEFUNC(_wrap_OBForceField_vector_length_derivative), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_angle_derivative", VALUEFUNC(_wrap_OBForceField_vector_angle_derivative), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_oopderivative", VALUEFUNC(_wrap_OBForceField_vector_oopderivative), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_torsion_derivative", VALUEFUNC(_wrap_OBForceField_vector_torsion_derivative), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_subtract", VALUEFUNC(_wrap_OBForceField_vector_subtract), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_add", VALUEFUNC(_wrap_OBForceField_vector_add), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_divide", VALUEFUNC(_wrap_OBForceField_vector_divide), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_multiply", VALUEFUNC(_wrap_OBForceField_vector_multiply), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_self_multiply", VALUEFUNC(_wrap_OBForceField_vector_self_multiply), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_normalize", VALUEFUNC(_wrap_OBForceField_vector_normalize), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_copy", VALUEFUNC(_wrap_OBForceField_vector_copy), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_length", VALUEFUNC(_wrap_OBForceField_vector_length), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_distance", VALUEFUNC(_wrap_OBForceField_vector_distance), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_angle", VALUEFUNC(_wrap_OBForceField_vector_angle), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_torsion", VALUEFUNC(_wrap_OBForceField_vector_torsion), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_oop", VALUEFUNC(_wrap_OBForceField_vector_oop), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_clear", VALUEFUNC(_wrap_OBForceField_vector_clear), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_dot", VALUEFUNC(_wrap_OBForceField_vector_dot), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "vector_cross", VALUEFUNC(_wrap_OBForceField_vector_cross), -1);
  rb_define_singleton_method(SwigClassOBForceField.klass, "print_vector", VALUEFUNC(_wrap_OBForceField_print_vector), -1);
  SwigClassOBForceField.mark = 0;
  SwigClassOBForceField.destroy = (void (*)(void *)) free_OpenBabel_OBForceField;
  SwigClassOBForceField.trackObjects = 0;
  
  SwigClassOBOp.klass = rb_define_class_under(mOpenBabel, "OBOp", ((swig_class *) SWIGTYPE_p_OpenBabel__OBPlugin->clientdata)->klass);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBOp, (void *) &SwigClassOBOp);
  rb_undef_alloc_func(SwigClassOBOp.klass);
  rb_define_singleton_method(SwigClassOBOp.klass, "default", VALUEFUNC(_wrap_OBOp_default), -1);
  rb_define_singleton_method(SwigClassOBOp.klass, "find_type", VALUEFUNC(_wrap_OBOp_find_type), -1);
  rb_define_method(SwigClassOBOp.klass, "type_id", VALUEFUNC(_wrap_OBOp_type_id), -1);
  rb_define_method(SwigClassOBOp.klass, "do", VALUEFUNC(_wrap_OBOp_do), -1);
  rb_define_method(SwigClassOBOp.klass, "works_with", VALUEFUNC(_wrap_OBOp_works_with), -1);
  rb_define_singleton_method(SwigClassOBOp.klass, "op_options", VALUEFUNC(_wrap_OBOp_op_options), -1);
  rb_define_singleton_method(SwigClassOBOp.klass, "do_ops", VALUEFUNC(_wrap_OBOp_do_ops), -1);
  SwigClassOBOp.mark = 0;
  SwigClassOBOp.destroy = (void (*)(void *)) free_OpenBabel_OBOp;
  SwigClassOBOp.trackObjects = 0;
  
  SwigClassOBMolAtomIter.klass = rb_define_class_under(mOpenBabel, "OBMolAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAtomIter, (void *) &SwigClassOBMolAtomIter);
  rb_define_alloc_func(SwigClassOBMolAtomIter.klass, _wrap_OBMolAtomIter_allocate);
  rb_define_method(SwigClassOBMolAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAtomIter), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "good", VALUEFUNC(_wrap_OBMolAtomIter_good), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "inc", VALUEFUNC(_wrap_OBMolAtomIter_inc), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "deref", VALUEFUNC(_wrap_OBMolAtomIter_deref), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAtomIter___ref__), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolAtomIter_Visit_set), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBMolAtomIter_Visit_get), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "duplicate", VALUEFUNC(_wrap_OBMolAtomIter_duplicate), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_idx", VALUEFUNC(_wrap_OBMolAtomIter_set_idx), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_hyb", VALUEFUNC(_wrap_OBMolAtomIter_set_hyb), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBMolAtomIter_set_atomic_num), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_isotope", VALUEFUNC(_wrap_OBMolAtomIter_set_isotope), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_set_implicit_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_increment_implicit_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_decrement_implicit_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBMolAtomIter_set_formal_charge), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomIter_set_spin_multiplicity), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_type", VALUEFUNC(_wrap_OBMolAtomIter_set_type), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBMolAtomIter_set_partial_charge), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_vector", VALUEFUNC(_wrap_OBMolAtomIter_set_vector), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBMolAtomIter_set_coord_ptr), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_residue", VALUEFUNC(_wrap_OBMolAtomIter_set_residue), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolAtomIter_set_parent), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBMolAtomIter_set_aromatic), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBMolAtomIter_unset_aromatic), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_clockwise_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_anti_clockwise_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_positive_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBMolAtomIter_set_negative_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBMolAtomIter_unset_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBMolAtomIter_set_in_ring), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_chiral", VALUEFUNC(_wrap_OBMolAtomIter_set_chiral), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBMolAtomIter_clear_coord_ptr), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBMolAtomIter_get_formal_charge), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBMolAtomIter_get_atomic_num), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_isotope", VALUEFUNC(_wrap_OBMolAtomIter_get_isotope), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBMolAtomIter_get_spin_multiplicity), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBMolAtomIter_get_atomic_mass), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBMolAtomIter_get_exact_mass), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_idx", VALUEFUNC(_wrap_OBMolAtomIter_get_idx), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBMolAtomIter_get_coordinate_idx), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_cidx", VALUEFUNC(_wrap_OBMolAtomIter_get_cidx), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_hyb", VALUEFUNC(_wrap_OBMolAtomIter_get_hyb), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_implicit_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_hvy_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBMolAtomIter_get_hetero_valence), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_type", VALUEFUNC(_wrap_OBMolAtomIter_get_type), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_x", VALUEFUNC(_wrap_OBMolAtomIter_get_x), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_y", VALUEFUNC(_wrap_OBMolAtomIter_get_y), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_z", VALUEFUNC(_wrap_OBMolAtomIter_get_z), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "x", VALUEFUNC(_wrap_OBMolAtomIter_x), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "y", VALUEFUNC(_wrap_OBMolAtomIter_y), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "z", VALUEFUNC(_wrap_OBMolAtomIter_z), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBMolAtomIter_get_coordinate), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_vector", VALUEFUNC(_wrap_OBMolAtomIter_get_vector), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBMolAtomIter_get_partial_charge), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_residue", VALUEFUNC(_wrap_OBMolAtomIter_get_residue), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolAtomIter_get_parent), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBMolAtomIter_get_new_bond_vector), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_bond", VALUEFUNC(_wrap_OBMolAtomIter_get_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBMolAtomIter_get_next_atom), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBMolAtomIter_begin_bonds), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "end_bonds", VALUEFUNC(_wrap_OBMolAtomIter_end_bonds), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "begin_bond", VALUEFUNC(_wrap_OBMolAtomIter_begin_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "next_bond", VALUEFUNC(_wrap_OBMolAtomIter_next_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBMolAtomIter_begin_nbr_atom), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBMolAtomIter_next_nbr_atom), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_distance", VALUEFUNC(_wrap_OBMolAtomIter_get_distance), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_angle", VALUEFUNC(_wrap_OBMolAtomIter_get_angle), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "new_residue", VALUEFUNC(_wrap_OBMolAtomIter_new_residue), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "add_residue", VALUEFUNC(_wrap_OBMolAtomIter_add_residue), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "delete_residue", VALUEFUNC(_wrap_OBMolAtomIter_delete_residue), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "add_bond", VALUEFUNC(_wrap_OBMolAtomIter_add_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "insert_bond", VALUEFUNC(_wrap_OBMolAtomIter_insert_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "delete_bond", VALUEFUNC(_wrap_OBMolAtomIter_delete_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "clear_bond", VALUEFUNC(_wrap_OBMolAtomIter_clear_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBMolAtomIter_hto_methyl), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBMolAtomIter_set_hyb_and_geom), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "force_no_h", VALUEFUNC(_wrap_OBMolAtomIter_force_no_h), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBMolAtomIter_has_no_hforced), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "force_impl_h", VALUEFUNC(_wrap_OBMolAtomIter_force_impl_h), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_impl_hforced", VALUEFUNC(_wrap_OBMolAtomIter_has_impl_hforced), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBMolAtomIter_count_free_oxygens), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomIter_implicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBMolAtomIter_explicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBMolAtomIter_member_of_ring_count), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBMolAtomIter_member_of_ring_size), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBMolAtomIter_count_ring_bonds), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBMolAtomIter_smallest_bond_angle), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBMolAtomIter_average_bond_angle), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "bosum", VALUEFUNC(_wrap_OBMolAtomIter_bosum), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "kbosum", VALUEFUNC(_wrap_OBMolAtomIter_kbosum), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_residue", VALUEFUNC(_wrap_OBMolAtomIter_has_residue), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_hydrogen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_carbon", VALUEFUNC(_wrap_OBMolAtomIter_is_carbon), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_nitrogen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_oxygen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBMolAtomIter_is_sulfur), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBMolAtomIter_is_phosphorus), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolAtomIter_is_aromatic), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolAtomIter_is_in_ring), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBMolAtomIter_is_in_ring_size), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBMolAtomIter_is_heteroatom), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBMolAtomIter_is_not_cor_h), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_connected", VALUEFUNC(_wrap_OBMolAtomIter_is_connected), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_one_three", VALUEFUNC(_wrap_OBMolAtomIter_is_one_three), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_one_four", VALUEFUNC(_wrap_OBMolAtomIter_is_one_four), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_carboxyl_oxygen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_phosphate_oxygen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_sulfate_oxygen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBMolAtomIter_is_nitro_oxygen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_amide_nitrogen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_polar_hydrogen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBMolAtomIter_is_non_polar_hydrogen), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBMolAtomIter_is_aromatic_noxide), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_chiral", VALUEFUNC(_wrap_OBMolAtomIter_is_chiral), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_axial", VALUEFUNC(_wrap_OBMolAtomIter_is_axial), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBMolAtomIter_is_clockwise), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBMolAtomIter_is_anti_clockwise), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBMolAtomIter_is_positive_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBMolAtomIter_is_negative_stereo), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBMolAtomIter_has_chirality_specified), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBMolAtomIter_has_chiral_volume), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBMolAtomIter_is_hbond_acceptor), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBMolAtomIter_is_hbond_donor), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBMolAtomIter_is_hbond_donor_h), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBMolAtomIter_has_alpha_beta_unsat), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBMolAtomIter_has_bond_of_order), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBMolAtomIter_count_bonds_of_order), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_non_single_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_single_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_double_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBMolAtomIter_has_aromatic_bond), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBMolAtomIter_matches_smarts), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "clear", VALUEFUNC(_wrap_OBMolAtomIter_clear), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "do_transformations", VALUEFUNC(_wrap_OBMolAtomIter_do_transformations), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "class_description", VALUEFUNC(_wrap_OBMolAtomIter_class_description), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "has_data", VALUEFUNC(_wrap_OBMolAtomIter_has_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "delete_data", VALUEFUNC(_wrap_OBMolAtomIter_delete_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "set_data", VALUEFUNC(_wrap_OBMolAtomIter_set_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "clone_data", VALUEFUNC(_wrap_OBMolAtomIter_clone_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "data_size", VALUEFUNC(_wrap_OBMolAtomIter_data_size), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_data", VALUEFUNC(_wrap_OBMolAtomIter_get_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "get_all_data", VALUEFUNC(_wrap_OBMolAtomIter_get_all_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "begin_data", VALUEFUNC(_wrap_OBMolAtomIter_begin_data), -1);
  rb_define_method(SwigClassOBMolAtomIter.klass, "end_data", VALUEFUNC(_wrap_OBMolAtomIter_end_data), -1);
  SwigClassOBMolAtomIter.mark = 0;
  SwigClassOBMolAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAtomIter;
  SwigClassOBMolAtomIter.trackObjects = 0;
  
  SwigClassOBMolBondIter.klass = rb_define_class_under(mOpenBabel, "OBMolBondIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolBondIter, (void *) &SwigClassOBMolBondIter);
  rb_define_alloc_func(SwigClassOBMolBondIter.klass, _wrap_OBMolBondIter_allocate);
  rb_define_method(SwigClassOBMolBondIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolBondIter), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "good", VALUEFUNC(_wrap_OBMolBondIter_good), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "inc", VALUEFUNC(_wrap_OBMolBondIter_inc), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "deref", VALUEFUNC(_wrap_OBMolBondIter_deref), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolBondIter___ref__), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "Visit=", VALUEFUNC(_wrap_OBMolBondIter_Visit_set), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "Visit", VALUEFUNC(_wrap_OBMolBondIter_Visit_get), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_idx", VALUEFUNC(_wrap_OBMolBondIter_set_idx), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_bo", VALUEFUNC(_wrap_OBMolBondIter_set_bo), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_bond_order", VALUEFUNC(_wrap_OBMolBondIter_set_bond_order), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_begin", VALUEFUNC(_wrap_OBMolBondIter_set_begin), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_end", VALUEFUNC(_wrap_OBMolBondIter_set_end), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolBondIter_set_parent), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_length", VALUEFUNC(_wrap_OBMolBondIter_set_length), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set", VALUEFUNC(_wrap_OBMolBondIter_set), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_ksingle", VALUEFUNC(_wrap_OBMolBondIter_set_ksingle), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_kdouble", VALUEFUNC(_wrap_OBMolBondIter_set_kdouble), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_ktriple", VALUEFUNC(_wrap_OBMolBondIter_set_ktriple), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBMolBondIter_set_aromatic), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_hash", VALUEFUNC(_wrap_OBMolBondIter_set_hash), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_wedge", VALUEFUNC(_wrap_OBMolBondIter_set_wedge), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_up", VALUEFUNC(_wrap_OBMolBondIter_set_up), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_down", VALUEFUNC(_wrap_OBMolBondIter_set_down), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBMolBondIter_set_in_ring), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_closure", VALUEFUNC(_wrap_OBMolBondIter_set_closure), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "unset_hash", VALUEFUNC(_wrap_OBMolBondIter_unset_hash), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "unset_wedge", VALUEFUNC(_wrap_OBMolBondIter_unset_wedge), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "unset_up", VALUEFUNC(_wrap_OBMolBondIter_unset_up), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "unset_down", VALUEFUNC(_wrap_OBMolBondIter_unset_down), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBMolBondIter_unset_aromatic), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "unset_kekule", VALUEFUNC(_wrap_OBMolBondIter_unset_kekule), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_idx", VALUEFUNC(_wrap_OBMolBondIter_get_idx), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_bo", VALUEFUNC(_wrap_OBMolBondIter_get_bo), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_bond_order", VALUEFUNC(_wrap_OBMolBondIter_get_bond_order), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_flags", VALUEFUNC(_wrap_OBMolBondIter_get_flags), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_begin_atom_idx", VALUEFUNC(_wrap_OBMolBondIter_get_begin_atom_idx), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_end_atom_idx", VALUEFUNC(_wrap_OBMolBondIter_get_end_atom_idx), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_begin_atom", VALUEFUNC(_wrap_OBMolBondIter_get_begin_atom), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_end_atom", VALUEFUNC(_wrap_OBMolBondIter_get_end_atom), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_nbr_atom", VALUEFUNC(_wrap_OBMolBondIter_get_nbr_atom), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolBondIter_get_parent), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_equib_length", VALUEFUNC(_wrap_OBMolBondIter_get_equib_length), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_length", VALUEFUNC(_wrap_OBMolBondIter_get_length), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_nbr_atom_idx", VALUEFUNC(_wrap_OBMolBondIter_get_nbr_atom_idx), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolBondIter_is_aromatic), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolBondIter_is_in_ring), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_rotor", VALUEFUNC(_wrap_OBMolBondIter_is_rotor), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_amide", VALUEFUNC(_wrap_OBMolBondIter_is_amide), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_primary_amide", VALUEFUNC(_wrap_OBMolBondIter_is_primary_amide), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_secondary_amide", VALUEFUNC(_wrap_OBMolBondIter_is_secondary_amide), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_ester", VALUEFUNC(_wrap_OBMolBondIter_is_ester), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_carbonyl", VALUEFUNC(_wrap_OBMolBondIter_is_carbonyl), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_single", VALUEFUNC(_wrap_OBMolBondIter_is_single), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_double", VALUEFUNC(_wrap_OBMolBondIter_is_double), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_triple", VALUEFUNC(_wrap_OBMolBondIter_is_triple), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_ksingle", VALUEFUNC(_wrap_OBMolBondIter_is_ksingle), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_kdouble", VALUEFUNC(_wrap_OBMolBondIter_is_kdouble), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_ktriple", VALUEFUNC(_wrap_OBMolBondIter_is_ktriple), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_closure", VALUEFUNC(_wrap_OBMolBondIter_is_closure), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_up", VALUEFUNC(_wrap_OBMolBondIter_is_up), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_down", VALUEFUNC(_wrap_OBMolBondIter_is_down), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_wedge", VALUEFUNC(_wrap_OBMolBondIter_is_wedge), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_hash", VALUEFUNC(_wrap_OBMolBondIter_is_hash), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "is_double_bond_geometry", VALUEFUNC(_wrap_OBMolBondIter_is_double_bond_geometry), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "clear", VALUEFUNC(_wrap_OBMolBondIter_clear), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "do_transformations", VALUEFUNC(_wrap_OBMolBondIter_do_transformations), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "class_description", VALUEFUNC(_wrap_OBMolBondIter_class_description), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "has_data", VALUEFUNC(_wrap_OBMolBondIter_has_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "delete_data", VALUEFUNC(_wrap_OBMolBondIter_delete_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "set_data", VALUEFUNC(_wrap_OBMolBondIter_set_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "clone_data", VALUEFUNC(_wrap_OBMolBondIter_clone_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "data_size", VALUEFUNC(_wrap_OBMolBondIter_data_size), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_data", VALUEFUNC(_wrap_OBMolBondIter_get_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "get_all_data", VALUEFUNC(_wrap_OBMolBondIter_get_all_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "begin_data", VALUEFUNC(_wrap_OBMolBondIter_begin_data), -1);
  rb_define_method(SwigClassOBMolBondIter.klass, "end_data", VALUEFUNC(_wrap_OBMolBondIter_end_data), -1);
  SwigClassOBMolBondIter.mark = 0;
  SwigClassOBMolBondIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolBondIter;
  SwigClassOBMolBondIter.trackObjects = 0;
  
  SwigClassOBAtomAtomIter.klass = rb_define_class_under(mOpenBabel, "OBAtomAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtomAtomIter, (void *) &SwigClassOBAtomAtomIter);
  rb_define_alloc_func(SwigClassOBAtomAtomIter.klass, _wrap_OBAtomAtomIter_allocate);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBAtomAtomIter), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "good", VALUEFUNC(_wrap_OBAtomAtomIter_good), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "inc", VALUEFUNC(_wrap_OBAtomAtomIter_inc), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "deref", VALUEFUNC(_wrap_OBAtomAtomIter_deref), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBAtomAtomIter___ref__), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBAtomAtomIter_Visit_set), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBAtomAtomIter_Visit_get), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "duplicate", VALUEFUNC(_wrap_OBAtomAtomIter_duplicate), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_idx", VALUEFUNC(_wrap_OBAtomAtomIter_set_idx), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_hyb", VALUEFUNC(_wrap_OBAtomAtomIter_set_hyb), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBAtomAtomIter_set_atomic_num), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_isotope", VALUEFUNC(_wrap_OBAtomAtomIter_set_isotope), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_set_implicit_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_increment_implicit_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_decrement_implicit_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBAtomAtomIter_set_formal_charge), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBAtomAtomIter_set_spin_multiplicity), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_type", VALUEFUNC(_wrap_OBAtomAtomIter_set_type), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBAtomAtomIter_set_partial_charge), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_vector", VALUEFUNC(_wrap_OBAtomAtomIter_set_vector), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBAtomAtomIter_set_coord_ptr), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_residue", VALUEFUNC(_wrap_OBAtomAtomIter_set_residue), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_parent", VALUEFUNC(_wrap_OBAtomAtomIter_set_parent), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBAtomAtomIter_set_aromatic), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBAtomAtomIter_unset_aromatic), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_clockwise_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_anti_clockwise_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_positive_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_set_negative_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_unset_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBAtomAtomIter_set_in_ring), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_chiral", VALUEFUNC(_wrap_OBAtomAtomIter_set_chiral), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBAtomAtomIter_clear_coord_ptr), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBAtomAtomIter_get_formal_charge), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBAtomAtomIter_get_atomic_num), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_isotope", VALUEFUNC(_wrap_OBAtomAtomIter_get_isotope), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBAtomAtomIter_get_spin_multiplicity), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBAtomAtomIter_get_atomic_mass), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBAtomAtomIter_get_exact_mass), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_idx", VALUEFUNC(_wrap_OBAtomAtomIter_get_idx), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBAtomAtomIter_get_coordinate_idx), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_cidx", VALUEFUNC(_wrap_OBAtomAtomIter_get_cidx), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_hyb", VALUEFUNC(_wrap_OBAtomAtomIter_get_hyb), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_implicit_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_hvy_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBAtomAtomIter_get_hetero_valence), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_type", VALUEFUNC(_wrap_OBAtomAtomIter_get_type), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_x", VALUEFUNC(_wrap_OBAtomAtomIter_get_x), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_y", VALUEFUNC(_wrap_OBAtomAtomIter_get_y), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_z", VALUEFUNC(_wrap_OBAtomAtomIter_get_z), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "x", VALUEFUNC(_wrap_OBAtomAtomIter_x), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "y", VALUEFUNC(_wrap_OBAtomAtomIter_y), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "z", VALUEFUNC(_wrap_OBAtomAtomIter_z), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBAtomAtomIter_get_coordinate), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_vector", VALUEFUNC(_wrap_OBAtomAtomIter_get_vector), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBAtomAtomIter_get_partial_charge), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_residue", VALUEFUNC(_wrap_OBAtomAtomIter_get_residue), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_parent", VALUEFUNC(_wrap_OBAtomAtomIter_get_parent), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBAtomAtomIter_get_new_bond_vector), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_bond", VALUEFUNC(_wrap_OBAtomAtomIter_get_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBAtomAtomIter_get_next_atom), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBAtomAtomIter_begin_bonds), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "end_bonds", VALUEFUNC(_wrap_OBAtomAtomIter_end_bonds), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "begin_bond", VALUEFUNC(_wrap_OBAtomAtomIter_begin_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "next_bond", VALUEFUNC(_wrap_OBAtomAtomIter_next_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBAtomAtomIter_begin_nbr_atom), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBAtomAtomIter_next_nbr_atom), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_distance", VALUEFUNC(_wrap_OBAtomAtomIter_get_distance), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_angle", VALUEFUNC(_wrap_OBAtomAtomIter_get_angle), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "new_residue", VALUEFUNC(_wrap_OBAtomAtomIter_new_residue), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "add_residue", VALUEFUNC(_wrap_OBAtomAtomIter_add_residue), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "delete_residue", VALUEFUNC(_wrap_OBAtomAtomIter_delete_residue), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "add_bond", VALUEFUNC(_wrap_OBAtomAtomIter_add_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "insert_bond", VALUEFUNC(_wrap_OBAtomAtomIter_insert_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "delete_bond", VALUEFUNC(_wrap_OBAtomAtomIter_delete_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "clear_bond", VALUEFUNC(_wrap_OBAtomAtomIter_clear_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBAtomAtomIter_hto_methyl), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBAtomAtomIter_set_hyb_and_geom), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "force_no_h", VALUEFUNC(_wrap_OBAtomAtomIter_force_no_h), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBAtomAtomIter_has_no_hforced), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "force_impl_h", VALUEFUNC(_wrap_OBAtomAtomIter_force_impl_h), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_impl_hforced", VALUEFUNC(_wrap_OBAtomAtomIter_has_impl_hforced), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBAtomAtomIter_count_free_oxygens), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBAtomAtomIter_implicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBAtomAtomIter_explicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBAtomAtomIter_member_of_ring_count), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBAtomAtomIter_member_of_ring_size), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBAtomAtomIter_count_ring_bonds), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBAtomAtomIter_smallest_bond_angle), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBAtomAtomIter_average_bond_angle), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "bosum", VALUEFUNC(_wrap_OBAtomAtomIter_bosum), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "kbosum", VALUEFUNC(_wrap_OBAtomAtomIter_kbosum), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_residue", VALUEFUNC(_wrap_OBAtomAtomIter_has_residue), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_hydrogen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_carbon", VALUEFUNC(_wrap_OBAtomAtomIter_is_carbon), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_nitrogen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_oxygen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBAtomAtomIter_is_sulfur), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBAtomAtomIter_is_phosphorus), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBAtomAtomIter_is_aromatic), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBAtomAtomIter_is_in_ring), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBAtomAtomIter_is_in_ring_size), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBAtomAtomIter_is_heteroatom), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBAtomAtomIter_is_not_cor_h), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_connected", VALUEFUNC(_wrap_OBAtomAtomIter_is_connected), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_one_three", VALUEFUNC(_wrap_OBAtomAtomIter_is_one_three), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_one_four", VALUEFUNC(_wrap_OBAtomAtomIter_is_one_four), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_carboxyl_oxygen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_phosphate_oxygen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_sulfate_oxygen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBAtomAtomIter_is_nitro_oxygen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_amide_nitrogen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_polar_hydrogen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBAtomAtomIter_is_non_polar_hydrogen), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBAtomAtomIter_is_aromatic_noxide), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_chiral", VALUEFUNC(_wrap_OBAtomAtomIter_is_chiral), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_axial", VALUEFUNC(_wrap_OBAtomAtomIter_is_axial), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBAtomAtomIter_is_clockwise), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBAtomAtomIter_is_anti_clockwise), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_is_positive_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBAtomAtomIter_is_negative_stereo), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBAtomAtomIter_has_chirality_specified), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBAtomAtomIter_has_chiral_volume), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBAtomAtomIter_is_hbond_acceptor), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBAtomAtomIter_is_hbond_donor), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBAtomAtomIter_is_hbond_donor_h), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBAtomAtomIter_has_alpha_beta_unsat), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBAtomAtomIter_has_bond_of_order), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBAtomAtomIter_count_bonds_of_order), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_non_single_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_single_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_double_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBAtomAtomIter_has_aromatic_bond), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBAtomAtomIter_matches_smarts), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "clear", VALUEFUNC(_wrap_OBAtomAtomIter_clear), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "do_transformations", VALUEFUNC(_wrap_OBAtomAtomIter_do_transformations), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "class_description", VALUEFUNC(_wrap_OBAtomAtomIter_class_description), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "has_data", VALUEFUNC(_wrap_OBAtomAtomIter_has_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "delete_data", VALUEFUNC(_wrap_OBAtomAtomIter_delete_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "set_data", VALUEFUNC(_wrap_OBAtomAtomIter_set_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "clone_data", VALUEFUNC(_wrap_OBAtomAtomIter_clone_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "data_size", VALUEFUNC(_wrap_OBAtomAtomIter_data_size), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_data", VALUEFUNC(_wrap_OBAtomAtomIter_get_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "get_all_data", VALUEFUNC(_wrap_OBAtomAtomIter_get_all_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "begin_data", VALUEFUNC(_wrap_OBAtomAtomIter_begin_data), -1);
  rb_define_method(SwigClassOBAtomAtomIter.klass, "end_data", VALUEFUNC(_wrap_OBAtomAtomIter_end_data), -1);
  SwigClassOBAtomAtomIter.mark = 0;
  SwigClassOBAtomAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBAtomAtomIter;
  SwigClassOBAtomAtomIter.trackObjects = 0;
  
  SwigClassOBAtomBondIter.klass = rb_define_class_under(mOpenBabel, "OBAtomBondIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBAtomBondIter, (void *) &SwigClassOBAtomBondIter);
  rb_define_alloc_func(SwigClassOBAtomBondIter.klass, _wrap_OBAtomBondIter_allocate);
  rb_define_method(SwigClassOBAtomBondIter.klass, "initialize", VALUEFUNC(_wrap_new_OBAtomBondIter), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "good", VALUEFUNC(_wrap_OBAtomBondIter_good), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "inc", VALUEFUNC(_wrap_OBAtomBondIter_inc), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "deref", VALUEFUNC(_wrap_OBAtomBondIter_deref), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "__ref__", VALUEFUNC(_wrap_OBAtomBondIter___ref__), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "Visit=", VALUEFUNC(_wrap_OBAtomBondIter_Visit_set), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "Visit", VALUEFUNC(_wrap_OBAtomBondIter_Visit_get), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_idx", VALUEFUNC(_wrap_OBAtomBondIter_set_idx), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_bo", VALUEFUNC(_wrap_OBAtomBondIter_set_bo), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_bond_order", VALUEFUNC(_wrap_OBAtomBondIter_set_bond_order), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_begin", VALUEFUNC(_wrap_OBAtomBondIter_set_begin), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_end", VALUEFUNC(_wrap_OBAtomBondIter_set_end), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_parent", VALUEFUNC(_wrap_OBAtomBondIter_set_parent), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_length", VALUEFUNC(_wrap_OBAtomBondIter_set_length), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set", VALUEFUNC(_wrap_OBAtomBondIter_set), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_ksingle", VALUEFUNC(_wrap_OBAtomBondIter_set_ksingle), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_kdouble", VALUEFUNC(_wrap_OBAtomBondIter_set_kdouble), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_ktriple", VALUEFUNC(_wrap_OBAtomBondIter_set_ktriple), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBAtomBondIter_set_aromatic), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_hash", VALUEFUNC(_wrap_OBAtomBondIter_set_hash), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_wedge", VALUEFUNC(_wrap_OBAtomBondIter_set_wedge), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_up", VALUEFUNC(_wrap_OBAtomBondIter_set_up), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_down", VALUEFUNC(_wrap_OBAtomBondIter_set_down), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBAtomBondIter_set_in_ring), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_closure", VALUEFUNC(_wrap_OBAtomBondIter_set_closure), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "unset_hash", VALUEFUNC(_wrap_OBAtomBondIter_unset_hash), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "unset_wedge", VALUEFUNC(_wrap_OBAtomBondIter_unset_wedge), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "unset_up", VALUEFUNC(_wrap_OBAtomBondIter_unset_up), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "unset_down", VALUEFUNC(_wrap_OBAtomBondIter_unset_down), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBAtomBondIter_unset_aromatic), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "unset_kekule", VALUEFUNC(_wrap_OBAtomBondIter_unset_kekule), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_idx), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_bo", VALUEFUNC(_wrap_OBAtomBondIter_get_bo), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_bond_order", VALUEFUNC(_wrap_OBAtomBondIter_get_bond_order), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_flags", VALUEFUNC(_wrap_OBAtomBondIter_get_flags), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_begin_atom_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_begin_atom_idx), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_end_atom_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_end_atom_idx), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_begin_atom", VALUEFUNC(_wrap_OBAtomBondIter_get_begin_atom), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_end_atom", VALUEFUNC(_wrap_OBAtomBondIter_get_end_atom), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_nbr_atom", VALUEFUNC(_wrap_OBAtomBondIter_get_nbr_atom), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_parent", VALUEFUNC(_wrap_OBAtomBondIter_get_parent), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_equib_length", VALUEFUNC(_wrap_OBAtomBondIter_get_equib_length), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_length", VALUEFUNC(_wrap_OBAtomBondIter_get_length), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_nbr_atom_idx", VALUEFUNC(_wrap_OBAtomBondIter_get_nbr_atom_idx), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBAtomBondIter_is_aromatic), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBAtomBondIter_is_in_ring), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_rotor", VALUEFUNC(_wrap_OBAtomBondIter_is_rotor), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_amide", VALUEFUNC(_wrap_OBAtomBondIter_is_amide), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_primary_amide", VALUEFUNC(_wrap_OBAtomBondIter_is_primary_amide), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_secondary_amide", VALUEFUNC(_wrap_OBAtomBondIter_is_secondary_amide), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_ester", VALUEFUNC(_wrap_OBAtomBondIter_is_ester), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_carbonyl", VALUEFUNC(_wrap_OBAtomBondIter_is_carbonyl), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_single", VALUEFUNC(_wrap_OBAtomBondIter_is_single), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_double", VALUEFUNC(_wrap_OBAtomBondIter_is_double), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_triple", VALUEFUNC(_wrap_OBAtomBondIter_is_triple), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_ksingle", VALUEFUNC(_wrap_OBAtomBondIter_is_ksingle), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_kdouble", VALUEFUNC(_wrap_OBAtomBondIter_is_kdouble), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_ktriple", VALUEFUNC(_wrap_OBAtomBondIter_is_ktriple), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_closure", VALUEFUNC(_wrap_OBAtomBondIter_is_closure), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_up", VALUEFUNC(_wrap_OBAtomBondIter_is_up), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_down", VALUEFUNC(_wrap_OBAtomBondIter_is_down), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_wedge", VALUEFUNC(_wrap_OBAtomBondIter_is_wedge), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_hash", VALUEFUNC(_wrap_OBAtomBondIter_is_hash), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "is_double_bond_geometry", VALUEFUNC(_wrap_OBAtomBondIter_is_double_bond_geometry), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "clear", VALUEFUNC(_wrap_OBAtomBondIter_clear), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "do_transformations", VALUEFUNC(_wrap_OBAtomBondIter_do_transformations), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "class_description", VALUEFUNC(_wrap_OBAtomBondIter_class_description), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "has_data", VALUEFUNC(_wrap_OBAtomBondIter_has_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "delete_data", VALUEFUNC(_wrap_OBAtomBondIter_delete_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "set_data", VALUEFUNC(_wrap_OBAtomBondIter_set_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "clone_data", VALUEFUNC(_wrap_OBAtomBondIter_clone_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "data_size", VALUEFUNC(_wrap_OBAtomBondIter_data_size), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_data", VALUEFUNC(_wrap_OBAtomBondIter_get_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "get_all_data", VALUEFUNC(_wrap_OBAtomBondIter_get_all_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "begin_data", VALUEFUNC(_wrap_OBAtomBondIter_begin_data), -1);
  rb_define_method(SwigClassOBAtomBondIter.klass, "end_data", VALUEFUNC(_wrap_OBAtomBondIter_end_data), -1);
  SwigClassOBAtomBondIter.mark = 0;
  SwigClassOBAtomBondIter.destroy = (void (*)(void *)) free_OpenBabel_OBAtomBondIter;
  SwigClassOBAtomBondIter.trackObjects = 0;
  
  SwigClassOBResidueIter.klass = rb_define_class_under(mOpenBabel, "OBResidueIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueIter, (void *) &SwigClassOBResidueIter);
  rb_define_alloc_func(SwigClassOBResidueIter.klass, _wrap_OBResidueIter_allocate);
  rb_define_method(SwigClassOBResidueIter.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueIter), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "good", VALUEFUNC(_wrap_OBResidueIter_good), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "inc", VALUEFUNC(_wrap_OBResidueIter_inc), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "deref", VALUEFUNC(_wrap_OBResidueIter_deref), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "__ref__", VALUEFUNC(_wrap_OBResidueIter___ref__), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "add_atom", VALUEFUNC(_wrap_OBResidueIter_add_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "insert_atom", VALUEFUNC(_wrap_OBResidueIter_insert_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "remove_atom", VALUEFUNC(_wrap_OBResidueIter_remove_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_name", VALUEFUNC(_wrap_OBResidueIter_set_name), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_num", VALUEFUNC(_wrap_OBResidueIter_set_num), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_chain", VALUEFUNC(_wrap_OBResidueIter_set_chain), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_chain_num", VALUEFUNC(_wrap_OBResidueIter_set_chain_num), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_idx", VALUEFUNC(_wrap_OBResidueIter_set_idx), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_atom_id", VALUEFUNC(_wrap_OBResidueIter_set_atom_id), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_het_atom", VALUEFUNC(_wrap_OBResidueIter_set_het_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_serial_num", VALUEFUNC(_wrap_OBResidueIter_set_serial_num), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_name", VALUEFUNC(_wrap_OBResidueIter_get_name), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_num", VALUEFUNC(_wrap_OBResidueIter_get_num), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_num_string", VALUEFUNC(_wrap_OBResidueIter_get_num_string), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_num_atoms", VALUEFUNC(_wrap_OBResidueIter_get_num_atoms), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_chain", VALUEFUNC(_wrap_OBResidueIter_get_chain), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_chain_num", VALUEFUNC(_wrap_OBResidueIter_get_chain_num), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_idx", VALUEFUNC(_wrap_OBResidueIter_get_idx), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_res_key", VALUEFUNC(_wrap_OBResidueIter_get_res_key), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_atoms", VALUEFUNC(_wrap_OBResidueIter_get_atoms), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_bonds", VALUEFUNC(_wrap_OBResidueIter_get_bonds), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_atom_id", VALUEFUNC(_wrap_OBResidueIter_get_atom_id), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_serial_num", VALUEFUNC(_wrap_OBResidueIter_get_serial_num), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_amino_acid_property", VALUEFUNC(_wrap_OBResidueIter_get_amino_acid_property), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_atom_property", VALUEFUNC(_wrap_OBResidueIter_get_atom_property), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_residue_property", VALUEFUNC(_wrap_OBResidueIter_get_residue_property), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "is_het_atom", VALUEFUNC(_wrap_OBResidueIter_is_het_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "is_residue_type", VALUEFUNC(_wrap_OBResidueIter_is_residue_type), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "begin_atoms", VALUEFUNC(_wrap_OBResidueIter_begin_atoms), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "end_atoms", VALUEFUNC(_wrap_OBResidueIter_end_atoms), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "begin_atom", VALUEFUNC(_wrap_OBResidueIter_begin_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "next_atom", VALUEFUNC(_wrap_OBResidueIter_next_atom), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "clear", VALUEFUNC(_wrap_OBResidueIter_clear), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "do_transformations", VALUEFUNC(_wrap_OBResidueIter_do_transformations), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "class_description", VALUEFUNC(_wrap_OBResidueIter_class_description), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "has_data", VALUEFUNC(_wrap_OBResidueIter_has_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "delete_data", VALUEFUNC(_wrap_OBResidueIter_delete_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "set_data", VALUEFUNC(_wrap_OBResidueIter_set_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "clone_data", VALUEFUNC(_wrap_OBResidueIter_clone_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "data_size", VALUEFUNC(_wrap_OBResidueIter_data_size), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_data", VALUEFUNC(_wrap_OBResidueIter_get_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "get_all_data", VALUEFUNC(_wrap_OBResidueIter_get_all_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "begin_data", VALUEFUNC(_wrap_OBResidueIter_begin_data), -1);
  rb_define_method(SwigClassOBResidueIter.klass, "end_data", VALUEFUNC(_wrap_OBResidueIter_end_data), -1);
  SwigClassOBResidueIter.mark = 0;
  SwigClassOBResidueIter.destroy = (void (*)(void *)) free_OpenBabel_OBResidueIter;
  SwigClassOBResidueIter.trackObjects = 0;
  
  SwigClassOBResidueAtomIter.klass = rb_define_class_under(mOpenBabel, "OBResidueAtomIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBResidueAtomIter, (void *) &SwigClassOBResidueAtomIter);
  rb_define_alloc_func(SwigClassOBResidueAtomIter.klass, _wrap_OBResidueAtomIter_allocate);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "initialize", VALUEFUNC(_wrap_new_OBResidueAtomIter), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "good", VALUEFUNC(_wrap_OBResidueAtomIter_good), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "inc", VALUEFUNC(_wrap_OBResidueAtomIter_inc), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "deref", VALUEFUNC(_wrap_OBResidueAtomIter_deref), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "__ref__", VALUEFUNC(_wrap_OBResidueAtomIter___ref__), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "Visit=", VALUEFUNC(_wrap_OBResidueAtomIter_Visit_set), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "Visit", VALUEFUNC(_wrap_OBResidueAtomIter_Visit_get), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "duplicate", VALUEFUNC(_wrap_OBResidueAtomIter_duplicate), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_idx", VALUEFUNC(_wrap_OBResidueAtomIter_set_idx), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_hyb", VALUEFUNC(_wrap_OBResidueAtomIter_set_hyb), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_atomic_num", VALUEFUNC(_wrap_OBResidueAtomIter_set_atomic_num), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_isotope", VALUEFUNC(_wrap_OBResidueAtomIter_set_isotope), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_set_implicit_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "increment_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_increment_implicit_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "decrement_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_decrement_implicit_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_formal_charge", VALUEFUNC(_wrap_OBResidueAtomIter_set_formal_charge), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_spin_multiplicity", VALUEFUNC(_wrap_OBResidueAtomIter_set_spin_multiplicity), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_type", VALUEFUNC(_wrap_OBResidueAtomIter_set_type), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_partial_charge", VALUEFUNC(_wrap_OBResidueAtomIter_set_partial_charge), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_vector", VALUEFUNC(_wrap_OBResidueAtomIter_set_vector), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_coord_ptr", VALUEFUNC(_wrap_OBResidueAtomIter_set_coord_ptr), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_residue", VALUEFUNC(_wrap_OBResidueAtomIter_set_residue), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_parent", VALUEFUNC(_wrap_OBResidueAtomIter_set_parent), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_aromatic", VALUEFUNC(_wrap_OBResidueAtomIter_set_aromatic), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "unset_aromatic", VALUEFUNC(_wrap_OBResidueAtomIter_unset_aromatic), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_clockwise_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_clockwise_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_anti_clockwise_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_anti_clockwise_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_positive_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_positive_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_negative_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_set_negative_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "unset_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_unset_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_in_ring", VALUEFUNC(_wrap_OBResidueAtomIter_set_in_ring), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_chiral", VALUEFUNC(_wrap_OBResidueAtomIter_set_chiral), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "clear_coord_ptr", VALUEFUNC(_wrap_OBResidueAtomIter_clear_coord_ptr), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_formal_charge", VALUEFUNC(_wrap_OBResidueAtomIter_get_formal_charge), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_atomic_num", VALUEFUNC(_wrap_OBResidueAtomIter_get_atomic_num), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_isotope", VALUEFUNC(_wrap_OBResidueAtomIter_get_isotope), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_spin_multiplicity", VALUEFUNC(_wrap_OBResidueAtomIter_get_spin_multiplicity), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_atomic_mass", VALUEFUNC(_wrap_OBResidueAtomIter_get_atomic_mass), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_exact_mass", VALUEFUNC(_wrap_OBResidueAtomIter_get_exact_mass), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_idx", VALUEFUNC(_wrap_OBResidueAtomIter_get_idx), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_coordinate_idx", VALUEFUNC(_wrap_OBResidueAtomIter_get_coordinate_idx), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_cidx", VALUEFUNC(_wrap_OBResidueAtomIter_get_cidx), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_hyb", VALUEFUNC(_wrap_OBResidueAtomIter_get_hyb), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_implicit_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_implicit_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_hvy_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_hvy_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_hetero_valence", VALUEFUNC(_wrap_OBResidueAtomIter_get_hetero_valence), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_type", VALUEFUNC(_wrap_OBResidueAtomIter_get_type), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_x", VALUEFUNC(_wrap_OBResidueAtomIter_get_x), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_y", VALUEFUNC(_wrap_OBResidueAtomIter_get_y), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_z", VALUEFUNC(_wrap_OBResidueAtomIter_get_z), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "x", VALUEFUNC(_wrap_OBResidueAtomIter_x), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "y", VALUEFUNC(_wrap_OBResidueAtomIter_y), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "z", VALUEFUNC(_wrap_OBResidueAtomIter_z), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_coordinate", VALUEFUNC(_wrap_OBResidueAtomIter_get_coordinate), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_vector", VALUEFUNC(_wrap_OBResidueAtomIter_get_vector), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_partial_charge", VALUEFUNC(_wrap_OBResidueAtomIter_get_partial_charge), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_residue", VALUEFUNC(_wrap_OBResidueAtomIter_get_residue), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_parent", VALUEFUNC(_wrap_OBResidueAtomIter_get_parent), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_new_bond_vector", VALUEFUNC(_wrap_OBResidueAtomIter_get_new_bond_vector), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_bond", VALUEFUNC(_wrap_OBResidueAtomIter_get_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_next_atom", VALUEFUNC(_wrap_OBResidueAtomIter_get_next_atom), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "begin_bonds", VALUEFUNC(_wrap_OBResidueAtomIter_begin_bonds), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "end_bonds", VALUEFUNC(_wrap_OBResidueAtomIter_end_bonds), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "begin_bond", VALUEFUNC(_wrap_OBResidueAtomIter_begin_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "next_bond", VALUEFUNC(_wrap_OBResidueAtomIter_next_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "begin_nbr_atom", VALUEFUNC(_wrap_OBResidueAtomIter_begin_nbr_atom), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "next_nbr_atom", VALUEFUNC(_wrap_OBResidueAtomIter_next_nbr_atom), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_distance", VALUEFUNC(_wrap_OBResidueAtomIter_get_distance), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_angle", VALUEFUNC(_wrap_OBResidueAtomIter_get_angle), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "new_residue", VALUEFUNC(_wrap_OBResidueAtomIter_new_residue), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "add_residue", VALUEFUNC(_wrap_OBResidueAtomIter_add_residue), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "delete_residue", VALUEFUNC(_wrap_OBResidueAtomIter_delete_residue), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "add_bond", VALUEFUNC(_wrap_OBResidueAtomIter_add_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "insert_bond", VALUEFUNC(_wrap_OBResidueAtomIter_insert_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "delete_bond", VALUEFUNC(_wrap_OBResidueAtomIter_delete_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "clear_bond", VALUEFUNC(_wrap_OBResidueAtomIter_clear_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "hto_methyl", VALUEFUNC(_wrap_OBResidueAtomIter_hto_methyl), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_hyb_and_geom", VALUEFUNC(_wrap_OBResidueAtomIter_set_hyb_and_geom), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "force_no_h", VALUEFUNC(_wrap_OBResidueAtomIter_force_no_h), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_no_hforced", VALUEFUNC(_wrap_OBResidueAtomIter_has_no_hforced), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "force_impl_h", VALUEFUNC(_wrap_OBResidueAtomIter_force_impl_h), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_impl_hforced", VALUEFUNC(_wrap_OBResidueAtomIter_has_impl_hforced), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "count_free_oxygens", VALUEFUNC(_wrap_OBResidueAtomIter_count_free_oxygens), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "implicit_hydrogen_count", VALUEFUNC(_wrap_OBResidueAtomIter_implicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "explicit_hydrogen_count", VALUEFUNC(_wrap_OBResidueAtomIter_explicit_hydrogen_count), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "member_of_ring_count", VALUEFUNC(_wrap_OBResidueAtomIter_member_of_ring_count), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "member_of_ring_size", VALUEFUNC(_wrap_OBResidueAtomIter_member_of_ring_size), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "count_ring_bonds", VALUEFUNC(_wrap_OBResidueAtomIter_count_ring_bonds), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "smallest_bond_angle", VALUEFUNC(_wrap_OBResidueAtomIter_smallest_bond_angle), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "average_bond_angle", VALUEFUNC(_wrap_OBResidueAtomIter_average_bond_angle), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "bosum", VALUEFUNC(_wrap_OBResidueAtomIter_bosum), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "kbosum", VALUEFUNC(_wrap_OBResidueAtomIter_kbosum), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_residue", VALUEFUNC(_wrap_OBResidueAtomIter_has_residue), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_hydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_hydrogen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_carbon", VALUEFUNC(_wrap_OBResidueAtomIter_is_carbon), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_nitrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_nitrogen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_oxygen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_sulfur", VALUEFUNC(_wrap_OBResidueAtomIter_is_sulfur), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_phosphorus", VALUEFUNC(_wrap_OBResidueAtomIter_is_phosphorus), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBResidueAtomIter_is_aromatic), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBResidueAtomIter_is_in_ring), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_in_ring_size", VALUEFUNC(_wrap_OBResidueAtomIter_is_in_ring_size), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_heteroatom", VALUEFUNC(_wrap_OBResidueAtomIter_is_heteroatom), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_not_cor_h", VALUEFUNC(_wrap_OBResidueAtomIter_is_not_cor_h), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_connected", VALUEFUNC(_wrap_OBResidueAtomIter_is_connected), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_one_three", VALUEFUNC(_wrap_OBResidueAtomIter_is_one_three), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_one_four", VALUEFUNC(_wrap_OBResidueAtomIter_is_one_four), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_carboxyl_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_carboxyl_oxygen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_phosphate_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_phosphate_oxygen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_sulfate_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_sulfate_oxygen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_nitro_oxygen", VALUEFUNC(_wrap_OBResidueAtomIter_is_nitro_oxygen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_amide_nitrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_amide_nitrogen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_polar_hydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_polar_hydrogen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_non_polar_hydrogen", VALUEFUNC(_wrap_OBResidueAtomIter_is_non_polar_hydrogen), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_aromatic_noxide", VALUEFUNC(_wrap_OBResidueAtomIter_is_aromatic_noxide), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_chiral", VALUEFUNC(_wrap_OBResidueAtomIter_is_chiral), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_axial", VALUEFUNC(_wrap_OBResidueAtomIter_is_axial), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_clockwise", VALUEFUNC(_wrap_OBResidueAtomIter_is_clockwise), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_anti_clockwise", VALUEFUNC(_wrap_OBResidueAtomIter_is_anti_clockwise), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_positive_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_is_positive_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_negative_stereo", VALUEFUNC(_wrap_OBResidueAtomIter_is_negative_stereo), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_chirality_specified", VALUEFUNC(_wrap_OBResidueAtomIter_has_chirality_specified), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_chiral_volume", VALUEFUNC(_wrap_OBResidueAtomIter_has_chiral_volume), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_hbond_acceptor", VALUEFUNC(_wrap_OBResidueAtomIter_is_hbond_acceptor), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_hbond_donor", VALUEFUNC(_wrap_OBResidueAtomIter_is_hbond_donor), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "is_hbond_donor_h", VALUEFUNC(_wrap_OBResidueAtomIter_is_hbond_donor_h), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_alpha_beta_unsat", VALUEFUNC(_wrap_OBResidueAtomIter_has_alpha_beta_unsat), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_bond_of_order", VALUEFUNC(_wrap_OBResidueAtomIter_has_bond_of_order), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "count_bonds_of_order", VALUEFUNC(_wrap_OBResidueAtomIter_count_bonds_of_order), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_non_single_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_non_single_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_single_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_single_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_double_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_double_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_aromatic_bond", VALUEFUNC(_wrap_OBResidueAtomIter_has_aromatic_bond), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "matches_smarts", VALUEFUNC(_wrap_OBResidueAtomIter_matches_smarts), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "clear", VALUEFUNC(_wrap_OBResidueAtomIter_clear), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "do_transformations", VALUEFUNC(_wrap_OBResidueAtomIter_do_transformations), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "class_description", VALUEFUNC(_wrap_OBResidueAtomIter_class_description), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "has_data", VALUEFUNC(_wrap_OBResidueAtomIter_has_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "delete_data", VALUEFUNC(_wrap_OBResidueAtomIter_delete_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "set_data", VALUEFUNC(_wrap_OBResidueAtomIter_set_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "clone_data", VALUEFUNC(_wrap_OBResidueAtomIter_clone_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "data_size", VALUEFUNC(_wrap_OBResidueAtomIter_data_size), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_data", VALUEFUNC(_wrap_OBResidueAtomIter_get_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "get_all_data", VALUEFUNC(_wrap_OBResidueAtomIter_get_all_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "begin_data", VALUEFUNC(_wrap_OBResidueAtomIter_begin_data), -1);
  rb_define_method(SwigClassOBResidueAtomIter.klass, "end_data", VALUEFUNC(_wrap_OBResidueAtomIter_end_data), -1);
  SwigClassOBResidueAtomIter.mark = 0;
  SwigClassOBResidueAtomIter.destroy = (void (*)(void *)) free_OpenBabel_OBResidueAtomIter;
  SwigClassOBResidueAtomIter.trackObjects = 0;
  
  SwigClassOBMolAngleIter.klass = rb_define_class_under(mOpenBabel, "OBMolAngleIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolAngleIter, (void *) &SwigClassOBMolAngleIter);
  rb_define_alloc_func(SwigClassOBMolAngleIter.klass, _wrap_OBMolAngleIter_allocate);
  rb_define_method(SwigClassOBMolAngleIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolAngleIter), -1);
  rb_define_method(SwigClassOBMolAngleIter.klass, "good", VALUEFUNC(_wrap_OBMolAngleIter_good), -1);
  rb_define_method(SwigClassOBMolAngleIter.klass, "inc", VALUEFUNC(_wrap_OBMolAngleIter_inc), -1);
  rb_define_method(SwigClassOBMolAngleIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolAngleIter___ref__), -1);
  SwigClassOBMolAngleIter.mark = 0;
  SwigClassOBMolAngleIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolAngleIter;
  SwigClassOBMolAngleIter.trackObjects = 0;
  
  SwigClassOBMolTorsionIter.klass = rb_define_class_under(mOpenBabel, "OBMolTorsionIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolTorsionIter, (void *) &SwigClassOBMolTorsionIter);
  rb_define_alloc_func(SwigClassOBMolTorsionIter.klass, _wrap_OBMolTorsionIter_allocate);
  rb_define_method(SwigClassOBMolTorsionIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolTorsionIter), -1);
  rb_define_method(SwigClassOBMolTorsionIter.klass, "good", VALUEFUNC(_wrap_OBMolTorsionIter_good), -1);
  rb_define_method(SwigClassOBMolTorsionIter.klass, "inc", VALUEFUNC(_wrap_OBMolTorsionIter_inc), -1);
  rb_define_method(SwigClassOBMolTorsionIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolTorsionIter___ref__), -1);
  SwigClassOBMolTorsionIter.mark = 0;
  SwigClassOBMolTorsionIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolTorsionIter;
  SwigClassOBMolTorsionIter.trackObjects = 0;
  
  SwigClassOBMolPairIter.klass = rb_define_class_under(mOpenBabel, "OBMolPairIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolPairIter, (void *) &SwigClassOBMolPairIter);
  rb_define_alloc_func(SwigClassOBMolPairIter.klass, _wrap_OBMolPairIter_allocate);
  rb_define_method(SwigClassOBMolPairIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolPairIter), -1);
  rb_define_method(SwigClassOBMolPairIter.klass, "good", VALUEFUNC(_wrap_OBMolPairIter_good), -1);
  rb_define_method(SwigClassOBMolPairIter.klass, "inc", VALUEFUNC(_wrap_OBMolPairIter_inc), -1);
  rb_define_method(SwigClassOBMolPairIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolPairIter___ref__), -1);
  SwigClassOBMolPairIter.mark = 0;
  SwigClassOBMolPairIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolPairIter;
  SwigClassOBMolPairIter.trackObjects = 0;
  
  SwigClassOBMolRingIter.klass = rb_define_class_under(mOpenBabel, "OBMolRingIter", rb_cObject);
  SWIG_TypeClientData(SWIGTYPE_p_OpenBabel__OBMolRingIter, (void *) &SwigClassOBMolRingIter);
  rb_define_alloc_func(SwigClassOBMolRingIter.klass, _wrap_OBMolRingIter_allocate);
  rb_define_method(SwigClassOBMolRingIter.klass, "initialize", VALUEFUNC(_wrap_new_OBMolRingIter), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "good", VALUEFUNC(_wrap_OBMolRingIter_good), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "inc", VALUEFUNC(_wrap_OBMolRingIter_inc), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "deref", VALUEFUNC(_wrap_OBMolRingIter_deref), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "__ref__", VALUEFUNC(_wrap_OBMolRingIter___ref__), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "_path=", VALUEFUNC(_wrap_OBMolRingIter__path_set), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "_path", VALUEFUNC(_wrap_OBMolRingIter__path_get), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "_pathset=", VALUEFUNC(_wrap_OBMolRingIter__pathset_set), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "_pathset", VALUEFUNC(_wrap_OBMolRingIter__pathset_get), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "size", VALUEFUNC(_wrap_OBMolRingIter_size), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "path_size", VALUEFUNC(_wrap_OBMolRingIter_path_size), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "is_aromatic", VALUEFUNC(_wrap_OBMolRingIter_is_aromatic), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "set_type", VALUEFUNC(_wrap_OBMolRingIter_set_type), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "get_type", VALUEFUNC(_wrap_OBMolRingIter_get_type), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "get_root_atom", VALUEFUNC(_wrap_OBMolRingIter_get_root_atom), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "is_member", VALUEFUNC(_wrap_OBMolRingIter_is_member), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "is_in_ring", VALUEFUNC(_wrap_OBMolRingIter_is_in_ring), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "set_parent", VALUEFUNC(_wrap_OBMolRingIter_set_parent), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "get_parent", VALUEFUNC(_wrap_OBMolRingIter_get_parent), -1);
  rb_define_method(SwigClassOBMolRingIter.klass, "find_center_and_normal", VALUEFUNC(_wrap_OBMolRingIter_find_center_and_normal), -1);
  SwigClassOBMolRingIter.mark = 0;
  SwigClassOBMolRingIter.destroy = (void (*)(void *)) free_OpenBabel_OBMolRingIter;
  SwigClassOBMolRingIter.trackObjects = 0;
}

